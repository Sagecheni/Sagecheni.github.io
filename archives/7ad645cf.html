<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.1.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.proxy.ustclug.org/css?family=Source+Code+Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" integrity="sha256-yIDrPSXHZdOZhAqiBP7CKzIwMQmRCJ8UeB8Jo17YC4o=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.sa1ge.ink","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.19.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":true,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="​ 缓考个人复习用，详细部分在个人未细化的知识点。 ​ 大部分资料来源于《C++程序设计》刘瑞芳主编。 ​ 集中在数据类型：  数组  普通数组 多维数组 字符数组  枚举(enum)、结构(struct)类型、联合类型(union) 类和对象（重点）  ​ 函数：  函数调用 参数传递（值传和地址传） 变量类型(四类) 内联(inline)和重载(overload)  ​ 指针（重点）：  指针">
<meta property="og:type" content="article">
<meta property="og:title" content="C++程序语言设计复习提纲">
<meta property="og:url" content="http://blog.sa1ge.ink/archives/7ad645cf.html">
<meta property="og:site_name" content="Sa1ge &#39;s Blog">
<meta property="og:description" content="​ 缓考个人复习用，详细部分在个人未细化的知识点。 ​ 大部分资料来源于《C++程序设计》刘瑞芳主编。 ​ 集中在数据类型：  数组  普通数组 多维数组 字符数组  枚举(enum)、结构(struct)类型、联合类型(union) 类和对象（重点）  ​ 函数：  函数调用 参数传递（值传和地址传） 变量类型(四类) 内联(inline)和重载(overload)  ​ 指针（重点）：  指针">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207003559609.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207165455521.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207195532331.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207234815346.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207235210234.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208002424370.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208004012723.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208114214213.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208125027759.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208152438945.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208155056171.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208163428475.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208175347976.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208183728480.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208190629572.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209213603588.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209113316738.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209123159944.png">
<meta property="og:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209125439645.png">
<meta property="article:published_time" content="2023-02-09T07:30:44.000Z">
<meta property="article:modified_time" content="2024-01-26T14:59:13.954Z">
<meta property="article:author" content="Sa1geChen">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Review">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207003559609.png">


<link rel="canonical" href="http://blog.sa1ge.ink/archives/7ad645cf.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"http://blog.sa1ge.ink/archives/7ad645cf.html","path":"archives/7ad645cf.html","title":"C++程序语言设计复习提纲"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++程序语言设计复习提纲 | Sa1ge 's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Sa1ge 's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">程序设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">程序开发过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">内存模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">第二章：基本数据类型与表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E8%AE%B0%E5%8F%B7%E5%92%8C%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">1.</span> <span class="nav-text">词法记号和标识符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">变量和常量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.1.</span> <span class="nav-text">符号常量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B4%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">整型常量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E5%9E%8B%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.3.</span> <span class="nav-text">实型常量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.4.</span> <span class="nav-text">字符常量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.5.</span> <span class="nav-text">字符串常量：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%B8%B8%E9%87%8F"><span class="nav-number">3.2.6.</span> <span class="nav-text">逻辑常量：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">运算符和表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">4.0.1.</span> <span class="nav-text">位运算：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">4.0.2.</span> <span class="nav-text">数据类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">4.1.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%87%BA"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%BE%93%E5%85%A5"><span class="nav-number">4.1.2.</span> <span class="nav-text">基本输入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">4.1.3.</span> <span class="nav-text">标准输入输出流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sizeof%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">4.2.</span> <span class="nav-text">sizeof运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">输出格式控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#string"><span class="nav-number">4.4.</span> <span class="nav-text">string</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="nav-number">4.5.</span> <span class="nav-text">文件读写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number"></span> <span class="nav-text">第三章：控制语句</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">基本控制结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%8F%8A%E5%85%B6%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.1.</span> <span class="nav-text">算法及其表示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#switch"><span class="nav-number">1.1.1.</span> <span class="nav-text">switch</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.2.</span> <span class="nav-text">循环结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">随机数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%B5%8C%E5%A5%97"><span class="nav-number">3.</span> <span class="nav-text">结构嵌套</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%95%B0%E7%BB%84%E5%8F%8A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">第四章：数组及自定义数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84array"><span class="nav-number">1.</span> <span class="nav-text">数组（Array）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E7%BB%84"><span class="nav-number">1.1.</span> <span class="nav-text">定义数组：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">数组初始化：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="nav-number">1.3.</span> <span class="nav-text">访问数组元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.</span> <span class="nav-text">字符数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.1.</span> <span class="nav-text">初始化字符数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="nav-number">1.4.2.</span> <span class="nav-text">字符数组的赋值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.</span> <span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8Benum"><span class="nav-number">2.</span> <span class="nav-text">枚举类型(enum)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">枚举类型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">2.2.</span> <span class="nav-text">枚举变量定义及使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8Bstruct"><span class="nav-number">3.</span> <span class="nav-text">结构类型(struct)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.1.</span> <span class="nav-text">结构类型的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">结构变量的定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.</span> <span class="nav-text">结构变量的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="nav-number">3.4.</span> <span class="nav-text">结构变量的赋值运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8Bunion"><span class="nav-number">4.</span> <span class="nav-text">联合类型(union)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA"><span class="nav-number">5.</span> <span class="nav-text">字符串的输入与输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">内存空间问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E6%94%BE"><span class="nav-number">6.1.</span> <span class="nav-text">多维数组在内存中的存放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">6.2.</span> <span class="nav-text">枚举类型的内存空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">6.3.</span> <span class="nav-text">结构类型的内存空间</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">第五章：函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%A6%82%E8%BF%B0"><span class="nav-number">1.1.</span> <span class="nav-text">自定义函数概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0"><span class="nav-number">1.2.</span> <span class="nav-text">库函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.</span> <span class="nav-text">函数的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0"><span class="nav-number">2.1.</span> <span class="nav-text">定义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">函数原型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return%E8%AF%AD%E5%8F%A5"><span class="nav-number">2.3.</span> <span class="nav-text">return语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">函数的调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">4.</span> <span class="nav-text">全局变量与局部变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">4.1.</span> <span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="nav-number">4.2.</span> <span class="nav-text">全局变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">4.3.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">4.4.</span> <span class="nav-text">可见性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">5.</span> <span class="nav-text">结构化程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">5.1.</span> <span class="nav-text">多文件结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86"><span class="nav-number">5.2.</span> <span class="nav-text">编译预处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">递归函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">7.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">重载函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-number">9.</span> <span class="nav-text">带默认参数值的函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">10.</span> <span class="nav-text">变量的存储类型和生存期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#auto%E5%9E%8B"><span class="nav-number">10.1.</span> <span class="nav-text">auto型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#register%E5%9E%8B"><span class="nav-number">10.2.</span> <span class="nav-text">register型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern%E5%9E%8B"><span class="nav-number">10.3.</span> <span class="nav-text">extern型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static%E5%9E%8B"><span class="nav-number">10.4.</span> <span class="nav-text">static型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">10.5.</span> <span class="nav-text">生存期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">11.</span> <span class="nav-text">函数调用的执行机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">参数的传递机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92"><span class="nav-number">12.1.</span> <span class="nav-text">值传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E4%BC%A0%E9%80%92"><span class="nav-number">12.2.</span> <span class="nav-text">地址传递</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE"><span class="nav-number">13.</span> <span class="nav-text">题目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E6%8C%87%E9%92%88%E5%92%8C%E5%BA%94%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">第六章：指针和应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E5%92%8C%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-number">1.1.</span> <span class="nav-text">地址和指针变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.2.</span> <span class="nav-text">指针的定义和初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">指针的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">2.</span> <span class="nav-text">动态内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE"><span class="nav-number">2.1.</span> <span class="nav-text">C语言的动态内存申请和释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE"><span class="nav-number">2.2.</span> <span class="nav-text">C++的动态内存申请和释放</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">3.1.</span> <span class="nav-text">引用的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.2.</span> <span class="nav-text">引用的使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">指针与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">指针作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">引用作为函数参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%E4%B8%8D%E8%80%83"><span class="nav-number">4.3.</span> <span class="nav-text">常指针和指针常量（不考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8D%E8%80%83"><span class="nav-number">4.4.</span> <span class="nav-text">指针函数和函数指针（不考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.5.</span> <span class="nav-text">指针与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">4.5.1.</span> <span class="nav-text">处理字符串的两种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-number">4.5.2.</span> <span class="nav-text">字符串操作函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">指针与数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">5.1.</span> <span class="nav-text">通过指针访问一维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84"><span class="nav-number">5.2.</span> <span class="nav-text">指针数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BAmain%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%A2%E5%8F%82%E4%B8%8D%E8%80%83"><span class="nav-number">5.3.</span> <span class="nav-text">指针数组作为main函数的形参（不考）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">5.4.</span> <span class="nav-text">二维数组与指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">6.</span> <span class="nav-text">指针与结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#void%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%8C%87%E9%92%88"><span class="nav-number">7.</span> <span class="nav-text">void类型的指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%92%8C%E6%8C%87%E9%92%88%E6%82%AC%E6%8C%82"><span class="nav-number">8.</span> <span class="nav-text">内存泄漏和指针悬挂</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Econst"><span class="nav-number">9.</span> <span class="nav-text">关于const</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">10.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="nav-number">11.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%82%B9%E6%84%8F%E6%80%9D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84"><span class="nav-number">12.</span> <span class="nav-text">有点意思的字符串与指针与字符数组</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">第七章：类与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">类和对象的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-number">1.2.</span> <span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.3.</span> <span class="nav-text">类的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="nav-number">1.4.</span> <span class="nav-text">对象的定义和使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">类的作用域与可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-number">1.5.1.</span> <span class="nav-text">类的作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.5.2.</span> <span class="nav-text">类的可见性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.</span> <span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.</span> <span class="nav-text">构造函数的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数的重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">带默认值的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.</span> <span class="nav-text">默认构造函数和无参构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">复制构造函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.</span> <span class="nav-text">面向对象设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%B0%81%E8%A3%85%E6%80%A7"><span class="nav-number">4.1.</span> <span class="nav-text">类的封装性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">软件工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">4.3.</span> <span class="nav-text">面向对象的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">6.</span> <span class="nav-text">使用对象传递函数参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88%E5%92%8C%E5%A0%86%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.</span> <span class="nav-text">对象指针和堆对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">9.</span> <span class="nav-text">复制析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">10.</span> <span class="nav-text">内部类和命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="nav-number">11.</span> <span class="nav-text">题目</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E7%BB%A7%E6%89%BF"><span class="nav-number"></span> <span class="nav-text">第八章：继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">继承的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E5%92%8C%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">基类和派生类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">定义派生类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">2.2.</span> <span class="nav-text">继承方式和访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#protected%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">protected属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E5%BD%B1%E5%93%8D%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">继承方式影响访问控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E5%90%8D%E8%A6%86%E7%9B%96"><span class="nav-number">3.</span> <span class="nav-text">同名覆盖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">派生类的构造和析构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E5%8F%AA%E6%9C%89%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.1.</span> <span class="nav-text">基类只有无参构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">派生类构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">派生类的析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">虚基类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E4%BA%8C%E4%B9%89%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">多继承和二义性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%9F%BA%E7%B1%BB-1"><span class="nav-number">5.2.</span> <span class="nav-text">虚基类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E5%90%8D%E8%A6%86%E7%9B%96%E5%92%8C%E9%87%8D%E8%BD%BD"><span class="nav-number">6.</span> <span class="nav-text">同名覆盖和重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">7.</span> <span class="nav-text">转换与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.</span> <span class="nav-text">派生类对象转换为基类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.2.</span> <span class="nav-text">基类指针指向派生类对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8"><span class="nav-number">7.3.</span> <span class="nav-text">用派生类对象初始化基类对象的引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%B1%BB%E5%88%B0%E6%B4%BE%E7%94%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.4.</span> <span class="nav-text">基类到派生不存在转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="nav-number">8.</span> <span class="nav-text">题目</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sa1geChen"
      src="/uploads/sageac.jpg">
  <p class="site-author-name" itemprop="name">Sa1geChen</p>
  <div class="site-description" itemprop="description">Talk is cheap.Show me the code.</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Sagecheni" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Sagecheni" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.sa1ge.ink/archives/7ad645cf.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/sageac.jpg">
      <meta itemprop="name" content="Sa1geChen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sa1ge 's Blog">
      <meta itemprop="description" content="Talk is cheap.Show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++程序语言设计复习提纲 | Sa1ge 's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++程序语言设计复习提纲
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-02-09 15:30:44" itemprop="dateCreated datePublished" datetime="2023-02-09T15:30:44+08:00">2023-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-01-26 22:59:13" itemprop="dateModified" datetime="2024-01-26T22:59:13+08:00">2024-01-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Review/" itemprop="url" rel="index"><span itemprop="name">Review</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">Views: </span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Word count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Word count in article: </span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>1:26</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>​ 缓考个人复习用，详细部分在个人未细化的知识点。</p>
<p>​ 大部分资料来源于《C++程序设计》刘瑞芳主编。</p>
<p>​ 集中在数据类型：</p>
<ul>
<li>数组
<ul>
<li>普通数组</li>
<li>多维数组</li>
<li>字符数组</li>
</ul></li>
<li>枚举(enum)、结构(struct)类型、联合类型(union)</li>
<li>类和对象（重点）</li>
</ul>
<p>​ 函数：</p>
<ul>
<li>函数调用</li>
<li>参数传递（值传和地址传）</li>
<li>变量类型(四类)</li>
<li>内联(inline)和重载(overload)</li>
</ul>
<p>​ 指针（重点）：</p>
<ul>
<li><p>指针的基本使用</p></li>
<li><p>动态内存</p></li>
<li><p>引用(类型名 &amp;变量名)</p></li>
<li><p>指针与函数</p>
<ul>
<li>指针与字符串</li>
<li>指针/引用作为参数</li>
</ul></li>
<li><p>指针与数组/结构体</p></li>
<li><p>const的一点知识</p></li>
</ul>
<p>课后习题答案：<a
target="_blank" rel="noopener" href="https://blog.csdn.net/Slatter/article/details/93309541">https://blog.csdn.net/Slatter/article/details/93309541</a>
<span id="more"></span> # 第一章：C++语言概述</p>
<h2 id="程序设计">程序设计</h2>
<p>​
面向过程的程序设计又称为结构化程序设计，一般强调的是3种基本结构：<strong>顺序、选择和循环结构。</strong></p>
<p>​ 类和对象：<strong>封装性、继承性、多态性</strong></p>
<p>​ 对象是类的实例化，类是对象的抽象。</p>
<p>​
在面向过程的程序设计中，C++的程序模块是以<strong>函数的形式</strong>实现的，在面向对象的程序设计中，C++程序模块是以<strong>类的形式</strong>实现的。</p>
<h2 id="程序开发过程">程序开发过程</h2>
<p>​ 1.源程序</p>
<p>​ 2.目标程序 .obj</p>
<p>​ 源程序经过翻译加工后所生成的程序，一般用机器语言表示</p>
<p>​ 3.可执行程序.exe</p>
<p>​ 目标程序和所用的其他资源进行链接生成的可以直接运行的程序</p>
<p>​ 翻译程序(3类)：</p>
<p>​ -汇编程序：源程序翻译为机器语言形式的目标程序</p>
<p>​ -编译程序：将高级语言编写的源程序翻译成机器语言形式的目标程序</p>
<p>​ -解释程序：将使用高级语言编写的源程序翻译成机器指令</p>
<p>​ 5.链接程序：</p>
<p>​
对汇编程序或编译程序生成的目标程序与所需的其他资源进行链接生成可执行文件的程序。</p>
<p>​ 注释：//注释一行说明，/* */，注释一段说明</p>
<p>​ 编译预处理：“#”开头的代码</p>
<h2 id="内存模型">内存模型</h2>
<p>​
一个程序执行时一定会先<strong>复制到内存</strong>，然后由CPU逐句读取来执行。</p>
<p>​ 每个储存单元有1<strong>个字节的大小(8
bit)</strong>，每个内存单元有一个唯一的地址。一般来说，地址是顺序编址。</p>
<p>​ CPU访问内存，进行取/存，读/写内存中的信息</p>
<p>内存分区使用：</p>
<p>​ <strong>代码区</strong>：被编译成机器码的程序在执行时会被复制此</p>
<p>​ <strong>数据区</strong>：程序中的变量和常量会被存储到此</p>
<p>​ 数据区又分为：</p>
<p>​
<strong>栈区</strong>：存放程序函数的局部变量。先入后出，自动释放</p>
<p>​ 全局变量区和静态变量区： 存放长期数据</p>
<p>​ 常量区一般是存放<strong>字符串常量</strong>的地方</p>
<p>​
<strong>堆区</strong>：在程序设计过程中申请的内存空间，这些空间应该在内存中释放。</p>
<p>​
全局变量和静态变量位于同一个区域，<strong>先定义的放在低地址，后定义的放在高地址</strong>。局部变量则相反，先定义的放在高地址，后定义的放在低地址。</p>
<p>​ C++程序由<strong>注释、编译预处理、程序主体</strong>组成。</p>
<p>​
一个C++程序需要经过<strong>编辑、编译和链接</strong>，才能产生可执行文件。</p>
<h1 id="第二章基本数据类型与表达式">第二章：基本数据类型与表达式</h1>
<h2 id="词法记号和标识符">词法记号和标识符</h2>
<p>关键词：</p>
<p>auto bool break case catch char class const</p>
<p>const_cast continue default delete do double dynamic_cast else</p>
<p>enum explicit extern false float for friend goto</p>
<p>if inline int long mutable namespace new operator</p>
<p>private protected public register reinterpret_case return short
signed</p>
<p>sizeof static static_cast struct switch template this throw</p>
<p>true try typedef typeid typename union unsigned using</p>
<p>virtual void volatile while</p>
<p>标识符：C++的标识符是<strong>大小写敏感</strong>的</p>
<h2 id="数据类型">数据类型</h2>
<p>基础数据类型：整型、字符型、实型、逻辑型</p>
<p>自定义数据类型：数组、指针、引用、空类型、结构、联合、枚举、类</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">分类</th>
<th style="text-align: center;">名称</th>
<th style="text-align: center;">标识</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">整型</td>
<td style="text-align: center;">int</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">字符型</td>
<td style="text-align: center;">char</td>
</tr>
<tr class="odd">
<td style="text-align: center;">基础数据类型</td>
<td style="text-align: center;">实型</td>
<td style="text-align: center;">float、double</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">逻辑型</td>
<td style="text-align: center;">bool</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">数组</td>
<td style="text-align: center;">type[]</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">指针</td>
<td style="text-align: center;">type*</td>
</tr>
<tr class="odd">
<td style="text-align: center;">自定义数据类型</td>
<td style="text-align: center;">引用</td>
<td style="text-align: center;">type&amp;</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">空类型</td>
<td style="text-align: center;">void</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">结构</td>
<td style="text-align: center;">struct</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">联合</td>
<td style="text-align: center;">union</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">枚举</td>
<td style="text-align: center;">enum</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">类</td>
<td style="text-align: center;">class</td>
</tr>
</tbody>
</table>
<p>修饰基本数据类型的关键词：</p>
<p>short 短整型 2字节(16 bit)</p>
<p>long 修饰int和double</p>
<p>unsigned 修饰char、short和int，表示该数据类型为无符号数</p>
<p>signed 与上面相反</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">长度（字节）</th>
<th style="text-align: center;">取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">char/signed char</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-128~127</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned char</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0~255</td>
</tr>
<tr class="odd">
<td style="text-align: center;">short int/short</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">-32768~32767</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned short int</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0~65535</td>
</tr>
<tr class="odd">
<td style="text-align: center;">int/signed int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">-2<sup>31</sup>~2<sup>31</sup>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0~2<sup>32</sup>-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">long/long int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">-2<sup>31</sup>-2<sup>31</sup>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned long</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0~2<sup>32</sup>-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">float</td>
<td style="text-align: center;">4</td>
<td
style="text-align: center;">-3.4x10<sup>38</sup>~3.4x10<sup>34</sup></td>
</tr>
<tr class="even">
<td style="text-align: center;">double</td>
<td style="text-align: center;">8</td>
<td
style="text-align: center;">-1.7x10<sup>308</sup>~1.7x10<sup>308</sup></td>
</tr>
<tr class="odd">
<td style="text-align: center;">long double</td>
<td style="text-align: center;">8</td>
<td
style="text-align: center;">-1.7x10<sup>308</sup>~1.7x10<sup>308</sup></td>
</tr>
</tbody>
</table>
<p>16位机下int的长度为2字节；32位机下int的长度为4字节</p>
<p>short和long表示的长度是固定的，因此如果需要编写可移植性好的程序，应将整型数据声明为short</p>
<h2 id="变量和常量">变量和常量</h2>
<h3 id="变量">变量</h3>
<p>​
变量的实质是内存中的一个<strong>地址空间</strong>，在这个地址空间中可以进行数据的存储和读取。</p>
<p>​ 变量定义语句是为变量分配存储空间</p>
<p>​ 先定义或声明，后使用，且只能定义一次</p>
<p>typedef：声明原有数据类型的一个<strong>别名</strong></p>
<h3 id="常量">常量</h3>
<p>​ 使用const定义常量</p>
<h4 id="符号常量">符号常量：</h4>
<p>​ const 数据类型 常量名 = 常量值，必须在定义时就进行初始化</p>
<h4 id="整型常量">整型常量：</h4>
<p>​ 八进制：以数字0开头</p>
<p>​ 十六进制：以0x或0X开头</p>
<p>​
整型常数默认是int类型，后缀字母L或l表示长整型，后缀字母U或u表示无符号型</p>
<h4 id="实型常量">实型常量：</h4>
<p>​
指数：<strong>aEb</strong>的形式表示，代表<strong>ax10<sup>b</sup></strong>。b必须是十进制数</p>
<p>​
实型常数默认为double型，可以用后缀字母f或F转换为float型，后缀L或l表示long
double型</p>
<h4 id="字符常量">字符常量：</h4>
<p>​ 用单括号括起来的一个可显示字符表示字符常数，如'a'、'A'等</p>
<p>​ 转义字符：以“”开头，回车，o是八进制数，h是十六进制数</p>
<p>​
在内存中，字符数据以ASCII码存储，也可以看成是单字节整数表示，所以字符数据和整型数据之间可以相互转换。</p>
<h4 id="字符串常量">字符串常量：</h4>
<p>​ 由双引号括起来的字符序列，例如"abc","Hello
World"，除了存储包含的字符，还需要存储一个结束符'\0'</p>
<h4 id="逻辑常量">逻辑常量：</h4>
<p>​ 0和1</p>
<h2 id="运算符和表达式">运算符和表达式</h2>
<p>​
表达式由<strong>运算符</strong>、<strong>操作数</strong>(常量、变量)和<strong>分隔符号</strong>组成的序列，并总能返回一个<strong>值</strong>作为表达式的结果</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207003559609.png" /></p>
<p>​ 三元运算符：? :</p>
<p>​ 取余运算：%</p>
<p>​ 只要有一个操作数是浮点数，除法的结果就是浮点数。</p>
<p>​ 不允许对浮点数进行取余操作</p>
<p>​ 前置++i：先+1，后使用</p>
<p>​ 后置i++：先使用，后+1</p>
<p>​ 关系表达式的结果类型为bool</p>
<p>​ 除了逻辑非，逻辑运算的级别低于关系运算</p>
<p>​
&amp;&amp;和||为短路运算符，只要能确定逻辑表达式的结果，就不再进行运算</p>
<h4 id="位运算">位运算：</h4>
<p>​
按位与(&amp;)、按位或(|)、按位异或(^)、按位取反(~)、左移位(&lt;&lt;)、右移位(&gt;&gt;)</p>
<p>​ 按位与：将两个操作数对应的每一位分别进行逻辑与操作</p>
<p>​
使用逻辑与可以将操作数中的若干位置0（其他位不变），或者去操作数中的若干位</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=a&amp;<span class="number">0376</span><span class="comment">//将字符变量a的最低位置0</span></span><br><span class="line"><span class="type">char</span> c=a&amp;<span class="number">0377</span> <span class="comment">//取整型变量a的低字节</span></span><br></pre></td></tr></table></figure>
<p>​ 按位或：</p>
<p>​ 将操作数中的若干位置1（其他位不变）</p>
<p>​ 按位取反：~1=0,~0-=1</p>
<p>​
位运算的常见用法是实现掩码运算，掩码是一个位模式，从一个字中选出一组位。</p>
<p>​
例如：0xFF表示一个字的低位字节，若有int型变量x，则位运算x&amp;0xFF生成一个由x的最低字节组成的值，而其他字节置0，这就相当于从x中选出它的最低字节。</p>
<p>​ 条件运算符：表达式1?表达式2:表达式3；</p>
<p>​ 如果表达式1的值为真，则返回表达式2，否则返回表达式3</p>
<h4 id="数据类型转换">数据类型转换</h4>
<p>​
转换的基本原则是将精度较低、范围较小的类型转换为精度较高、范围较大的类型。</p>
<p>​ 逻辑运算，非0即真</p>
<p>​ 强制类型转换：(数据类型名)表达式 或 数据类型名(表达式)</p>
<p>​ 强制类型转换运算符：static_cast<类型名>(表达式)</p>
<h3 id="输入输出">输入输出</h3>
<h4 id="基本输出">基本输出</h4>
<p>​ putchar 输出字符 putchar()</p>
<p>​ printf</p>
<h4 id="基本输入">基本输入</h4>
<p>​ getchar getchar()</p>
<p>​ scanf scanf("%",&amp;)</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">类型字符</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">d</td>
<td style="text-align: center;">十进制数</td>
</tr>
<tr class="even">
<td style="text-align: center;">o</td>
<td style="text-align: center;">八进制数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">x</td>
<td style="text-align: center;">十六进制数</td>
</tr>
<tr class="even">
<td style="text-align: center;">u</td>
<td style="text-align: center;">无符号十进制数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">i</td>
<td style="text-align: center;">整型</td>
</tr>
<tr class="even">
<td style="text-align: center;">f</td>
<td style="text-align: center;">实型的小数形式</td>
</tr>
<tr class="odd">
<td style="text-align: center;">e</td>
<td style="text-align: center;">实型的指数形式</td>
</tr>
<tr class="even">
<td style="text-align: center;">g</td>
<td style="text-align: center;">f和e的较短形式</td>
</tr>
<tr class="odd">
<td style="text-align: center;">c</td>
<td style="text-align: center;">字符</td>
</tr>
<tr class="even">
<td style="text-align: center;">s</td>
<td style="text-align: center;">字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;">l或h</td>
<td
style="text-align: center;">放在任何整数转换说明符之前，用于输入/输出long或short类型数据</td>
</tr>
<tr class="even">
<td style="text-align: center;">l或L</td>
<td
style="text-align: center;">放在任何浮点转换说明符之前，用于输入/输出double或long
double类型数据</td>
</tr>
</tbody>
</table>
<h4 id="标准输入输出流">标准输入输出流</h4>
<p>​ cin</p>
<p>​ 使用提取操作符“&gt;&gt;”将键盘键入的数据读入到变量中</p>
<p>​ cout</p>
<p>​ 使用插入操作符“&lt;&lt;”</p>
<h3 id="sizeof运算符">sizeof运算符</h3>
<p>​ 用于确定某种数据的长度，单位是字节</p>
<h3 id="输出格式控制">输出格式控制</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d,OK\n&quot;</span>,<span class="number">3</span>);<span class="comment">//控制宽度为4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%04d,OK\n&quot;</span>,<span class="number">3</span>);<span class="comment">//位数不足4位前面填0</span></span><br></pre></td></tr></table></figure>
<p>​ C++的I/O流提供了操纵符</p>
<p>​ 1.设置域宽 <strong>setw(int n)</strong>控制输出间隔</p>
<p>​ 2.左对齐：<strong>setiosflags(ios::left)</strong>
右对齐：<strong>setiosflags(ios::right)</strong></p>
<p>​
除了<strong>setw()</strong>操纵符外，其他操纵符一旦设置，则对后面所有的输入/输出造成影响，直到重新设置才改变格式；</p>
<p>​ 3.设置填充字符</p>
<p>​ <strong>setfill(char c)</strong>来设置其他字符作为间隔的填充</p>
<p>​ 4.设置浮点数的显示</p>
<p>​ C++默认输出的浮点数有效位为6位，但单独使用<strong>setprecision(int
n)</strong>可以控制显示浮点数的数字个数</p>
<p>​ 直接输出或设置精度为0都是输出6位有效数字</p>
<p>​
<strong>setiosflags(ios::fixed)</strong>操纵符是用定点方式表示浮点数，若不设置精度，则显示六位有效小数，总的有效数字可以超过6位</p>
<p>​
<strong>setiosflags(ios::scientific)</strong>操纵符使用质数方法显示浮点数</p>
<p>​ 将<strong>setprecision(int
n)</strong>和<strong>setiosflags(ios::scientific)</strong>控制指数表示法的小数位数</p>
<p>​ 使用操纵符将小数截短显示后，将进行四舍五入处理</p>
<h3 id="string">string</h3>
<p>​
关系运算符实际上比较的是两个string对象的字母，即字符ASCII码的大小</p>
<h3 id="文件读写">文件读写</h3>
<p>​ 使用标准库的ifstream类和ofstream类来定义文件流对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofile</span><span class="params">(<span class="string">&quot;odata.txt&quot;</span>)</span></span>;<span class="comment">//定义文件流对象ofile，并指定它与磁盘文件odata.txt关联</span></span><br><span class="line">ofile&lt;&lt;i&lt;&lt;endl;<span class="comment">//将变量i的值写入文件</span></span><br><span class="line">ofile.close</span><br></pre></td></tr></table></figure>
<h1 id="第三章控制语句">第三章：控制语句</h1>
<h2 id="基本控制结构">基本控制结构</h2>
<p>​
3种基本控制结构：<strong>顺序结构</strong>、<strong>选择结构</strong>和<strong>循环结构</strong></p>
<p>​ 顺序结构：按语句编写顺序执行的语句结构</p>
<p>​ 选择结构：根据给定条件的真假而选择不同语句执行的语句结构</p>
<p>​
循环结构：在一定条件下重复执行指定语句的语句组，用于处理需要重复执行某些操作的问题</p>
<h3 id="算法及其表示">算法及其表示</h3>
<p>​
算法：解决特定问题的方法和具体步骤。可以先用伪代码或流程图来表述算法，然后再逐渐完善</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207165455521.png" /></p>
<h4 id="switch">switch</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
表达式的值可以是字符型、整型，也可以是枚举型，其他类型不允许（实型、指针类型等）</p>
<h3 id="循环结构">循环结构</h3>
<p>​
循环语句的主要部分是：<strong>循环控制条件</strong>、<strong>循环体</strong>和<strong>循环控制变量</strong></p>
<p>​ while()：表达式为真则执行，先判断后执行</p>
<p>​ do-while：先执行一次，再判断表达式的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>
<p>​ for：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环控制变量赋初值;循环条件;修改循环控制变量值)</span><br><span class="line">&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
一般用for实现循环次数一定的问题，而用while和do-while实现循环次数事先不能确定的问题。</p>
<ul>
<li><p>for语句的3个表达式种任意一个或几个可以不写，但是“；”不能省略</p></li>
<li><p>省略表达式1意味着循环控制变量赋初值的语句要放在for语句之前完成。</p></li>
<li><p>表达式1和表达式3都可以是逗号语句</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(sum=<span class="number">0</span>,k=<span class="number">1</span>;k&lt;=<span class="number">10</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line">	sum+=k*k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​ break:从循环体跳出，去执行循环结构后面的语句</p>
<p>​ continue:提前结束本次循环，进入下次循环</p>
<h2 id="随机数">随机数</h2>
<p>​ rand()可以产生一个0~RAND_MAX之间的随机数，是伪随机数</p>
<p>​ 需要在使用rand()用srand()函数为随机数序列设置种子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<h2 id="结构嵌套">结构嵌套</h2>
<p>​ if嵌套：从最内层开始，else总是与前面最近的（未曾匹配的）if配对</p>
<h1 id="第四章数组及自定义数据类型">第四章：数组及自定义数据类型</h1>
<p>​
用户自定义的数据类型和系统预定义的数据类型的地位<strong>是等价的</strong></p>
<p>​
数组的分量称为<strong>元素</strong>，结构的分量为<strong>成员</strong>；</p>
<p>​
数组<strong>存储类型和意义相同</strong>的<strong>集合元素</strong>，结构类型的成员用不同的数据类型描述了<strong>一种实体的不同属性</strong>。</p>
<p>​ 枚举类型实质是<strong>有限个整数</strong>的集合。</p>
<p>​
结构变量所占内存长度是各个成员所占的<strong>内存长度之和</strong>，每个成员都有自己的内存单元。</p>
<p>​
联合变量所占的内存长度等于<strong>最长的成员的长度</strong>，无论有多少成员，他们共用内存单元。</p>
<h2 id="数组array">数组（Array）</h2>
<h3 id="定义数组">定义数组：</h3>
<p>​ 类型标识符 数组名[<strong>常量</strong>表达式]；</p>
<p>​
定义语句使系统给该数组分配一段<strong>连续</strong>的内存空间，<strong>数组名表示该内存空间的起始地址</strong></p>
<p>​
元素的下标可以理解为元素存放位置相对于数组名的<strong>偏移量</strong></p>
<p>​ 数组名是一个<strong>地址常量</strong>，禁止给数组名赋值</p>
<p>​ 数组所占字节数：<strong>sizeof</strong>(数组名)或<strong>N *
sizeof</strong>(数组类型)</p>
<h3 id="数组初始化">数组初始化：</h3>
<p>​ 类型标识符
数组名[<strong>常量</strong>表达式]={以逗号隔开的初始化值}；</p>
<p>​ 初始化数值不能多于数组元素，可以少于数组元素</p>
<h3 id="访问数组元素">访问数组元素</h3>
<p>​ 数组元素的下标表达式的结果必须是0或正整数</p>
<p>​ 数组的下标值不得越界</p>
<p>​ 复制两个数组可以使用<strong>memcpy</strong>函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>],b[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(a,b,<span class="built_in">sizeof</span>(b))</span><br></pre></td></tr></table></figure>
<h3 id="字符数组">字符数组</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> chArray[]=<span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​
字符串中每个字符占用1个字节，加上字符串常量最后的结束符，数组需要的字节数比显示的字符数要<strong>多一个</strong>。</p>
<h4 id="初始化字符数组">初始化字符数组</h4>
<ol type="1">
<li><p>用双引号内的字符串常量初始化字符数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> array[]=&#123;<span class="string">&quot;Hellow&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>用字符常量来初始化字符数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> array[]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,\<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="字符数组的赋值">字符数组的赋值</h4>
<p>​
使用<strong>strcpy</strong>(字符数组1，字符串2)，即字符串复制函数，将字符串2复制到字符数组1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>]=<span class="string">&quot;&quot;</span>,str2[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2);</span><br></pre></td></tr></table></figure>
<p>​ 字符数组1要能够容纳被复制的字符串</p>
<p>​
不能用赋值语句将一个字符串常量或字符数组直接给字符数组赋值，如str1="Hello";</p>
<h3 id="多维数组">多维数组</h3>
<p>​ n维数组：<strong>类型标识符
数组名称标识符[常量表达式1][常量表达式2]...[常量表达式n]</strong></p>
<p>​ 多维数组初始化时需要使用嵌套的括号</p>
<h2 id="枚举类型enum">枚举类型(enum)</h2>
<h3 id="枚举类型定义">枚举类型定义</h3>
<p>​ <strong>enum 新的数据类型名称{变量值名称}</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekday</span>&#123;sun,mon,tue,wed,thu,fri,sat&#125;;</span><br></pre></td></tr></table></figure>
<p>​ sun，mon等称为枚举元素或枚举常量</p>
<h3 id="枚举变量定义及使用">枚举变量定义及使用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekday</span>&#123;sun,mon,tue,wed,thu,fri,sat&#125;;</span><br><span class="line">weekday day;</span><br></pre></td></tr></table></figure>
<p>​ 变量day的取值范围为类型定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">day=sat;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>在类型定义后，枚举元素<strong>按常量处理</strong>，不能对它们赋值，如：sum=0</p></li>
<li><p>枚举元素具有默认值，它们依次为：0，1，...。例如，sun=0，mon=1，...</p></li>
<li><p>枚举类型可以进行关系运算，但不能进行其他运算</p></li>
<li><p>也可以在类型声明时另行指定枚举元素的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekday</span>&#123;sun=<span class="number">7</span>,mon=<span class="number">1</span>,tue,wed,thu,fri,sat&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>枚举值可以直接赋给整型变量，但整数值不能直接赋给枚举变量；若需要将整数值赋给枚举变量，则需要进行强制类型转换，如day=weekday(3)</p></li>
</ol>
<h2 id="结构类型struct">结构类型(struct)</h2>
<h3 id="结构类型的定义和初始化">结构类型的定义和初始化</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构类型名</span><br><span class="line">&#123;</span><br><span class="line">    数据类型说明符<span class="number">1</span> 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型说明符<span class="number">2</span> 成员名<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    数据类型说明符n 成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">    <span class="type">char</span> namep[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 大括号括起的内容称为结构的<strong>成员</strong>。</p>
<h3 id="结构变量的定义和使用">结构变量的定义和使用</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">studnet s1;</span><br></pre></td></tr></table></figure>
<p>​
要访问结构的成员，需要使用圆点操作符”.“，它是双目操作符，左边的操作数是结构变量名，右边的操作数是结构的成员名，引用形式为：<strong>结构变量名.成员名</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;s1.name;</span><br></pre></td></tr></table></figure>
<h3 id="结构变量的初始化">结构变量的初始化</h3>
<ol type="1">
<li><p>在结构变量定义的同时设置初始值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student s2=&#123;<span class="number">20041118</span>,”Li Li“，<span class="number">18</span>，<span class="number">90</span>，”Xi Tu Cheng Lu <span class="number">10</span>“&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>在程序中，单独给结构变量的各个成员赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1.num=<span class="number">20041118</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1.name,”Li Li“);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="结构变量的赋值运算">结构变量的赋值运算</h3>
<p>​
属于同一结构类型的各个变量之间可以相互赋值，即使结构体内有数组类型的数据成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">student s1,s2;</span><br><span class="line">s1=s2;</span><br></pre></td></tr></table></figure>
<p>​ 不同结构的变量不允许相互赋值，即使这两个变量可能有同样的成员。</p>
<p>​
结构变量代表一个完整的内存空间，复制结构变量就是将这块内存空间整体复制到另一个位置。</p>
<h2 id="联合类型union">联合类型(union)</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 联合类型名</span><br><span class="line">&#123;</span><br><span class="line">    数据类型说明符<span class="number">1</span> 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型说明符<span class="number">2</span> 成员名<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    数据类型说明符n 成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 联合类型变量定义的语法形式为：<strong>联合类型名
联合变量名</strong></p>
<p>​ 在某时刻，只能使用多个成员的其中之一</p>
<p>​ 引用形式：联合变量名.成员名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">uarea</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c_data;</span><br><span class="line">	<span class="type">short</span> s_data;</span><br><span class="line">	<span class="type">long</span> l_data;</span><br><span class="line">&#125;ux;</span><br></pre></td></tr></table></figure>
<p>​
新的数据类型uarea属于联合类型，它有3个成员，这三个成员共用内存空间，分配给uarea类型的变量ux的内存空间如下图所示</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207195532331.png" /></p>
<p>​ 如果在主程序这样写：</p>
<p>​ ux.s_data=10;</p>
<p>​ ux.l_data=20;</p>
<p>​ 最终结果是：20覆盖了先存入的10；</p>
<p>​
联合类型可以不声明名称，称为<strong>无名联合</strong>，常用作<strong>结构类型的内嵌成员</strong></p>
<p>​ 联合型变量的特点：</p>
<ol type="1">
<li>同一段内存用来存放几种不同类型的成员，但在<strong>某一时刻只能存放其中一种</strong>，而不能同时存放几种</li>
<li>联合变量中起作用的成员是<strong>最后一次存放的成员</strong>，在存入一个新的成员后，原有的成员会失去作用</li>
<li>联合变量的地址和它的各个成员的地址是<strong>同一地址</strong></li>
<li>不能对联合变量名赋值，也不能在定义时初始化</li>
<li>不能用联合变量作为<strong>函数参数</strong>或<strong>返回值</strong></li>
</ol>
<h2 id="字符串的输入与输出">字符串的输入与输出</h2>
<p>​ <strong>getline</strong>(字符数组名，大小，终止处)</p>
<p>​
除了字符数组，其他类型的数组要输出数组元素的值，必须用循环语句一个元素一个元素地输出，而数组名只能代表数组的储存地址</p>
<h2 id="内存空间问题">内存空间问题</h2>
<h3 id="多维数组在内存中的存放">多维数组在内存中的存放</h3>
<p>​ 一维数组在内存中从数组名所代表的起始地址开始，按下标次序存储</p>
<p>​
二维数组在内存中从数组名所代表的起始地址开始，按行优先依次存储，数组的第i行第j列元素在内存中的起始位置相对于数组起始地址偏移了“<strong>行号
x 列数 + 列号</strong>”个int型变量空间大小</p>
<p>​
三维数组在内存中从数组名所代表的起始地址开始，按页、行、列依次存储，即按使数组元素<strong>最右边下标值最快变化来存储</strong>，数组的第k页第i行第j列元素在内存中的起始位置相对于数组起始地址偏移了“<strong>页号
x（行号 x 列数)+行号x列数+列号</strong>”个int型变量空间大小</p>
<p>​ 二维数组实际上是一维数组的一维数组；</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207234815346.png" /></p>
<h3 id="枚举类型的内存空间">枚举类型的内存空间</h3>
<p>​
枚举元素的默认值都是整数，计算机处理数据中把枚举类型按整型(int)对待</p>
<h3 id="结构类型的内存空间">结构类型的内存空间</h3>
<p>​
某个结构类型的变量所占的存储空间是结构中所有成员所占空间的总和（按字节计）</p>
<p>​
在实际系统中会存在结构变量空间对齐问题，对于32位机，如果某个成员所占的空间不是4的倍数，系统会将其调整为4的倍数，使得结构变量所占空间一定是4的倍数，所以结构变量占用空间经常会超过数据成员应该占用空间的总和</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207235210234.png" /></p>
<p>​
考虑到对齐的要求，系统会将所占的空间不是4的倍数的成员空间调整为4的倍数：将sex成员调整为4字节，将addr成员调整为32字节，总共占用68字节。</p>
<h1 id="第五章函数">第五章：函数</h1>
<h2 id="概述">概述</h2>
<p>​ 函数是具有一定功能又独立使用的相对独立的代码段。</p>
<p>​
函数由<strong>接口</strong>和<strong>函数体</strong>构成，函数的接口包括：<strong>函数名</strong>、<strong>函数类型</strong>和<strong>形式参数表</strong>；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 函数体由于实现算法。</p>
<p>​ 代码函数化的主要目的：</p>
<ul>
<li>实现模块化设计，将项目分为小模块分别实现</li>
<li>软件复用，使用现有函数能实现的功能不必重新定义新的代码</li>
<li>避免程序代码的重复书写</li>
</ul>
<h3 id="自定义函数概述">自定义函数概述</h3>
<p>​
将程序中多处使用的、实现一定功能的特定代码端定义成函数，这样的函数称为<strong>自定义函数</strong></p>
<p>​
在函数调用过程中，把实现函数调用的函数称为<strong>调用函数（主调函数）</strong>被调用的函数称为<strong>被调函数</strong>。</p>
<h3 id="库函数">库函数</h3>
<p>​ 数学库函数</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208002424370.png" /></p>
<p>​
函数定义中声明的所有变量都是<strong>局部变量</strong>，只在定义它们的函数中有效。</p>
<p>​
为实现函数之间的信息交换，多数函数需要有一定内容的<strong>形式参数</strong>表，这些形式参数也是局部变量。</p>
<h2 id="函数的定义">函数的定义</h2>
<p>​
一个C++程序可以由一个主函数和若干子函数构成。主函数main()是程序执行的开始点，由主函数调用子函数，子函数还可以继续调用其他子函数。</p>
<p>​
调用其他函数的函数称为<strong>主调函数</strong>，被其他函数调用的函数称为<strong>被调函数</strong>。</p>
<h3 id="定义函数">定义函数</h3>
<p>​ 每一个函数都是一个具有一定功能的语句模块，函数定义的语法形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形式参数表)</span><br><span class="line">&#123;</span><br><span class="line">	函数体(变量声明和语句)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​
函数名是这个独立代码段（函数体）的外部标识符，代表这个代码段在内存的起始地址。</p>
<p>​ 函数的形式参数表：</p>
<p>​ (类型1 形式参数1，类型2 形式参数2，...，类型n 形式参数n)</p>
<p>​
其中，“类型”是各个形式参数的类型标识符，“形式参数”为各个形式参数的标识符</p>
<p>​
形式参数表从参数的<strong>类型、个数、排列顺序</strong>上规定了主调函数和被调函数之间信息交换的形式。</p>
<p>​
函数返回值类型规定了函数返回给主调函数的值的类型，也被称为<strong>函数类型</strong>。</p>
<p>​
由return语句返回的值的类型必须与函数返回值的<strong>类型一致</strong>。</p>
<p>​ 如果函数声明时没有写返回值类型，将默认为int类型。</p>
<p>​ <strong>C++不允许函数嵌套定义</strong>。</p>
<h3 id="函数原型">函数原型</h3>
<p>​ 函数原型声明语法形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">maximum</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
函数原型声明中的形式参数标识符(x,y,...)可以不同于函数定义时形式参数表中的形式参数标识符，但参数的类型、个数以及形式参数的先后次序必须与函数定义时的一致；</p>
<p>​
函数声明应该写在所有函数定义之外，表明这些函数都可以被位于原型声明之后的所有函数调用。</p>
<p>​ C++常用的库头文件：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208004012723.png" /></p>
<p>​ 程序中包含头文件，需要用编译预处理指令include，语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span><span class="comment">//用于系统的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;头文件&quot;</span><span class="comment">//用于用户自定义头文件</span></span></span><br></pre></td></tr></table></figure>
<h3 id="return语句">return语句</h3>
<p>​
当被调函数只需要将一个数值返回给主调函数时，使用return语句返回最为合适。</p>
<h2 id="函数的调用">函数的调用</h2>
<p>​
通常采用的调用方式：<strong>函数语句</strong>、<strong>函数表达式</strong>和<strong>函数参数</strong></p>
<ol type="1">
<li><p>函数语句</p>
<p>具体语句：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(实际参数表);</span><br></pre></td></tr></table></figure>
<p>实际参数表的<strong>类型、个数、排列顺序</strong>必须与被调函数声明的形式参数表一一严格对应。</p></li>
<li><p>函数表达式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量名=函数名(实际参数表);</span><br><span class="line">变量名=带有函数调用的表达式;</span><br></pre></td></tr></table></figure></li>
<li><p>函数参数</p>
<p>将函数调用写在另一次函数调用的实际参数的位置</p>
<p>实际是将函数的返回值作为下次调用的实际参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m=<span class="built_in">max</span>(de,<span class="built_in">max</span>(a,b,c));</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="全局变量与局部变量">全局变量与局部变量</h2>
<h3 id="局部变量">局部变量</h3>
<p>​
在函数体内定义的变量和函数的形式参数，它们只能在本函数内使用，不能被其他函数访问。</p>
<p>​
局部变量能够随其所在函数被调用而被分配内存空间，也随其所在函数调用结束而消失（释放内存空间），所以使用局部变量能够<strong>提高内存利用率</strong>。</p>
<p>​
由于局部变量只能被其所在的函数访问，这种变量的数据安全性也比较好。</p>
<h3 id="全局变量">全局变量</h3>
<p>​ 在<strong>函数外部</strong>定义的变量就是全局变量。</p>
<p>​
全局变量能够被位于其定义位置之后的所有函数（属于本源文件的）共用，即全局变量的作用域是<strong>整个源文件</strong>。</p>
<p>​
全局变量在程序执行的整个过程中，始终位于全局数据区内<strong>固定的内存单元</strong>。如果程序没有初始化变量，系统会将其初始化为0。</p>
<h3 id="作用域">作用域</h3>
<p>​ 程序中标识符的作用域也就是<strong>标识符起作用的范围</strong>。</p>
<p>​
从标识符起作用的范围上划分，作用域主要分为全局作用域和局部作用域两种。</p>
<p>​
从标识符在程序中所处位置来划分，作用域又可分为<strong>块作用域</strong>、<strong>函数作用域</strong>、<strong>类作用域</strong>和<strong>文件作用域</strong>。</p>
<ul>
<li>块作用域：在程序块内定义的标识符具有块作用域。从<strong>变量定义起至本块结束</strong>。</li>
<li>函数作用域：函数作用域是指标识符的作用域为函数，从标识符定义开始到函数结束。在函数定义中，<strong>任何程序块以外所定义的变量</strong>具有函数作用域。</li>
<li>文件作用域：即全局作用域
，作用域为文件范围。在源文件所有函数之外声明或定义的标识符具有文件作用域。</li>
</ul>
<h3 id="可见性">可见性</h3>
<p>​
标识符在其<strong>作用域内</strong>，<strong>能被访问到</strong>的位置称为<strong>可见</strong>，不能被访问到的位置称为不可见。</p>
<p>​
例如：若在某个函数定义了与某个全局变量标识符相同的局部变量，则该全局变量在这个函数内不可见。</p>
<p>​
<strong>内层标识符与外层标识符同名时，内层标识符可见，外层标识符不可见。</strong></p>
<p>​ 即内层变量屏蔽外层同名变量。</p>
<p>​
如果在函数中一定要使用这个同名全局变量，可以使用<strong>全局运算符(::)</strong>指定要访问的全局变量</p>
<h2 id="结构化程序设计">结构化程序设计</h2>
<h3 id="多文件结构">多文件结构</h3>
<p>​ 多文件结构程序：即由多个源程序分别完成不同的子功能。</p>
<p>​
在实现每个子功能时，一般可使用两个源文件：一个包含程序<strong>自定义类型</strong>、<strong>符号常量定义</strong>和<strong>函数声明</strong>等头文件<strong>*.h</strong>，一个是由实现算法的函数的*<strong>.cpp</strong>文件</p>
<h3 id="编译预处理">编译预处理</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208114214213.png" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DEBUG_PROGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DEBUG_PROGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​
如果没有定义<strong>_DEBUG_PROGRAM_H</strong>，就定义一个标识符<strong>_DEBUG_PROGRAM_H</strong>，并对头文件的其他语句进行编译;否则就忽略这个头文件中的所有语句。</p>
<p>​
按这样的结构编写头文件，可以防止头文件的<strong>重复嵌入</strong>。</p>
<p>​
使用条件编译，在调试程序时显示一些调试的信息。在调试完毕后，屏蔽编译条件，调试信息就不显示了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DEBUG_MODE</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG_MODE</span></span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​ 调试完后只需要将<strong>#define_DEBUG_MODE
</strong>注释掉，调试信息就不会显示。</p>
<h2 id="递归函数">递归函数</h2>
<p>​
递归函数的函数体内有调用函数自身的语句或通过其他函数间接调用函数自身。</p>
<p>​ 递归函数可读性好，但效率低。</p>
<p>​ 所有递归问题求解可分为两步：</p>
<ul>
<li>化简问题的递推阶段</li>
<li>达到递归终止条件得到基本情况的结果，并逐步回推结果阶段</li>
</ul>
<p>​
递归函数划分问题：函数中能处理的部分（直达已知）和函数不能处理的部分（结果未知）</p>
<p>​
对于还不能即可给出结果的部分，函数将简化问题，再调用递归函数，逐步达到已知结果。</p>
<p>​ 递归函数包含以下主要部分：</p>
<ul>
<li>具有更简单参数的递归调用</li>
<li>停止递归的<strong>终止条件</strong>（递归终止条件）</li>
</ul>
<p>​ 多数能用递归解决的问题，也能使用迭代的方式解决。</p>
<h2 id="内联函数">内联函数</h2>
<p>​
内联函数可以减少函数调用的时空开销，一些常用短小的函数适合采用内联函数的形式</p>
<p>​ 内联函数的定义形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> 函数类型 函数名(形式参数表)</span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
形式上，只需要在函数类型前加个<strong>inline</strong>即可，内联函数是函数的一种特殊形式。</p>
<p>​
系统在编译程序的时候就已经<strong>把内联函数的函数体代码插入到相应的函数调用位置</strong>，<strong>成为主调函数内的一段代码</strong>，可以直接执行，<strong>不必再转换流程控制权</strong>，所以节省了时空开销，但是使得主调函数代码变长，故<strong>一般只把短小的代码写成内联函数</strong>。</p>
<ul>
<li>内联函数不能包含循环结构、switch语句</li>
<li>内联函数要先定义、后调用，不能先声明函数原型，再调用、定义</li>
</ul>
<h2 id="重载函数">重载函数</h2>
<p>​
C++允许几个功能相似的函数同名，但同名函数的形式参数必须不同，称这些同名函数为重载函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">max</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这是两个不同的函数。</p>
<p>​
各重载函数形式参数不同是指参数的<strong>个数、类型或顺序</strong>彼此不同。</p>
<ul>
<li><p>编译器不以形式参数的标识符区分重载函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器认为这是同一个函数声明两次</p></li>
<li><p>编译器不以函数类型区分重载函数、</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器认为这是同一个函数声明两次</p></li>
<li><p>不应该将完成不同功能的函数写成重载函数</p></li>
</ul>
<h2 id="带默认参数值的函数">带默认参数值的函数</h2>
<p>​ C++允许函数的形式参数有默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">CaircleArea</span><span class="params">(<span class="type">double</span> radius=<span class="number">1.0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">return</span> PI*radius*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
调用具有默认参数的函数时候，如果提供实际参数值，则采用实际参数；若不提供实际参数值，则采用默认参数值。</p>
<p>​
形式参数表中具有默认参数值的参数<strong>右边不能出现没有默认值的参数</strong>,<strong>即带有默认值的参数要在最右端</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CuboidVolumn</span><span class="params">(<span class="type">int</span> length=<span class="number">1</span>,<span class="type">int</span> width =<span class="number">1</span>,<span class="type">int</span> height=<span class="number">1</span>)</span></span>;<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CuboidVolumn</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> width =<span class="number">1</span>,<span class="type">int</span> height=<span class="number">1</span>)</span></span>;<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CuboidVolumn</span><span class="params">(<span class="type">int</span> length=<span class="number">1</span>,<span class="type">int</span> width =<span class="number">1</span>,<span class="type">int</span> height)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>​ 函数在声明时便需要指定默认参数值。</p>
<h2 id="变量的存储类型和生存期">变量的存储类型和生存期</h2>
<p>​ 一个变量在内存中存在的时间取决于<strong>变量的存储类型</strong></p>
<h3 id="auto型">auto型</h3>
<p>​
auto型变量包括<strong>函数体内部定义的局部变量、函数的形式参数</strong>，称为<strong>自动变量</strong>。</p>
<p>​ 自动变量的定义一般都省略关键词auto，一般定义的变量都是自动变量。</p>
<p>​
自动变量因其<strong>所在的函数被调用而存在</strong>，随其所在函数的调用的结束而消失。</p>
<p>​
自动变量存放于<strong>栈区</strong>，不长时间占用固定内存，有利于内存资源的动态调用。</p>
<h3 id="register型">register型</h3>
<p>​ 寄存器型变量，定义形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> 类型标识符 变量标识符;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> counter;</span><br></pre></td></tr></table></figure>
<p>​ 把counter放在CPU的寄存器内存储。</p>
<p>​
访问在寄存器中的变量比访问内存中的变量速度快，但由于寄存器数量有限，如果设置过多的register变量，编译器会将这些变量按auto型局部变量处理。</p>
<h3 id="extern型">extern型</h3>
<p>​ 即<strong>外部存储类型</strong></p>
<p>​
如果一个文件中的函数需要使用其他文件中定义的全局变量，可以用extern关键词声明所要用的全局变量。</p>
<p>​
提供了一个多文件程序结构不同源文件共享数据的一个途径，但需要注意数据安全。</p>
<h3 id="static型">static型</h3>
<p>​ 定义形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> 类型标识符 变量标识名;</span><br></pre></td></tr></table></figure>
<p>​
静态变量分为<strong>静态全局变量</strong>和<strong>静态局部变量</strong>。</p>
<p>​
静态变量在程序运行期间一直在<strong>静态存储区</strong>占有<strong>固定的存储空间</strong>。</p>
<p>​</p>
<p>​
静态局部变量只在其所在函数<strong>第一次被调用时</strong>进行初始化，被初始化为指定的值。若没有指定初始化值，则系统将其初始化为0。此后静态局部变量能够<strong>保持</strong>其在前一次函数调用结束后所获得的值，直到下一次函数调用被修改。</p>
<p>​
静态全局变量只能在其定义的文件中使用，不能被多文件结构程序的其他文件访问。除此之外静态全局变量在定义它的文件用法与全局变量一致。</p>
<p>​ 静态全局变量的数据安全性优于普通全局变量。</p>
<h3 id="生存期">生存期</h3>
<p>​
一个变量在<strong>内存中存在的时间</strong>称为<strong>变量的生存期</strong>。</p>
<p>​
按生存期可以将变量分为两种：<strong>静态生存期变量</strong>和<strong>动态生存期变量</strong></p>
<p>​
auto型和register型具有动态生存期，全局变量和静态变量具有静态生存期。</p>
<p>​
具有静态生存期的变量在<strong>程序运行期间</strong>一直存在。被初始化时，若未指定初始化值，则初始化为0.</p>
<p>​
具有动态生存期的变量取决于函数是否被调用，在<strong>函数被调用期间</strong>存在。被初始化时，若未指定初始化值，则初始化为<strong>随机数</strong>.</p>
<h2 id="函数调用的执行机制">函数调用的执行机制</h2>
<p>​ 函数调用是基于函数调用工作栈实现的。</p>
<p>​ 栈空间的存取原则是先进后出。</p>
<p>​
系统在栈空间为函数调用建立<strong>工作记录</strong>，在函数的工作记录中存储主调函数的<strong>断点地址、被调函数的形式参数和自动局部变量</strong>等。</p>
<p>​
当被调函数执行完成后，系统从其工作记录中取出断点地址，并将此工作记录退栈，CPU将从主调函数的断点处继续执行。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208125027759.png" /></p>
<h2 id="参数的传递机制">参数的传递机制</h2>
<p>​ C++的函数参数传递方式分为以下两种：</p>
<ul>
<li>值转递（Pass by Value）</li>
<li>地址传递（Pass by Address）</li>
</ul>
<h3 id="值传递">值传递</h3>
<p>​
值传递：函数的形参为<strong>普通变量</strong>时，当函数被调用，系统为形参分配内存空间，并用实参值初始化形参。</p>
<p>​ 值传递方式下：</p>
<ul>
<li>实参和形参<strong>各自占有</strong>自己的内存空间；</li>
<li>参数传递方向只能由<strong>实参到形参</strong>；（参数传递的单向性）</li>
<li>不论被调函数对形参对任意更改，都<strong>不影响</strong>对应的实参；</li>
</ul>
<h3 id="地址传递">地址传递</h3>
<p>​
地址传递：函数的形参为<strong>指针变量</strong>时，当函数被调用，实参使用地址变量或地址常量，即传递给实参地址值。</p>
<ul>
<li>数组名作为形参，只将数组的<strong>起始地址</strong>传递给了被调函数，数组的大小需要单独通过值传递的方式传给被调函数；</li>
<li>如果是多维数组名作为函数的形参，则数组的<strong>每一维的大小都需要</strong>传给被调函数；</li>
<li>多维数组名作为形参，只可以省略<strong>第一维</strong>（最左边）的大小，注意<strong>下标越界</strong>问题；</li>
</ul>
<h2 id="题目">题目</h2>
<p>​
<strong>函数sumarray()计算一个数组所有元素的和，其定义如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumarray</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    sum+=a[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 现有int
a[2][3]，若求数组a中所有元素的和，则对sumarray()调用正确的为（C）
A.sumarray(a,6)　　　　B.sumarray(a[0],6)　　　　
C.sumarray(&amp;a[0][0],6)　　　　D.sumarray(&amp;a,6)</p>
<p>​ 在内存空间看来，</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">栈空间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a[0][0]</td>
</tr>
<tr class="even">
<td style="text-align: center;">a[0][1]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a[0][2]</td>
</tr>
<tr class="even">
<td style="text-align: center;">a[1][0]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a[1][1]</td>
</tr>
<tr class="even">
<td style="text-align: center;">a[1][2]</td>
</tr>
</tbody>
</table>
<p>​ 函数形参要求数组起始地址，所以将&amp;a[0][0]传入</p>
<p>​ <strong>5.14 下列说法正确的是(B)</strong> ​
A.内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方 ​
B.内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方 ​
C.类的内联函数必须在类体内定义 ​
D.类的内联函数必须在类体外通过加关键字inline定义</p>
<h1 id="第六章指针和应用">第六章：指针和应用</h1>
<h2 id="指针">指针</h2>
<h3 id="地址和指针变量">地址和指针变量</h3>
<p>​ <strong>指针变量</strong>：存放<strong>地址</strong>的变量</p>
<p>​ 对变量的<strong>直接访问</strong>：通过变量名对变量进行访问</p>
<p>​ 对内存单元的<strong>间接访问</strong>：通过地址对变量进行访问</p>
<p>​ 访问指针时，只能看到地址，只有通过这个地址才能访问地址单元的内容</p>
<h3 id="指针的定义和初始化">指针的定义和初始化</h3>
<p>​ 指针定义的格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;变量名&gt; *变量名<span class="number">1</span>,变量名<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *pa1,*pa2;</span><br><span class="line"><span class="type">char</span> *pch1,*pch2;</span><br></pre></td></tr></table></figure>
<p>​ 定义指针变量时的“*”有如下两个含义：</p>
<ul>
<li>声明变量pa1、pa2等都是指针变量</li>
<li>说明变量pa1、pa2的类型是<strong>(int
<em>)<strong>型，即指向整型的指针。它们所指定的地址单元只能存放整型数据。pch1和pch2的类型是</strong>(char
</em>)</strong>类型，它们所指定的地址单元只能存放字符。</li>
</ul>
<p>​
指针变量的类型就是它所指定的<strong>地址单元中存放的数据的类型</strong>。</p>
<p>​
指针变量在声明后，变量的值是随机的，所以一般建议在定义指针时，给指针赋值为0</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *val=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> *ch1=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>​ 指针变量必须在初始化后才可以正确使用。</p>
<p>​ 指针变量的初始化：</p>
<ol type="1">
<li><p>在定义时初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型名&gt; *指针变量名=&amp;变量名;<span class="comment">//变量名和指针要同类型</span></span><br><span class="line"><span class="type">char</span> ch1=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *pch1=&amp;ch1;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208152438945.png" /></p></li>
<li><p>在定义指针变量后，用赋值的方式初始化</p></li>
</ol>
<p>​
没有初始化的指针变量是不可以使用的。<strong>先初始化，后使用</strong>。</p>
<h3 id="指针的使用">指针的使用</h3>
<p>​ 间接引用运算符<strong>“ *
”</strong>是<strong>一元运算符</strong>，与指针变量连用，对指针所指向的内存单元进行间接访问。</p>
<p>​ 使用格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 指针变量</span><br></pre></td></tr></table></figure>
<p>​
指针可以进行的算数运算只有<strong>加减法</strong>，指针p和整数n加减的含义是相对于p的前后方偏移n个数据单元位置。</p>
<p>​ 指针和指针直接相加没有意义，且不允许。</p>
<p>​
指针和指针相减得到两个指针之间的<strong>内存长度</strong>（<strong>偏移值</strong>），而不是两个地址值的具体差值。</p>
<p>​ 不允许用整数减去一个指针。</p>
<p>​
指针的赋值运算一定是<strong>地址的赋值</strong>，可以对指针赋值的参量有：</p>
<ul>
<li>同类型变量的地址</li>
<li>同类型已经初始化的指针变量</li>
<li>向系统申请的同类型指针的地址</li>
</ul>
<p>​
<strong>不同类型的指针是不可以互相赋值的</strong>，不存在类型的自动转换。</p>
<p>​
相同类型的指针可以进行各种关系运算，两个指针<strong>相等</strong>表示它们<strong>指向同一个内存地址</strong>。</p>
<h2 id="动态内存">动态内存</h2>
<p>​
<strong>动态内存</strong>：在程序执行时才能申请、使用和释放的内存，即存放动态数据的内存区域。</p>
<p>​ <strong>堆</strong>：存放动态内存的区域</p>
<p>​ 动态内存不能通过变量名来使用，只能通过指针来使用。</p>
<p>​ 使用堆内存的情况：</p>
<ul>
<li>需要存储大量数据时</li>
<li>需要存储一组数，数据类型相同但数据个数在编程时不确定，在运行时才能确定</li>
</ul>
<h3 id="c语言的动态内存申请和释放">C语言的动态内存申请和释放</h3>
<p>​
C语言通过凸函数<strong>mallowc()</strong>申请动态内存，通过函数<strong>free()</strong>释放动态内存。</p>
<p>​ <strong>mallowc</strong>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
<strong>malloc</strong>函数申请<strong>size个字节</strong>的内存空间，并返回指向所分配内存的<strong>void
</strong>*类型的指针。</p>
<p>​ <strong>void
</strong>*指针具有很好的通用性，可以通过<strong>类型转换</strong>赋值给<strong>任何类型</strong>的指针变量。</p>
<p>​ 如果没有申请到内存空间，则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pn=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>​
该语句按照int类型数据存储空间的大小分配了4个字节的空间，并由整型指针pn指向该内存空间。</p>
<p>​ 函数free的原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br></pre></td></tr></table></figure>
<p>​ 所要释放的内存由ptr指向</p>
<h3 id="c的动态内存申请和释放">C++的动态内存申请和释放</h3>
<p>​ 动态内存申请运算符new的使用格式：<strong>new
<类型名>(初值)</strong></p>
<p>​
运算成功<strong>返回指定类型内存的地址</strong>，申请失败返回NULL指针。</p>
<p>​ 一般总是将动态申请的地址赋值给一个指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="number">0</span>;</span><br><span class="line">pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>​ 如果申请成功，指针pi就获得了一个有效的地址，并使得*pi=10。</p>
<p>​
动态内存使用完毕后，需要用delete运算符来释放，delete的使用格式：<strong>delete
<指针名></strong></p>
<p>​
动态内存的申请和释放应该配合使用，<strong>new和delete应该成对出现</strong>。</p>
<p>​ 申请动态一维数组时，要在new表达式中加上申请数组的大小</p>
<p>​ 格式：<strong>new <类型名>[表达式]</strong></p>
<p>​ 在动态申请数组时，<strong>不可以对数组进行初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *piarray=<span class="number">0</span>;</span><br><span class="line">piarray=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>​ 这样申请得到的地址的类型仍然是(int
*)，只是申请了10个这样的整型数据空间</p>
<p>​ 释放动态数组空间要用：<strong>delete []<指针名>;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1=<span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *p2=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br></pre></td></tr></table></figure>
<h2 id="引用">引用</h2>
<p>​
引用是<strong>变量或者其他编程实体（如对象）的别名</strong>，因此，<strong>引用是不可以单独定义的</strong>。</p>
<p>​
变量A在内存中有自己的地址，而A的引用B实际上就是变量A，只是A的另外一个名字。<strong><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208155056171.png" /></strong></p>
<p>​
指针变量本身也有自己的地址，是可以独立存在的，而引用是不可以独立存在的。</p>
<h3 id="引用的声明">引用的声明</h3>
<p>​
引用是通过<strong>运算符&amp;</strong>来定义的，定义格式：<类型名>&amp;引用名=变量名；</p>
<p>​ 其中，变量名是要已经定义的，并且与引用的类型相同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> someInt;</span><br><span class="line"><span class="type">int</span> &amp;refInt=someInt;</span><br></pre></td></tr></table></figure>
<p>​
refInt就是变量someInt的引用，引用refInt和someInt具有相同的地址，对引用refInt的操作也就是对变量someInt的操作。</p>
<p>​
引用必须在声明的同时完成初始化，不可以先声明引用，再用另一个语句对它进行初始化。</p>
<p>​ 下面是错误的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> someInt;</span><br><span class="line"><span class="type">int</span> &amp;refInt;</span><br><span class="line">refInt=someInt;</span><br></pre></td></tr></table></figure>
<p>​ 引用具有以下特定：</p>
<ul>
<li>引用<strong>不能独立存在</strong>，它只是其他变量的别名；</li>
<li>引用必须在声明的<strong>同时初始化</strong>；</li>
<li>引用一旦定义，引用关系就<strong>不可以更改</strong>；</li>
<li>引用的类型就是相关变量的类型，引用的使用和变量的使用相同；</li>
</ul>
<h3 id="引用的使用">引用的使用</h3>
<p>​ 通过引用使用/修改相关的变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> intA=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;refA=intA;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;引用的值和相关变量值相同:refA=&quot;</span>&lt;&lt;refA&lt;&lt;endl;</span><br><span class="line">	refA=<span class="number">5</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;引用变化，则相关变量也变化:intA=&quot;</span>&lt;&lt;intA&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
在程序中真正使用引用的地方是在函数调用中：或者将引用作为函数的<strong>形式参数</strong>，或者将引用作为函数的<strong>返回值</strong>。</p>
<h2 id="指针与函数">指针与函数</h2>
<h3 id="指针作为函数参数">指针作为函数参数</h3>
<p>​ 指针和函数可以实现<strong>地址调用</strong>。</p>
<p>​ 必须满足以下条件：</p>
<ul>
<li>函数的<strong>形式参数</strong>是<strong>指针变量</strong>；</li>
<li>函数的<strong>实际参数</strong>是<strong>内存的地址</strong>，具体来说可以是数组名、变量的地址、用变量地址初始化的指针；</li>
<li>形参指针类型和实参地址<strong>类型</strong>必须相同</li>
</ul>
<p>​ 满足以上条件后，这样的函数调用在使用上具有以下特点：</p>
<ul>
<li>实参传递给形参的是内存的地址，所以<strong>形参指针指向实参变量</strong>；</li>
<li>形参指针通过<strong>间接引用直接访问实参变量</strong>，包括改变实参变量的值；</li>
<li>函数调用后，可以保留对实参变量的操作结果，如果有多个实参，就可以有多个实参变量在函数调用中得到修改</li>
</ul>
<p>​
这种调用方式可以实现“参数的双向传递”，即实参将变量地址传递给形参指针，，形参将变量变化的结果传递给变量；也可以称为“可以返回多个结果”。</p>
<p>​
实际上并不存在形参到实参的“返回”操作，形参指针的间接引用就是对实参变量的操作，实参变量的变化在函数调用的过程以及发生，而不是在函数执行后才发生。</p>
<p>​
数组作为函数参数就属于这种情况，现在是用指针代替数组名，属于更一般的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">10</span>)</span>,<span class="title">y</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;主函数变量的值：x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Swap</span>(&amp;x,&amp;y);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;返回后变量的值：x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t=*a;</span><br><span class="line">	*a=*b;</span><br><span class="line">	*b=t;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;函数中完成了交换：*a=&quot;</span>&lt;&lt;*a&lt;&lt;<span class="string">&quot;    *b=&quot;</span>&lt;&lt;*b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208163428475.png" /></p>
<p>​ 如果要函数返回一个结果，直接用函数的返回值；</p>
<p>​ 如果要从函数中得到多个结果，就要使用指针作为形参的地址调用</p>
<h3 id="引用作为函数参数">引用作为函数参数</h3>
<p>​ 引用的主要应用就是作为函数的形式参数</p>
<p>​ 引用作为函数的形参有如下特点：</p>
<ul>
<li>实际参数是相同类型的变量</li>
<li>参数传递属于<strong>地址传递</strong></li>
<li>在函数中并不产生实际参数的副本，形式参数的引用和实际参数的变量实际上是同一个实体</li>
<li>函数对引用的操作，也是对实参变量的操作，函数调用可以改变实际参数的值</li>
</ul>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_1</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    j=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">12345</span>,b=<span class="number">54321</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;函数调用前：a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;  b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap_1</span>(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;函数调用后：a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;  b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 与指针作为形式参数的相似点：</p>
<ul>
<li>两者都属于<strong>地址调用</strong>：通过指针的地址调用和通过引用的地址调用；</li>
<li>两者在函数调用时都不建立实参的副本，而是对实参的数据直接进行操作；</li>
<li>指针作为形式参数需要在函数中定义指针变量，引用作为形式参数不需要新建任何实体，所以引用不需要占用新的内存，执行效率更高；</li>
<li>用引用作为形式参数，编程语句也会更简单</li>
</ul>
<p>​ 所以在C++中，常常使用引用作为函数的形式参数</p>
<h3 id="常指针和指针常量不考">常指针和指针常量（不考）</h3>
<p>​
可以使用<strong>常指针</strong>和<strong>常引用</strong>实现对传递参数的保护。</p>
<p>​
常指针是<strong>指向常量的指针</strong>的习惯说法，就是规定指针所指向的内容不可以通过指针的间接引用改变。</p>
<p>​ 常指针的定义格式：</p>
<p>​ <code>const &lt;类型名&gt; *&lt;指针名&gt;;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptint;</span><br></pre></td></tr></table></figure>
<p>​
其中，指针ptint的类型是<code>(const int*)</code>，也就是指向一个恒定的整型数。但是这个整型数本身也许是可以改变的，只是不可以通过指针ptint的间接引用来改变。。而ptint也可以用不同的地址对它进行赋值。</p>
<p>​ 常指针最常见的应用是在函数原型中，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
其中，字符串复制函数中有两个参数，都是字符指针，功能是把s2指向的字符复制给s1，s2指向的字符串不要被函数修改，所以定义常指针。</p>
<p>​ 类似地，也可以定义常引用，格式为：<strong>const <类型名>
<引用名>&amp;;</strong></p>
<p>​
还有另外一种和常量有关的指针：指针常量，也就是指针本身的内容是常量，不可以改变，声明格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型名&gt; *<span class="type">const</span> &lt;指针名&gt;=&lt;初值&gt;;</span><br></pre></td></tr></table></figure>
<p>​ 也可以写成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型名&gt; <span class="type">const</span> *&lt;指针名&gt;=&lt;初值&gt;;</span><br></pre></td></tr></table></figure>
<p>​ 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch,*<span class="type">const</span> ptch=&amp;ch;</span><br></pre></td></tr></table></figure>
<p>​
这是，指针ptch是用ch地址初始化的常量，不可以改为其他地址，但可以通过ptch的间接引用来改变ch的值。</p>
<p>​ 数组名就是一个指针常量。</p>
<p>​
常指针可以改变指针<strong>指向的地址</strong>，但不可以改变指针指向的<strong>地址的内容</strong>；</p>
<p>​
指针常量可以改变指针<strong>指向的地址内容</strong>，但不可以改变指针<strong>指向的地址</strong>；</p>
<h3 id="指针函数和函数指针不考">指针函数和函数指针（不考）</h3>
<p>​ 指针函数：函数的返回值是指针，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">func01</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​ 返回指针，实际上就是返回一个内存单元的地址。.</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">reverse</span><span class="params">(<span class="type">int</span> <span class="type">const</span> *list, <span class="type">const</span> <span class="type">int</span> size)</span> <span class="comment">// 指针函数，形参有指针常量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *result = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = size - <span class="number">1</span>; i &lt; size; i++, j--)</span><br><span class="line">	&#123;</span><br><span class="line">		result[j] = list[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> <span class="type">const</span> *list, <span class="type">const</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; list[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> list[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *pList = <span class="built_in">reverse</span>(list, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">printArray</span>(pList, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">delete</span>[] pList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
不能返回函数中局部变量的地址，这样的地址处于内存的栈区，函数结束时所占用的栈空间就释放了，回到主调函数后不能再使用该空间了。所以上面的例子中，不能在reverse函数中定义局部数组int
result[6]，使用堆空间是比较好的解决办法。</p>
<p>​ 指针和函数有着天然的联系，函数名本身就是地址。</p>
<p>​
指针不仅可以指向变量，还可以指向函数，<strong>指向函数的指针</strong>被称为<strong>函数指针</strong>，定义的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型名&gt;(*指针名)(形参列表):</span><br></pre></td></tr></table></figure>
<p>​
其中，数据类型代表函数的返回值类型，形参列表是所指函数的形参列表，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>(*fptr)(<span class="type">int</span>,<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>​
函数指针指向某个函数后，就可以像使用函数名一样使用函数指针来调用函数了。</p>
<p>​
因为函数名代表函数的内存地址，所以给函数指针赋值的时候，直接用函数名即可，不需要取地址运算符<strong>&amp;</strong>。</p>
<h3 id="指针与字符串">指针与字符串</h3>
<p>​
C++字符串常量是用双引号括起的字符序列，并以字符'\0'作为结束标志。</p>
<p>​
字符常量存放在内存的常量区域，有自己固定的首地址。如果将字符串常量的首地址看作指针，这种指针既是常指针，也是指针常量。即<strong>字符串的内容和首地址都是不能改变的。</strong></p>
<h4 id="处理字符串的两种方式">处理字符串的两种方式</h4>
<p>​ <strong>数组方式和指针方式</strong></p>
<p>​
数组方式是将字符串存入字符数组后，再进行处理，一般可以声明数组时用字符串来进行初始化。</p>
<p>​
指针方式是用<strong>字符串常量</strong>来初始化一个字符指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *string_pt=<span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​ 两种操作方式的区别：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208175347976.png" /></p>
<p>​
数组名是<strong>指针常量</strong>，是<strong>右值</strong>，不能放在等号左边。</p>
<h4 id="字符串操作函数">字符串操作函数</h4>
<p>​
C++提供了大量字符串处理函数，需要包含头文件<strong>&lt;cstring&gt;</strong>。</p>
<p>​</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 38%" />
<col style="width: 26%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">功能</th>
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">返回值</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">字符串长度</td>
<td style="text-align: center;">int strlen(const char *string);</td>
<td style="text-align: center;">长度值</td>
<td style="text-align: center;">'\0'不计入</td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串复制</td>
<td style="text-align: center;">char <em>strcpy(char </em>s1,const char
*s2);</td>
<td style="text-align: center;">复制的字符串</td>
<td style="text-align: center;">s1要有足够的空间</td>
</tr>
<tr class="odd">
<td style="text-align: center;">按字符数复制</td>
<td style="text-align: center;">char <em>strncpy(char </em>s1,const char
*s2,int n)</td>
<td style="text-align: center;">复制的字符串</td>
<td style="text-align: center;">s1要有足够的空间</td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串比较</td>
<td style="text-align: center;">int strcmp(const char <em>s1,const char
</em>s2);</td>
<td style="text-align: center;">&lt;0,=0,&gt;0
对应s1&lt;s2,s1=s2,s1&gt;s2</td>
<td style="text-align: center;">按字符顺序比较ACSII码值的大小</td>
</tr>
<tr class="odd">
<td style="text-align: center;">字符串连接</td>
<td style="text-align: center;">char <em>strcat(char </em>s1,const char
*s2);</td>
<td style="text-align: center;">连接后的字符串</td>
<td style="text-align: center;">s1要有足够的空间</td>
</tr>
</tbody>
</table>
<p>​
多数函数是以字符指作为形式参数，源字符串都是常指针，以保护原来的数据。</p>
<h2 id="指针与数组">指针与数组</h2>
<p>​ 数组名本身就是地址</p>
<h3 id="通过指针访问一维数组">通过指针访问一维数组</h3>
<p>​ 一维数组名就是数组的地址，一维数组名可以看做指针，具有以下特点：</p>
<ul>
<li><p>指针的类型是指向数组元素的指针，因此，数组名也是数组第一个元素的地址，对于数组A来说，数组名A和&amp;A[0]具有相同的类型和相同的值；</p></li>
<li><p>通过数组名的间接引用运算，如*A，就可以访问数组的第一个元素A[0]；</p></li>
<li><p>数组名所包含的地址值是不可改变的，是指针常量；</p>
<p>要通过指针访问一维数组，必须先声明一个和数组类型相同的指针，并且用数组名来对指针进行初始化，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">10</span>],*pa=A;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过数组名或所定义的指针变量，用以下多种方式访问数组元素</p></li>
<li><p>数组名和下标</p></li>
<li><p>指针和下标，如pa[0],pa[4]</p></li>
<li><p>指针加偏移量的间接引用</p></li>
<li><p>数组名加偏移量的间接引用</p></li>
<li><p>指针自加后的间接引用，如*pa++，但这种方式会改变指着本身的值</p></li>
</ul>
<p>​
但是，不允许数组名自加后的间接引用来访问数组元素，如*A++，因为数组名是常量</p>
<h3 id="指针数组">指针数组</h3>
<p>​ 若数组元素是某种类型的指针，称这样的数组为指针数组。</p>
<p>​ 指针数组的声明格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt; *&lt;数组名&gt;\[常量表达式]</span><br></pre></td></tr></table></figure>
<p>​ 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> (member_name[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>​ 使用较多的是指向字符的指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *member_name[] = &#123;<span class="string">&quot;Merry&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Hill&quot;</span>&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The namelist show as:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; member_name[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="指针数组作为main函数的形参不考">指针数组作为main函数的形参（不考）</h3>
<p>​ 命令行参数是main函数的参数。带有命令行参数的main函数的原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;<span class="built_in">main</span>(<span class="type">int</span> argc,<span class="type">char</span> *argv\[]);</span><br></pre></td></tr></table></figure>
<p>​ 可见，有两个命令行参数</p>
<p>​
argc：整数，存放命令行参数的数目，这个参数不需要用户输入，由程序自动统计，所统计的命令行参数包括所执行的程序名。</p>
<p>​
argv[]：指针数组，存放所输入的命令行参数。命令行参数都看做是字符串，用空格隔开，回车结束。指针数组中存放各个字符串的地址。其中argv[0]是所执行的程序名，argv[argc-1]是最后一个输入的参数字符串，argv[argc]中自动存入NULL，表示输入结束。</p>
<h3 id="二维数组与指针">二维数组与指针</h3>
<p>​
二维数组可以看成是一维数组的一维数组。二维数组名虽然也是地址，但是却与一维数组有不同的类型。</p>
<p>​
对于一维数组A[5]，数组名A的地址就是<strong>数组第一个元素A[0]的地址</strong>。指针的类型是<strong>指向数组元素的指针</strong>，A+1就是元素A[1]的地址。</p>
<p>​
对于二维数组B[3][4],数组名B的地址，则是其中第一个一维数组B[0]的地址。指针的类型是<strong>指向一维数组的指针</strong>。B+1就是下一个一维数组B[1]的地址。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208183728480.png" /></p>
<p>​
数组名B和C虽然都是指向一维数组的指针，两者还是有差别：所指向的一维数组的大小不同。</p>
<p>​ 因此在定义指向一维数组的指针时，还必须指出一维数组的大小。</p>
<p>​ 指向一维数组的指针的格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型名&gt;(*指针变量名)[一维数组大小];</span><br></pre></td></tr></table></figure>
<p>​ 例如，和上图中两个二维数组所对应的指向一维数组的指针定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> (*ptchb)[<span class="number">4</span>],(ptchc)[<span class="number">2</span>];</span><br><span class="line">ptchb=B;</span><br><span class="line">ptchc=C;</span><br></pre></td></tr></table></figure>
<p>​
这样定义后，ptchb就是指向一维数组B[0]的指针，ptchb+1就是指向一维数组B[1]的指针。</p>
<p>​ 对于指向一维数组的指针，具有以下特征：</p>
<ul>
<li>二维数组名是<strong>指向一维数组的指针</strong>，而不是指向<strong>数组元素的指针</strong>；</li>
<li>指向一维数组指针加1的结果，是指向<strong>下一个一维数组</strong>的指针。若ptchb指向一维数组B[0]，ptchb+1就是指向一维数组B[1]；</li>
<li>指向一维数组的指针的间接引用的结果<strong>仍然是地址</strong>（ptchb指向的内存单元内仍然是地址），即<strong>*ptchb仍然是地址</strong>，只是地址的类型变了，变为一维数组B[0]第一个元素B[0][0]的地址。*ptchb+1是B[0][0]下一个元素的地址，即B[0][1]的地址；</li>
</ul>
<p>​
因为*ptchb是数组元素的地址，**ptchb就是数组元素的值。用指向一维数组指针访问数组元素的一般公式是：<strong>*(*(指针名+i)+j)</strong>是<strong>第i行第j列</strong>元素的地址：(指针名+i)是二维数组第i行的地址，*(指针名+i)是第i行第0列元素的地址，(*(指针名+i)+j)是第i行第j列元素的地址</p>
<p>​ 借助于指向一维数组指针的概念，可以用单循环访问二维数组。</p>
<h2 id="指针与结构体">指针与结构体</h2>
<p>​ 可以定义指向结构型数据类型的指针变量。</p>
<p>​ 声明了指向结构的指针后，必须对指针进行初始化。</p>
<ul>
<li><p>可以将结构变量的地址赋给结构指针，使用取地址符&amp;操作，得到结构变量的地址，这个地址是结构的第一个成员的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line">student stu=&#123;<span class="number">20041118</span>,<span class="string">&quot;Li Li&quot;</span>,<span class="number">81</span>&#125;</span><br><span class="line">student *ps=&amp;stu</span><br></pre></td></tr></table></figure></li>
<li><p>使用new操作在堆中给结构指针分配空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student *ps=<span class="keyword">new</span> student;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​
用结构指针访问结构成员时，<strong>用箭头操作符代替原来的点操作符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;ps-&gt;score;</span><br></pre></td></tr></table></figure>
<p>​ <strong>ps-&gt;score等价于(*ps).score</strong>。</p>
<p>​
结构体指针数组，每个元素是结构体变量的地址，用交换指针代替交换结构体变量。</p>
<p>​
链表是通过指针链接在一起的一组数据项，是一种非常有用的<strong>动态数据结构</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	student *next; <span class="comment">// 指向下一个学生的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student *head = <span class="literal">NULL</span>, *temp = <span class="literal">NULL</span>;</span><br><span class="line">	head = <span class="keyword">new</span> student;</span><br><span class="line">	temp = head;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp-&gt;num = i;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please input name and score for No.&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//建立4个节点的链表</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp-&gt;next = <span class="keyword">new</span> student;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp = head;</span><br><span class="line">	<span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; temp-&gt;num &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; temp-&gt;name &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; temp-&gt;score &lt;&lt; endl;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
main函数首先定义了头节点指针：<code>student *head</code>;并申请动态内存，再存储几个学生的信息，会组成如下图的链表</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208190629572.png" /></p>
<h2 id="void类型的指针">void类型的指针</h2>
<p>​ void类型指针声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *&lt;指针名&gt;;</span><br></pre></td></tr></table></figure>
<p>​ void类型指针也指向内存地址，但是不指定这个地址单元内的数据类型。</p>
<p>​ void类型指针有如下特点：</p>
<ul>
<li>任何其他类型的指针都可以赋值给void指针。但是这样赋值后的void的指针类型仍然是void；</li>
<li>void类型指针不可以直接赋值给任何其他类型的指针；</li>
<li>无论何时，void类型的指针都不能通过间接引用来访问内存中的数据，因为只要是数据就有类型，不存在“无类型”的数据</li>
<li>要通过void类型指针访问内存中的数据，必须进行指针类型的强制转换。</li>
</ul>
<p>​
void类型一般不会独立使用，而是作为指针类型转换的中介：将某种类型的指针转换为void指针，进行具体操作后，再转换回原来的类型。</p>
<p>​
C++有一个通用的内存区域的复制函数<strong>memcpy()</strong>，它就是将某种数据类型的地址转换void指针，进行复制后再强制转换为原来的类型地址类型。该函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest,<span class="type">const</span> <span class="type">void</span> *src,<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
函数有3个形参：源地址指针、目的地址指针、复制字节数。两个指针都是void类型，所以可以接受任何类型的实参指针。函数返回值是void类型目的地址指针，可以赋值给任何类型的指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[<span class="number">10</span>]=<span class="string">&quot;012345678&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span>* pc=(<span class="type">char</span>*)<span class="built_in">memcpy</span>(dest,src,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>​
void类型指针还可以显示字符指针的内容。除了字符指针以外，指针都可以直接用cout输出地址值，但是用cout输出字符指针时，则是输出它所指向的字符串。可以将字符指针强制转换为void指针，再用cout输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pch=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">cout&lt;&lt;pch&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;(<span class="type">void</span>*)pch&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏和指针悬挂">内存泄漏和指针悬挂</h2>
<p>​ 内存泄漏：动态申请的内存空间没有正常释放，但是也不能继续使用</p>
<p>​ 指针悬挂：让指针指向一个已经释放了的空间</p>
<h2 id="关于const">关于const</h2>
<p>​
<strong>const默认作用于其左边的东西，如果左边没东西，则作用于其右边的东西。</strong></p>
<p>​ <strong>const int</strong>*</p>
<p>​ const
要作用于左边的东西，但是左边没东西，所以const修饰int成<strong>常量整型，</strong>然后*再作用于<strong>常量整型。</strong>所以这是<strong>a
pointer to a constant
integer</strong>（指向一个整型，不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址）即<strong>常指针</strong></p>
<p>​ <strong>int* const</strong></p>
<p>​
这个const的左边是*，所以const作用于指针（不可改变指向的地址），所以这是<strong>a
constant pointer to an
integer</strong>，可以通过指针改变其所指向的内容但只能指向该地址，不可指向别的地址。即指针常量</p>
<p>​ <strong>const int* const</strong></p>
<p>​ 这里有两个const。左边的const
的左边没东西，右边有int那么此const修饰int。右边的const作用于*使得指针本身变成const（不可改变指向地址），那么这个是<strong>a
constant pointer to a constant
integer</strong>，不可改变指针本身所指向的地址也不可通过指针改变其指向的内容。</p>
<p>​ <strong>int const * const</strong></p>
<p>​
这里也出现了两个const，左边都有东西，那么左边的const作用于int，右边的const作用于*，于是这个还是<strong>a
constant pointer to a constant integer</strong>。</p>
<h2 id="小结">小结</h2>
<p>​ 指针的特点是可变性，即指针内的地址是可变的。</p>
<p>​ 引用的特点是不变性，一个变量的引用只能和这个变量联系在一起。</p>
<h2 id="题目-1">题目</h2>
<p><strong>以下程序在使用指针时有没有问题？运行后是否有问题？</strong>此题存疑</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *pch;</span><br><span class="line">    pch=<span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(pch,<span class="string">&quot;Book&quot;</span>);</span><br><span class="line">    cout&lt;&lt;pch&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> pch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在编译时没有错误。但是，存在内存泄漏问题，申请的堆内存没有释放，运行时也会出现错误。因为delete语句要释放的不是堆内存的地址；pch中现在是字符串地址，这样的地址不需要通过delete释放，也不可以通过delete释放。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209213603588.png" /></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> *pa, <span class="type">int</span> n, <span class="type">int</span> *pmin, <span class="type">int</span> *pflag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pmin = *pa;</span><br><span class="line">    *pflag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa[i] &lt; *pmin)</span><br><span class="line">        &#123;</span><br><span class="line">            *pmin = *(pa + i);</span><br><span class="line">            *pflag = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>&#125;, min, ind;</span><br><span class="line">    <span class="built_in">search</span>(a, <span class="number">10</span>, &amp;min, &amp;ind);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The min element is:&quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Its num is:&quot;</span> &lt;&lt; ind;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="有点意思的字符串与指针与字符数组">有点意思的字符串与指针与字符数组</h2>
<p>​
字符指针：指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的首地址。将字符串的首地址赋给字符指针，可让字符指针指向一个字符串</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​ 字符数组：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr=str;<span class="comment">//等价于</span></span><br><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line">ptr=str;</span><br></pre></td></tr></table></figure>
<p>​ 函数strcpy:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> <span class="comment">//把src所指向的字符串复制到dest中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* ret = dest;<span class="comment">//存入地址方便返回dest原始地址</span></span><br><span class="line">	<span class="built_in">assert</span>(dest &amp;&amp; src);<span class="comment">//断言，防止传入空指针</span></span><br><span class="line">	<span class="keyword">while</span> (*dest++ = *src++) <span class="comment">//先++后赋值；因为是后置++；所以赋值后在执行自增操作</span></span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入两个数组指针dest，src，返回指针指向dest首地址</p>
<p>定义ret指针存入dest地址
assert（断言），需引入头文件,对不符合要求的传参发出警告 <strong>while
(dest++ = src++)</strong>
代码执行，src指针++，因为是后置++，先赋值后++，src首地址所指向的第一个数据传入dest中的首地址中，修改值,while判断（）中值为真，即不为0；循环继续
src++ dest++ 两个指针后移，依次进行上续操作，直至src指向 ‘\0’
src为’\0’,先赋值给dest，++后，while判断，‘\0’,值为假，跳出循环
返回dest首地址</p>
<h1 id="第七章类与对象">第七章：类与对象</h1>
<h2 id="类和对象的定义">类和对象的定义</h2>
<h3 id="基本概念">基本概念</h3>
<p>​ 类代表一类事物，事物具有相应的特征和属性。</p>
<p>​ 类有数据成员和成员函数。</p>
<p>​
类是一种用户自定义的数据类型，与结构体类似，但类的成员是默认private的，不可以任意访问。</p>
<p>​ 类和对象具有继承和多态的特性。</p>
<h3 id="类的声明">类的声明</h3>
<p>​ 类是一组对象的抽象化模型。</p>
<p>​ 声明类的语法形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名称</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		私有成员;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		保护型成员;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		公有成员;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>​ 成员既可以是数据成员，也可以是成员函数的原型。</p>
<p>​ 类的成员包括数据成员和函数成员，分别描述问题的属性和操作。</p>
<p>​
数据成员的声明和一般变量相同，函数成员用于描述类的对象可以进行的操作，一般在类中声明原型，在类声明之后定义函数的具体实现。</p>
<p>​ 根据访问权限不同，类成员可以分为3类：</p>
<ul>
<li>私有成员：只允许本类的成员函数来访问；</li>
<li>公有成员：类对外的窗口，允许外界访问；</li>
<li>保护型成员：可访问性与私有成员性质类似，差别在于继承过程中对派生类的影响不同；</li>
</ul>
<p>​ 默认的访问属性是private。</p>
<h3 id="类的实现">类的实现</h3>
<p>​
类的成员函数描述的是类的行为或操作。函数的原型声明要在类的主体中，而函数的具体实现一般写在类声明之外。</p>
<p>​ 定义成员函数的语法形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 通过类名和作用域操作符"::"来表示函数属于哪个类。</p>
<p>​ 类的成员函数还可以有多种形态：</p>
<ul>
<li><p>带默认参数值的成员函数，默认值要写在函数原型声明中，调用规则与普通函数相同；</p></li>
<li><p>内联成员函数：</p>
<ul>
<li><p>声明方式：<strong>隐式声明和显式声明</strong></p></li>
<li><p>隐式声明：在类声明时定义的成员函数都是<strong>内联函数</strong>。函数定义时没有任何的附加说明，所以称为隐式声明。</p></li>
<li><p>显式声明：在类声明之后定义内联函数需要用关键词inline</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> 返回值类型 类名::成员函数名(参数表)&#123;函数体&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>成员函数的重载</p>
<p>成员函数可以像普通函数那样重载。类名也是成员函数名的一部分，所以一个类的成员函数即使与另一个类的成员函数同名，也不能认为是重载。</p></li>
</ul>
<h3 id="对象的定义和使用">对象的定义和使用</h3>
<p>​ 语法形式：类名称 对象名称;</p>
<p>​
一个对象所占空间是类的数据成员所占的空间总和。类的成员函数存放在代码区，不占用栈和堆空间。</p>
<p>​ <strong>类的成员是抽象的，对象的成员才是具体的。</strong></p>
<p>​
类声明中的数据成员一定不能具有具体的属性值，只有对象的成员才具有具体的属性值。</p>
<p>​ 数据成员的访问语法形式：<strong>对象名.公有数据成员</strong></p>
<p>​
如果是函数成员，其一般形式为：<strong>对象名.公有成员函数名(参数表)</strong></p>
<h3 id="类的作用域与可见性">类的作用域与可见性</h3>
<h4 id="类的作用域">类的作用域</h4>
<p>​
一个类的所有成员位于这个类的作用域内，一个类的所有成员函数都能访问这个类的所有成员，C++认为一个类的全部成员是一个整体的相关部分。</p>
<p>​
类作用域是指<strong>类定义和相应的成员定义的范围</strong>，通俗地称为类的内部。在该范围内，一个类的成员函数对本类的其他成员具有<strong>无限制</strong>的访问权。</p>
<h4 id="类的可见性">类的可见性</h4>
<p>​
类名实际上是个类型名，允许<strong>类与其他类型变量或其他函数</strong>同名。</p>
<p>​
在类的内部，与<strong>类或类的成员同名</strong>的全局变量名或函数名不可见。</p>
<p>​
在一个函数内，同名的类和变量可以<strong>同时使用</strong>，都是可见的。</p>
<h2 id="构造函数">构造函数</h2>
<p>​
类和对象的关系是简单数据类型与其变量的关系，也就是一般与特殊的关系。</p>
<p>​
C++中对象的初始化由<strong>构造函数</strong>完成，清理由<strong>析构函数</strong>完成。</p>
<p>​ <strong>析构的顺序与构造的顺序相反。</strong></p>
<h3 id="构造函数的定义">构造函数的定义</h3>
<p>​ 定义构造函数的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		类名(形参表);<span class="comment">//构造函数原型</span></span><br><span class="line">	<span class="comment">//类的其它成员</span></span><br><span class="line">&#125;;</span><br><span class="line">类名::类名(形参表)<span class="comment">//构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 构造函数可以在类的内部实现，也可以在外部实现。</p>
<p>​
构造函数的特点：<strong>构造函数的名称和类名相同，构造函数没有返回值，构造函数一定是公有函数。</strong></p>
<p>​ 构造函数可以带默认形参值，也可以重载。</p>
<h3 id="构造函数的重载">构造函数的重载</h3>
<p>​ 构造函数可以像普通函数那样重载，根据需要选用。</p>
<h3 id="带默认值的构造函数">带默认值的构造函数</h3>
<p>​ 同普通函数相同。</p>
<h3 id="默认构造函数和无参构造函数">默认构造函数和无参构造函数</h3>
<p>​
没有定义类的构造函数时，编译器会在编译时自动生成一个默认形式的构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::类名()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​ 一个既没有形参，也没有任何语句的函数。</p>
<p>​ 只有在类中没有定义任何构造函数的情况下，才能使用默认构造函数。</p>
<p>​ 无参构造函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名::类名()&#123;语句&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>程序中不能同时出现无参数构造函数和带有全部默认参数的构造函数</strong>，否则会出现编译错误。</p>
<h3 id="复制构造函数">复制构造函数</h3>
<p>​ 用来复制一个对象。</p>
<p>​
<strong>复制构造函数就是函数形参是类的对象的引用的构造函数。</strong></p>
<p>​ 定义一个复制构造函数的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		类名(类名&amp; 对象名);<span class="comment">//复制构造函数原型</span></span><br><span class="line">&#125;;</span><br><span class="line">类名::类名(类名&amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">complex</span>(<span class="type">const</span> complex &amp; c)<span class="comment">//自己定义了一个复制构造函数 </span></span><br><span class="line">	  &#123;</span><br><span class="line">	  	real=c.real;</span><br><span class="line">	  	imag=c.imag;</span><br><span class="line">	  	cout&lt;&lt;<span class="string">&quot;复制构造函数&quot;</span>; </span><br><span class="line">	   &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是<strong>本类对象的引用</strong>，其作用是使用一个已经存在的对象去初始化一个新的同类的对象。</p>
<p>​
复制构造函数和原来的构造函数实现了<strong>函数的重载</strong>，如果程序没有显式定义复制构造函数，系统也会默认生成一个，将成员值一一复制。</p>
<p>​
但某些情况必须显式定义一个复制构造函数。例如，当类的成员包括指针变量时，类的构造函数用new运算符为这个指针动态申请空间，如果复制时只是简单的一一复制，就会出现两个对象指向相同的堆地址，程序就会报错，这时候就必须定义复制构造函数，在其中为新对象申请新的堆空间。</p>
<h2 id="析构函数">析构函数</h2>
<p>​ 对象所占用的空间要通过析构函数来释放，函数原型是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~类名()；</span><br></pre></td></tr></table></figure>
<p>​ 如果程序不定义析构函数，系统也会提供一个默认的析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~类名()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这个析构函数不能释放堆空间。</p>
<p>​
析构函数也是类的一个公有成员函数，没有返回值，<strong>没有形式参数</strong>。</p>
<p>​
析构函数在<strong>对象生存期即将结束</strong>的时刻由系统自动调用的。</p>
<p>​ <strong>类的析构函数不能重载</strong>，因为析构函数没有参数。</p>
<h2 id="面向对象设计">面向对象设计</h2>
<h3 id="类的封装性">类的封装性</h3>
<p>​ 将<strong>数据和操作数据的行为</strong>进行有机结合就是封装性。</p>
<p>​
类是<strong>属性和操作的结合体</strong>，并在定义类的属性和操作时，规定了它们的可见性。</p>
<p>​ 封装有两个含义：</p>
<ol type="1">
<li><strong>包装</strong>，将对象的全部属性和操作结合在一起</li>
<li><strong>信息隐藏</strong></li>
</ol>
<p>​
封装性是面向对象的重要原则。对象的属性和操作的紧密结合反映了事物的静态特征和动态特征，封装的信息隐藏能力反映了事物的相对独立性。</p>
<h3 id="软件工程">软件工程</h3>
<p>​ 可靠性，成本效益好，可理解性，可维护性。</p>
<p>​
面向对象首先是一种思想，面向对象程序设计是面向对象思想在软件工程领域的全面应用。</p>
<h3 id="面向对象的意义">面向对象的意义</h3>
<ol type="1">
<li>模块化</li>
<li>软件复用</li>
</ol>
<h2 id="对象数组">对象数组</h2>
<p>​ 数组的元素可以是自定义的类类型。</p>
<p>​
对象数组的元素是对象，不仅具有数据成员，还有函数成员，可以通过数组元素调用成员函数。</p>
<p>​ 析构的顺序与构造的顺序相反。</p>
<h2 id="使用对象传递函数参数">使用对象传递函数参数</h2>
<p>​ 类类型可以作为函数的一个参数类型和返回值类型。</p>
<p>​
如果类的数据成员较多，需要一一复制，这时候用对象指针或对象引用的方式来传递函数参数。</p>
<h2 id="对象指针和堆对象">对象指针和堆对象</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clock c;<span class="comment">//在栈中分配Clock型存储空间空间</span></span><br><span class="line">Clock *pc1=<span class="keyword">new</span> Clock;<span class="comment">//在堆中分配Clock型存储空间空间</span></span><br><span class="line">Clock *pc2=&amp;c;</span><br></pre></td></tr></table></figure>
<p>​
对象指针就是用于<strong>存放对象地址的变量</strong>，可以用new在堆中给对象分配存储空间，也可以使用一个已有对象初始化对象指针。</p>
<p>​ 对象指针遵循一般变量指针的规则，声明对象指针的一般语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 *对象指针名;</span><br></pre></td></tr></table></figure>
<p>​
使用对象指针访问对象的成员，要使用“<strong>-&gt;</strong>”运算符，语法形式为：<strong>对象指针名-&gt;公有成员;</strong></p>
<h2 id="this指针">this指针</h2>
<p>​ <strong>在类的外部访问类的成员必须通过对象来调用。</strong></p>
<p>​ 成员函数是如何识别不同变量属于哪个对象呢？</p>
<p>​
对象在调用成员函数时，还接收了一个地址参数，这个参数的数据类型是<strong>类名</strong>*，形式参数的名称为this，因此成员函数的原型实际上是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型名 函数名(类名 *<span class="keyword">this</span>,形参<span class="number">1</span>,形参<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<p>​
当调用时，系统会自动<strong>取对象的地址</strong>作为实际参数赋给this指针。</p>
<p>​ 需要时可以显式地使用this指针。</p>
<p>​
在成员函数内部，所有对类成员的访问都可以加上<strong>隐含的前缀this-&gt;</strong>。</p>
<p>​
<strong>this指针指出了成员函数当前所操作的数据所属的对象</strong>，不同的对象调用成员函数时，this指针将指向不同的对象，也就可以访问不同对象的数据成员。</p>
<p>​ 有时需要在成员函数中用*this来标识正在调用该函数的对象。</p>
<h2 id="复制析构函数">复制析构函数</h2>
<p>​
当构造时从堆中为对象的成员分配存储空间，在对象生存期结束时，把堆空间释放，归还给系统，需要定义一个复制构造函数。</p>
<h2 id="内部类和命名空间">内部类和命名空间</h2>
<p>​ 把一个类的定义写在另一个类的内部，称其为内部类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//定义内部类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">public</span>:</span><br><span class="line">				<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
上面的代码将类Inner定义在AAA内部，此时内部类的类名全称为：AAA:Inner，使用时要用类全名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	AAA:Inner a;</span><br><span class="line">	<span class="built_in">strcpy</span>(a.name,<span class="string">&quot;xulei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
内部类在使用上和普通类<strong>几乎没有区别</strong>，外部类AAA不能自由访问内部类的成员，内部类Inner也不能自由访问外部类的成员，<strong>相当于把Inner写在外面</strong>。</p>
<p>​
内部类的用途主要是为了<strong>避免类名的冲突</strong>。当发现一个类仅在局部使用时，就可以定义一个内部类。</p>
<p>​ 命名空间是解决名字冲突的终极方案，语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ID</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
可以把很多的名字：类名、函数名、全局变量名，定义在一个命名空间ID里，以后使用ID作为前缀，ID要在<strong>整个项目</strong>里<strong>全局唯一</strong>。</p>
<p>​
在main函数中使用命名空间里的名字时，需要<strong>加上前缀</strong>，如果确定不会有名字冲突，可以使用<strong>using</strong>语句来解除前缀。</p>
<h2 id="题目-2">题目</h2>
<p><strong>类和对象的区别是什么？</strong>
一个类表示现实生活中的一类事物，是抽象的，对象是一类事物中的一个具体的个体，即对象是类的一个具体的实例，类和对象的关系相当于普遍与特殊的关系。在C++中，类是一个自定义的数据类型，对象是该数据类型的一个变量。</p>
<p><strong>什么时候系统会调用复制构造函数？</strong>
复制构造函数在以下三种情况下都会被调用:
1.用类的一个对象去初始化该类的另外一个对象
2.如果函数的形参是类的对象，调用函数时，进行形参和实参结合时
3.如果函数的返回值是类的对象，函数执行完成返回调用者时</p>
<h1 id="第八章继承">第八章：继承</h1>
<h2 id="继承的概念">继承的概念</h2>
<p>​
继承是在现有的类的基础上创建新类，并<strong>扩展</strong>现有类的功能的机制，称现有的类为<strong>基类(Base
Class)</strong>，新建立的类为<strong>派生类(Derived
Class)</strong>。</p>
<p>​
“派生”可以理解为继承的另外一种说法。类D继承了类B可以表述为类B派生出类D。若类B派生出类D1、D2...，可以说B是D1、D2...的繁华，称B为D1、D2...的基类，称D1、D2为B的派生类。</p>
<p>​ <strong>“基类-派生类”=“父类(Parent Class)-子类(Child
Class)”=“超类(Superclass)-子类(Subclass)”</strong></p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209113316738.png" /></p>
<p>​
泛化是一个从<strong>特殊到一般</strong>的总结过程，将子类的共同特征抽象出来，得到父类。</p>
<p>​
若派生类<strong>只有一个直接基类</strong>，则称这种继承方式为<strong>单继承</strong>；若派生类有<strong>多个直接基类</strong>，则称为多继承。</p>
<p>​
如非必要，不推荐使用多继承，多继承的问题可以使用类的组合的方法来代替。</p>
<h2 id="基类和派生类">基类和派生类</h2>
<p>​
如何从基类得到派生类。基类的成员会被继承到派生类中，但是这些成员在派生类的访问控制属性受到继承方式的影响，同时继承还会导致<strong>同名覆盖</strong>。</p>
<ul>
<li>派生类继承了基类的所有成员，派生类对象包括基类的数据成员，也可以直接调用基类公有函数；</li>
<li>派生类对象不可以直接访问基类的私有成员；</li>
<li>派生类对象可以通过基类的公有函数访问基类的私有成员；</li>
</ul>
<h3 id="定义派生类">定义派生类</h3>
<p>​ 语法格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 继承方式 基类<span class="number">1</span>,继承方式 基类<span class="number">2</span>,...,继承方式,基类n&#123;</span><br><span class="line">    	派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 如果仅有一个基类，那么就是单继承，否则是多继承。</p>
<p>​
继承方式是<strong>public、private和protected</strong>三者之一，不同的继承方式会影响<strong>基类成员</strong>在<strong>派生类</strong>的访问控制属性。</p>
<p>​
派生类继承了基类的所有成员，但<strong>不包括构造函数、析构函数和默认赋值运算符。</strong></p>
<h3 id="继承方式和访问控制">继承方式和访问控制</h3>
<h4 id="protected属性">protected属性</h4>
<p>​
派生类希望访问基类的一些成员，但仍然禁止用户代码访问这些成员，此时，需要将基类成员设置为protected访问方式。</p>
<p>​
类的对象不能访问protected属性的成员，但是派生类的成员函数可以访问基类的protected属性的成员。</p>
<ul>
<li>protected成员不能通过本类对象访问(在类的外部)；</li>
<li>protected成员可以被派生类成员函数访问(在派生类内部)；</li>
<li>protected成员不能通过派生类对象访问(在类的外部)；</li>
</ul>
<h4 id="继承方式影响访问控制">继承方式影响访问控制</h4>
<ol type="1">
<li><p>派生类的成员函数对所继承的基类成员的访问控制</p>
<p>派生类成员函数都可以访问基类的public和protected成员，但不能访问基类的private成员</p></li>
<li><p>派生类对象对所继承的基类成员的访问控制</p>
<p>只有public继承的派生类对象可以访问基类的public成员，protected和private继承的派生类对象不能访问基类public成员</p></li>
<li><p>基类成员的访问属性在派生类中的变化</p>
<ul>
<li>对于<strong>public继承</strong>，基类的public成员、protected成员在派生类中仍然<strong>保持</strong>原来的访问属性；</li>
<li>对于<strong>protected继承</strong>，基类的public成员和protected成员在派生类中变为<strong>protected属性</strong>；</li>
<li>对于<strong>private继承</strong>，基类的public成员、protected成员在派生类中<strong>都变为private属性</strong>；</li>
<li>不论是哪种继承方式，基类的private成员在派生类中都不可被访问；</li>
</ul></li>
</ol>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209123159944.png" /></p>
<p>​
private继承看似好像不影响派生类成员对基类public和protected成员的访问。但如果有连续两次的private继承，基类的public和protected成员在最下面一层的派生类中都将不能访问。</p>
<h2 id="同名覆盖">同名覆盖</h2>
<p>​
同名覆盖：派生类修改基类的成员，是在派生类中<strong>声明了一个与基类成员同名的新成员</strong>。在<strong>派生类作用域内或者在类外通过派生类的对象直接使用</strong>这个成员名，只能访问到派生类中声明的同名新成员，这个新成员覆盖了从基类继承的新成员。</p>
<h2 id="派生类的构造和析构">派生类的构造和析构</h2>
<p>​
派生类需要定义自己的构造函数和析构函数。派生类的构造和析构函数会受到基类构造和析构函数的影响。</p>
<h3 id="基类只有无参构造函数">基类只有无参构造函数</h3>
<p>​
基类具有无参构造函数，派生类又没有定义自己的构造函数，系统会<strong>自动调用基类的无参构造函数来</strong>构造派生类对象中的<strong>基类成分</strong>。</p>
<p>​
基类没有无参构造函数，派生类也不定义自己的构造函数，便会发生语法错误。</p>
<p>​ 基类的构造函数一般被声明为<strong>public</strong>访问控制方式。</p>
<h3 id="派生类构造函数">派生类构造函数</h3>
<p>​
一般来说，派生类构造函数要<strong>初始化本类的数据成员</strong>，还要<strong>调用基类的构造函数</strong>，<strong>并为基类构造函数传递参数</strong>，完成派生类中<strong>基类成分的初始化</strong>。</p>
<p>​ 派生类构造函数的形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">派生类名::派生类名(基类所需的形参,本类成员所需的形参):</span><br><span class="line">	基类<span class="number">1</span>(基类参数表<span class="number">1</span>),基类<span class="number">2</span>(基类参数表<span class="number">2</span>),...,基类<span class="built_in">n</span>(基类参数表n)</span><br><span class="line">&#123;</span><br><span class="line">	本类基本类型数据成员初始化:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
“基类1(基类参数表1),基类2(基类参数表2),...,基类n(基类参数表n)”称为<strong>构造函数初始化列表</strong>，简称为<strong>初始化列表</strong>，用来调用基类构造函数以及为基类构造函数传递参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span></span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    yellow,</span><br><span class="line">    blue,</span><br><span class="line">    white,</span><br><span class="line">    black</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *author;</span><br><span class="line">    color s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> <span class="type">char</span> *, color);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">(color)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; endl</span><br><span class="line">                       &lt;&lt; author &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; s; &#125;</span><br><span class="line">    ~<span class="built_in">Shape</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Shape::<span class="built_in">Shape</span>(<span class="type">const</span> <span class="type">char</span> *c, color i)</span><br><span class="line">&#123;</span><br><span class="line">    author = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(c)];</span><br><span class="line">    <span class="built_in">strcpy</span>(author, c);</span><br><span class="line">    s = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shape::Change</span><span class="params">(color i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = i;</span><br><span class="line">&#125;</span><br><span class="line">Shape::~<span class="built_in">Shape</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> <span class="type">char</span> *c, color i, <span class="type">double</span> z);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">(color, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">const</span> <span class="type">char</span> *c, color i, <span class="type">double</span> z) : <span class="built_in">Shape</span>(c, i)</span><br><span class="line">&#123;</span><br><span class="line">    r = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Change</span><span class="params">(color s, <span class="type">double</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape::<span class="built_in">Change</span>(s);</span><br><span class="line">    r = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape::<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">shape1</span><span class="params">(<span class="string">&quot;wang&quot;</span>, red)</span></span>;</span><br><span class="line">    shape1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="function">Circle <span class="title">circle1</span><span class="params">(<span class="string">&quot;zhang&quot;</span>, red, <span class="number">3</span>)</span></span>;</span><br><span class="line">    circle1.<span class="built_in">show</span>();</span><br><span class="line">    circle1.<span class="built_in">Change</span>(black, <span class="number">6</span>);</span><br><span class="line">    circle1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果是单继承，派生类构造函数的形式会更简单。</p>
<h3 id="派生类的析构函数">派生类的析构函数</h3>
<p>​
派生类不能继承基类的析构函数，需要自己的定义析构函数。派生类的析构函数只需要清理它新定义的成员，一般来说只需要清理堆区的成员。</p>
<p>​
如果没有特殊指针数据成员需要清理，可以使用由系统提供的默认析构函数。</p>
<p>​
当派生类对象消亡时，系统调用析构函数的顺序与建立派生类对象时调用构造函数的顺序正好相反，即<strong>先调用派生类的析构函数，再调用基类的析构函数</strong>。</p>
<h2 id="虚基类">虚基类</h2>
<h3 id="多继承和二义性">多继承和二义性</h3>
<p>​
多继承结构中，派生类可能有多个直接基类或间接基类，可能会引起成员访问的二义性或不确定性问题。</p>
<p>​
基类base的成员要继承到派生类Fderiver1和Fderiver2，然后又继承到派生类Sderiver，即Sderiver派生类中，基类的成员有两份拷贝。因此，通过Sderiver派生类的对象访问基类的公有成员时，编译系统就不知道应该如何从两份拷贝中进行选取，只好给出"ambiguos"的错误信息，即出现了二义性。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209125439645.png" /></p>
<p>​
二义性产生的原因是基类的构造函数调用了两次，调用两次构造函数所产生的基类成员都继承到派生类Sderiver，二义性也就产生了。如果基类构造函数只调用一次，这种类型的二义性就可以解决了。</p>
<h3 id="虚基类-1">虚基类</h3>
<p>​
我们可以将共同基类设置为虚基类，创建派生类对象时，虚基类的构造函数只会调用1次，虚基类的成员在第三层派生类对象中就只有一份拷贝，不会再引起二义性问题。</p>
<p>​
将共同基类设置为虚基类，需要在第一级派生类时就用关键字virtual修饰说明继承关系，其语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: <span class="keyword">virtual</span> 继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
在多继承情况下，虚基类关键词的作用范围和继承方式关键词相同，只对紧随其后的基类起作用。由于这一层的派生类的多个，这一层的其它派生类也需要用virtual关键词说明。</p>
<h2 id="同名覆盖和重载">同名覆盖和重载</h2>
<p>​ 同名覆盖(Override)：在类继承中才会出现</p>
<p>​
重载(Overload)：在<strong>同一作用域范围内</strong>，由<strong>参数个数或类型不同</strong>的多个<strong>同名函数</strong>构成，可以单独出现，也可以与override现象同时出现。</p>
<p>​
一般来说，同名覆盖现象中的多个函数原型(函数类型、名字、参数)是相同的，而重载现象中多个函数原型(参数)是不同的。</p>
<h2 id="转换与继承">转换与继承</h2>
<p>​ 派生类继承了基类成员，但基类成员收到访问控制的限制。</p>
<p>​ 派生类的成员与基类成员到底有上面不同呢：</p>
<p>​
每个派生类对象包含一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行基类的操作，这就涉及到派生类到基类的转换。这种转换包括以下三种情况：</p>
<ul>
<li>派生类对象转换为基类对象</li>
<li>基类对象指针指向派生类对象</li>
<li>用派生类对象初始化基类对象的引用</li>
</ul>
<h3 id="派生类对象转换为基类对象">派生类对象转换为基类对象</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TShape</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = mx;</span><br><span class="line">		y = my;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCircle</span> : <span class="keyword">public</span> TShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TCircle</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>, <span class="type">int</span> mr = <span class="number">1</span>) : <span class="built_in">TShape</span>(mx, my) &#123; r = mr; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TShape::<span class="built_in">Show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\tr=&quot;</span> &lt;&lt; r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TShape s;</span><br><span class="line">	<span class="function">TCircle <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;TShape s\t&quot;</span>;</span><br><span class="line">	s.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;TCircle c\t&quot;</span>;</span><br><span class="line">	c.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	s = c; <span class="comment">// 用派生类对象为基类对象赋值</span></span><br><span class="line">	<span class="comment">// s=static_cast&lt;TShape&gt;(c)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;s=c \t\t&quot;</span>;</span><br><span class="line">	s.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 编译后，运行的输出结果是：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TShape s        x=0      y=0</span><br><span class="line">TCircle c       x=1      y=2    r=3</span><br><span class="line">s=c             x=1      y=2</span><br></pre></td></tr></table></figure>
<p>​
派生类对象c赋值给基类对象s之后，基类对象s仅获取了派生类对象c中内嵌的TShape子对象的值，而派生类对象c中的数据成员r被忽略了。</p>
<p>​
换句话说，在s=c这个赋值语句中，派生类对象c被截断成了两部分：<strong>内嵌TShape子对象</strong>和<strong>派生类独有</strong>的数据成员。这种现象被称为“<strong>对象截断</strong>”。</p>
<p>​
s=c语句实际上执行了一个隐式类型转换，将TCircle对象转换为了TShape对象。建议用<strong>s=static_cast&lt;TShape&gt;(c)</strong>替换<strong>s=c</strong></p>
<h3 id="基类指针指向派生类对象">基类指针指向派生类对象</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TShape</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = mx;</span><br><span class="line">		y = my;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCircle</span> : <span class="keyword">public</span> TShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TCircle</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>, <span class="type">int</span> mr = <span class="number">1</span>) : <span class="built_in">TShape</span>(mx, my) &#123; r = mr; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TShape::<span class="built_in">Show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\tr=&quot;</span> &lt;&lt; r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TCircle <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;TCircle c\t&quot;</span>;</span><br><span class="line">	c.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// TShape* ps=&amp;c;</span></span><br><span class="line">	TShape *ps = <span class="built_in">dynamic_cast</span>&lt;TShape *&gt;(&amp;c); <span class="comment">// 基类对象指针指向派生类对象</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != ps)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ps=&amp;c\t\t&quot;</span>;</span><br><span class="line">		ps-&gt;<span class="built_in">Show</span>();</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 输出结果如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCircle c       x=<span class="number">1</span>      y=<span class="number">2</span>    r=<span class="number">3</span></span><br><span class="line">ps=&amp;c           x=<span class="number">1</span>      y=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​
指针变量ps的类型是<strong>基类指针</strong>，实际指向是派生类对象c的TShape内嵌对象。</p>
<p>​
换句话说，*<strong>ps</strong>就是被截断的派生类对象c的一部分。需要注意的是，ps-&gt;Show()访问的是基类的函数<strong>TShape::Show()</strong>，而不是派生类的<strong>TCircle::Show()</strong>。</p>
<h3
id="用派生类对象初始化基类对象的引用">用派生类对象初始化基类对象的引用</h3>
<p>​
与“基类对象指针指向派生类对象”的类似，区别在于，引用只能在定义时赋值(初始化)，而指针变量可以在定义之后赋值。</p>
<h3 id="基类到派生不存在转换">基类到派生不存在转换</h3>
<p>​
编译器可以自动将派生类对象转换为基类对象（隐式类型转换），但是从基类到派生类的自动转换是不存在的。</p>
<p>​
原因是基类对象不包含派生类成员，若允许用基类对象给派生类对象赋值，那么就可以试图使用该派生类对象访问不存在的成员，显然会导致错误。</p>
<h2 id="题目-3">题目</h2>
<p><strong>在类的层次结构中，采用什么顺序调用构造函数？调用析构函数的顺序是什么？</strong>
构造函数的调用次序是:基类构造函数、内嵌对象的构造函数、派生类的构造函数；析构函数的调用次序与此相反</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/Review/" rel="tag"># Review</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/archives/c0da8988.html" rel="prev" title="Linear Algebra Notes">
                  <i class="fa fa-angle-left"></i> Linear Algebra Notes
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/archives/705520af.html" rel="next" title="数分复习">
                  数分复习 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2022 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sa1geChen</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>


  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.6.1/mermaid.min.js","integrity":"sha256-mm3Re3y7xlvh+yCD+l/Zs1d+PU0AEad93MkWvljfm/s="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
